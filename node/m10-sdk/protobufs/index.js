/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
"use strict";

var $protobuf = require("protobufjs/minimal");

// Common aliases
var $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;

// Exported root namespace
var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

$root.m10 = (function() {

    /**
     * Namespace m10.
     * @exports m10
     * @namespace
     */
    var m10 = {};

    m10.sdk = (function() {

        /**
         * Namespace sdk.
         * @memberof m10
         * @namespace
         */
        var sdk = {};

        sdk.M10TxService = (function() {

            /**
             * Constructs a new M10TxService service.
             * @memberof m10.sdk
             * @classdesc Represents a M10TxService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function M10TxService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (M10TxService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = M10TxService;

            /**
             * Creates new M10TxService service using the specified rpc implementation.
             * @function create
             * @memberof m10.sdk.M10TxService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {M10TxService} RPC service. Useful where requests and/or responses are streamed.
             */
            M10TxService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link m10.sdk.M10TxService#createTransaction}.
             * @memberof m10.sdk.M10TxService
             * @typedef CreateTransactionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.transaction.TransactionResponse} [response] TransactionResponse
             */

            /**
             * Calls CreateTransaction.
             * @function createTransaction
             * @memberof m10.sdk.M10TxService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10TxService.CreateTransactionCallback} callback Node-style callback called with the error, if any, and TransactionResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10TxService.prototype.createTransaction = function createTransaction(request, callback) {
                return this.rpcCall(createTransaction, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.transaction.TransactionResponse, request, callback);
            }, "name", { value: "CreateTransaction" });

            /**
             * Calls CreateTransaction.
             * @function createTransaction
             * @memberof m10.sdk.M10TxService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.transaction.TransactionResponse>} Promise
             * @variation 2
             */

            return M10TxService;
        })();

        sdk.M10QueryService = (function() {

            /**
             * Constructs a new M10QueryService service.
             * @memberof m10.sdk
             * @classdesc Represents a M10QueryService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function M10QueryService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (M10QueryService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = M10QueryService;

            /**
             * Creates new M10QueryService service using the specified rpc implementation.
             * @function create
             * @memberof m10.sdk.M10QueryService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {M10QueryService} RPC service. Useful where requests and/or responses are streamed.
             */
            M10QueryService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#getTransfer}.
             * @memberof m10.sdk.M10QueryService
             * @typedef GetTransferCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.transaction.FinalizedTransfer} [response] FinalizedTransfer
             */

            /**
             * Calls GetTransfer.
             * @function getTransfer
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.GetTransferCallback} callback Node-style callback called with the error, if any, and FinalizedTransfer
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.getTransfer = function getTransfer(request, callback) {
                return this.rpcCall(getTransfer, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.transaction.FinalizedTransfer, request, callback);
            }, "name", { value: "GetTransfer" });

            /**
             * Calls GetTransfer.
             * @function getTransfer
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.transaction.FinalizedTransfer>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#listTransfers}.
             * @memberof m10.sdk.M10QueryService
             * @typedef ListTransfersCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.transaction.FinalizedTransfers} [response] FinalizedTransfers
             */

            /**
             * Calls ListTransfers.
             * @function listTransfers
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.ListTransfersCallback} callback Node-style callback called with the error, if any, and FinalizedTransfers
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.listTransfers = function listTransfers(request, callback) {
                return this.rpcCall(listTransfers, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.transaction.FinalizedTransfers, request, callback);
            }, "name", { value: "ListTransfers" });

            /**
             * Calls ListTransfers.
             * @function listTransfers
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.transaction.FinalizedTransfers>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#observeTransfers}.
             * @memberof m10.sdk.M10QueryService
             * @typedef ObserveTransfersCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.FinalizedTransactions} [response] FinalizedTransactions
             */

            /**
             * Calls ObserveTransfers.
             * @function observeTransfers
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.ObserveTransfersCallback} callback Node-style callback called with the error, if any, and FinalizedTransactions
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.observeTransfers = function observeTransfers(request, callback) {
                return this.rpcCall(observeTransfers, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.FinalizedTransactions, request, callback);
            }, "name", { value: "ObserveTransfers" });

            /**
             * Calls ObserveTransfers.
             * @function observeTransfers
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.FinalizedTransactions>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#getIndexedAccount}.
             * @memberof m10.sdk.M10QueryService
             * @typedef GetIndexedAccountCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.transaction.IndexedAccount} [response] IndexedAccount
             */

            /**
             * Calls GetIndexedAccount.
             * @function getIndexedAccount
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.GetIndexedAccountCallback} callback Node-style callback called with the error, if any, and IndexedAccount
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.getIndexedAccount = function getIndexedAccount(request, callback) {
                return this.rpcCall(getIndexedAccount, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.transaction.IndexedAccount, request, callback);
            }, "name", { value: "GetIndexedAccount" });

            /**
             * Calls GetIndexedAccount.
             * @function getIndexedAccount
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.transaction.IndexedAccount>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#getAccount}.
             * @memberof m10.sdk.M10QueryService
             * @typedef GetAccountCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.model.Account} [response] Account
             */

            /**
             * Calls GetAccount.
             * @function getAccount
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.GetAccountCallback} callback Node-style callback called with the error, if any, and Account
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.getAccount = function getAccount(request, callback) {
                return this.rpcCall(getAccount, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.model.Account, request, callback);
            }, "name", { value: "GetAccount" });

            /**
             * Calls GetAccount.
             * @function getAccount
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.model.Account>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#getAccountInfo}.
             * @memberof m10.sdk.M10QueryService
             * @typedef GetAccountInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.model.AccountInfo} [response] AccountInfo
             */

            /**
             * Calls GetAccountInfo.
             * @function getAccountInfo
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.GetAccountInfoCallback} callback Node-style callback called with the error, if any, and AccountInfo
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.getAccountInfo = function getAccountInfo(request, callback) {
                return this.rpcCall(getAccountInfo, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.model.AccountInfo, request, callback);
            }, "name", { value: "GetAccountInfo" });

            /**
             * Calls GetAccountInfo.
             * @function getAccountInfo
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.model.AccountInfo>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#listAccounts}.
             * @memberof m10.sdk.M10QueryService
             * @typedef ListAccountsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.ListAccountsResponse} [response] ListAccountsResponse
             */

            /**
             * Calls ListAccounts.
             * @function listAccounts
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.ListAccountsCallback} callback Node-style callback called with the error, if any, and ListAccountsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.listAccounts = function listAccounts(request, callback) {
                return this.rpcCall(listAccounts, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.ListAccountsResponse, request, callback);
            }, "name", { value: "ListAccounts" });

            /**
             * Calls ListAccounts.
             * @function listAccounts
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.ListAccountsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#observeAccounts}.
             * @memberof m10.sdk.M10QueryService
             * @typedef ObserveAccountsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.FinalizedTransactions} [response] FinalizedTransactions
             */

            /**
             * Calls ObserveAccounts.
             * @function observeAccounts
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.ObserveAccountsCallback} callback Node-style callback called with the error, if any, and FinalizedTransactions
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.observeAccounts = function observeAccounts(request, callback) {
                return this.rpcCall(observeAccounts, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.FinalizedTransactions, request, callback);
            }, "name", { value: "ObserveAccounts" });

            /**
             * Calls ObserveAccounts.
             * @function observeAccounts
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.FinalizedTransactions>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#getAction}.
             * @memberof m10.sdk.M10QueryService
             * @typedef GetActionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.transaction.Action} [response] Action
             */

            /**
             * Calls GetAction.
             * @function getAction
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.GetActionCallback} callback Node-style callback called with the error, if any, and Action
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.getAction = function getAction(request, callback) {
                return this.rpcCall(getAction, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.transaction.Action, request, callback);
            }, "name", { value: "GetAction" });

            /**
             * Calls GetAction.
             * @function getAction
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.transaction.Action>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#listActions}.
             * @memberof m10.sdk.M10QueryService
             * @typedef ListActionsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.transaction.Actions} [response] Actions
             */

            /**
             * Calls ListActions.
             * @function listActions
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.ListActionsCallback} callback Node-style callback called with the error, if any, and Actions
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.listActions = function listActions(request, callback) {
                return this.rpcCall(listActions, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.transaction.Actions, request, callback);
            }, "name", { value: "ListActions" });

            /**
             * Calls ListActions.
             * @function listActions
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.transaction.Actions>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#observeActions}.
             * @memberof m10.sdk.M10QueryService
             * @typedef ObserveActionsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.FinalizedTransactions} [response] FinalizedTransactions
             */

            /**
             * Calls ObserveActions.
             * @function observeActions
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.ObserveActionsCallback} callback Node-style callback called with the error, if any, and FinalizedTransactions
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.observeActions = function observeActions(request, callback) {
                return this.rpcCall(observeActions, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.FinalizedTransactions, request, callback);
            }, "name", { value: "ObserveActions" });

            /**
             * Calls ObserveActions.
             * @function observeActions
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.FinalizedTransactions>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#getChainInfo}.
             * @memberof m10.sdk.M10QueryService
             * @typedef GetChainInfoCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.ChainInfo} [response] ChainInfo
             */

            /**
             * Calls GetChainInfo.
             * @function getChainInfo
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {m10.sdk.M10QueryService.GetChainInfoCallback} callback Node-style callback called with the error, if any, and ChainInfo
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.getChainInfo = function getChainInfo(request, callback) {
                return this.rpcCall(getChainInfo, $root.google.protobuf.Empty, $root.m10.sdk.ChainInfo, request, callback);
            }, "name", { value: "GetChainInfo" });

            /**
             * Calls GetChainInfo.
             * @function getChainInfo
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<m10.sdk.ChainInfo>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#getTransaction}.
             * @memberof m10.sdk.M10QueryService
             * @typedef GetTransactionCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.FinalizedTransaction} [response] FinalizedTransaction
             */

            /**
             * Calls GetTransaction.
             * @function getTransaction
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.GetTransactionCallback} callback Node-style callback called with the error, if any, and FinalizedTransaction
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.getTransaction = function getTransaction(request, callback) {
                return this.rpcCall(getTransaction, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.FinalizedTransaction, request, callback);
            }, "name", { value: "GetTransaction" });

            /**
             * Calls GetTransaction.
             * @function getTransaction
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.FinalizedTransaction>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#listTransactions}.
             * @memberof m10.sdk.M10QueryService
             * @typedef ListTransactionsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.FinalizedTransactions} [response] FinalizedTransactions
             */

            /**
             * Calls ListTransactions.
             * @function listTransactions
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.ListTransactionsCallback} callback Node-style callback called with the error, if any, and FinalizedTransactions
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.listTransactions = function listTransactions(request, callback) {
                return this.rpcCall(listTransactions, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.FinalizedTransactions, request, callback);
            }, "name", { value: "ListTransactions" });

            /**
             * Calls ListTransactions.
             * @function listTransactions
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.FinalizedTransactions>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#groupTransactions}.
             * @memberof m10.sdk.M10QueryService
             * @typedef GroupTransactionsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.GroupedFinalizedTransactions} [response] GroupedFinalizedTransactions
             */

            /**
             * Calls GroupTransactions.
             * @function groupTransactions
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.GroupTransactionsCallback} callback Node-style callback called with the error, if any, and GroupedFinalizedTransactions
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.groupTransactions = function groupTransactions(request, callback) {
                return this.rpcCall(groupTransactions, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.GroupedFinalizedTransactions, request, callback);
            }, "name", { value: "GroupTransactions" });

            /**
             * Calls GroupTransactions.
             * @function groupTransactions
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.GroupedFinalizedTransactions>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#getAccountSet}.
             * @memberof m10.sdk.M10QueryService
             * @typedef GetAccountSetCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.model.AccountSet} [response] AccountSet
             */

            /**
             * Calls GetAccountSet.
             * @function getAccountSet
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.GetAccountSetCallback} callback Node-style callback called with the error, if any, and AccountSet
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.getAccountSet = function getAccountSet(request, callback) {
                return this.rpcCall(getAccountSet, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.model.AccountSet, request, callback);
            }, "name", { value: "GetAccountSet" });

            /**
             * Calls GetAccountSet.
             * @function getAccountSet
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.model.AccountSet>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#listAccountSets}.
             * @memberof m10.sdk.M10QueryService
             * @typedef ListAccountSetsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.ListAccountSetsResponse} [response] ListAccountSetsResponse
             */

            /**
             * Calls ListAccountSets.
             * @function listAccountSets
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.ListAccountSetsCallback} callback Node-style callback called with the error, if any, and ListAccountSetsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.listAccountSets = function listAccountSets(request, callback) {
                return this.rpcCall(listAccountSets, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.ListAccountSetsResponse, request, callback);
            }, "name", { value: "ListAccountSets" });

            /**
             * Calls ListAccountSets.
             * @function listAccountSets
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.ListAccountSetsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#getRoleBinding}.
             * @memberof m10.sdk.M10QueryService
             * @typedef GetRoleBindingCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.RoleBinding} [response] RoleBinding
             */

            /**
             * Calls GetRoleBinding.
             * @function getRoleBinding
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.GetRoleBindingCallback} callback Node-style callback called with the error, if any, and RoleBinding
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.getRoleBinding = function getRoleBinding(request, callback) {
                return this.rpcCall(getRoleBinding, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.RoleBinding, request, callback);
            }, "name", { value: "GetRoleBinding" });

            /**
             * Calls GetRoleBinding.
             * @function getRoleBinding
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.RoleBinding>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#listRoleBindings}.
             * @memberof m10.sdk.M10QueryService
             * @typedef ListRoleBindingsCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.ListRoleBindingsResponse} [response] ListRoleBindingsResponse
             */

            /**
             * Calls ListRoleBindings.
             * @function listRoleBindings
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.ListRoleBindingsCallback} callback Node-style callback called with the error, if any, and ListRoleBindingsResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.listRoleBindings = function listRoleBindings(request, callback) {
                return this.rpcCall(listRoleBindings, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.ListRoleBindingsResponse, request, callback);
            }, "name", { value: "ListRoleBindings" });

            /**
             * Calls ListRoleBindings.
             * @function listRoleBindings
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.ListRoleBindingsResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#getRole}.
             * @memberof m10.sdk.M10QueryService
             * @typedef GetRoleCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.Role} [response] Role
             */

            /**
             * Calls GetRole.
             * @function getRole
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.GetRoleCallback} callback Node-style callback called with the error, if any, and Role
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.getRole = function getRole(request, callback) {
                return this.rpcCall(getRole, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.Role, request, callback);
            }, "name", { value: "GetRole" });

            /**
             * Calls GetRole.
             * @function getRole
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.Role>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#listRoles}.
             * @memberof m10.sdk.M10QueryService
             * @typedef ListRolesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.ListRolesResponse} [response] ListRolesResponse
             */

            /**
             * Calls ListRoles.
             * @function listRoles
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.ListRolesCallback} callback Node-style callback called with the error, if any, and ListRolesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.listRoles = function listRoles(request, callback) {
                return this.rpcCall(listRoles, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.ListRolesResponse, request, callback);
            }, "name", { value: "ListRoles" });

            /**
             * Calls ListRoles.
             * @function listRoles
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.ListRolesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.sdk.M10QueryService#observeResources}.
             * @memberof m10.sdk.M10QueryService
             * @typedef ObserveResourcesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.sdk.FinalizedTransactions} [response] FinalizedTransactions
             */

            /**
             * Calls ObserveResources.
             * @function observeResources
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @param {m10.sdk.M10QueryService.ObserveResourcesCallback} callback Node-style callback called with the error, if any, and FinalizedTransactions
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(M10QueryService.prototype.observeResources = function observeResources(request, callback) {
                return this.rpcCall(observeResources, $root.m10.sdk.RequestEnvelope, $root.m10.sdk.FinalizedTransactions, request, callback);
            }, "name", { value: "ObserveResources" });

            /**
             * Calls ObserveResources.
             * @function observeResources
             * @memberof m10.sdk.M10QueryService
             * @instance
             * @param {m10.sdk.IRequestEnvelope} request RequestEnvelope message or plain object
             * @returns {Promise<m10.sdk.FinalizedTransactions>} Promise
             * @variation 2
             */

            return M10QueryService;
        })();

        sdk.RequestEnvelope = (function() {

            /**
             * Properties of a RequestEnvelope.
             * @memberof m10.sdk
             * @interface IRequestEnvelope
             * @property {Uint8Array|null} [payload] RequestEnvelope payload
             * @property {m10.sdk.ISignature|null} [signature] RequestEnvelope signature
             */

            /**
             * Constructs a new RequestEnvelope.
             * @memberof m10.sdk
             * @classdesc Represents a RequestEnvelope.
             * @implements IRequestEnvelope
             * @constructor
             * @param {m10.sdk.IRequestEnvelope=} [properties] Properties to set
             */
            function RequestEnvelope(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RequestEnvelope payload.
             * @member {Uint8Array} payload
             * @memberof m10.sdk.RequestEnvelope
             * @instance
             */
            RequestEnvelope.prototype.payload = $util.newBuffer([]);

            /**
             * RequestEnvelope signature.
             * @member {m10.sdk.ISignature|null|undefined} signature
             * @memberof m10.sdk.RequestEnvelope
             * @instance
             */
            RequestEnvelope.prototype.signature = null;

            /**
             * Creates a new RequestEnvelope instance using the specified properties.
             * @function create
             * @memberof m10.sdk.RequestEnvelope
             * @static
             * @param {m10.sdk.IRequestEnvelope=} [properties] Properties to set
             * @returns {m10.sdk.RequestEnvelope} RequestEnvelope instance
             */
            RequestEnvelope.create = function create(properties) {
                return new RequestEnvelope(properties);
            };

            /**
             * Encodes the specified RequestEnvelope message. Does not implicitly {@link m10.sdk.RequestEnvelope.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.RequestEnvelope
             * @static
             * @param {m10.sdk.IRequestEnvelope} message RequestEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestEnvelope.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.payload);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    $root.m10.sdk.Signature.encode(message.signature, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified RequestEnvelope message, length delimited. Does not implicitly {@link m10.sdk.RequestEnvelope.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.RequestEnvelope
             * @static
             * @param {m10.sdk.IRequestEnvelope} message RequestEnvelope message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RequestEnvelope.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RequestEnvelope message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.RequestEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.RequestEnvelope} RequestEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestEnvelope.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.RequestEnvelope();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.payload = reader.bytes();
                        break;
                    case 3:
                        message.signature = $root.m10.sdk.Signature.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RequestEnvelope message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.RequestEnvelope
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.RequestEnvelope} RequestEnvelope
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RequestEnvelope.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RequestEnvelope message.
             * @function verify
             * @memberof m10.sdk.RequestEnvelope
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RequestEnvelope.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.payload != null && message.hasOwnProperty("payload"))
                    if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                        return "payload: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature")) {
                    var error = $root.m10.sdk.Signature.verify(message.signature);
                    if (error)
                        return "signature." + error;
                }
                return null;
            };

            /**
             * Creates a RequestEnvelope message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.RequestEnvelope
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.RequestEnvelope} RequestEnvelope
             */
            RequestEnvelope.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.RequestEnvelope)
                    return object;
                var message = new $root.m10.sdk.RequestEnvelope();
                if (object.payload != null)
                    if (typeof object.payload === "string")
                        $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                    else if (object.payload.length)
                        message.payload = object.payload;
                if (object.signature != null) {
                    if (typeof object.signature !== "object")
                        throw TypeError(".m10.sdk.RequestEnvelope.signature: object expected");
                    message.signature = $root.m10.sdk.Signature.fromObject(object.signature);
                }
                return message;
            };

            /**
             * Creates a plain object from a RequestEnvelope message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.RequestEnvelope
             * @static
             * @param {m10.sdk.RequestEnvelope} message RequestEnvelope
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RequestEnvelope.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.payload = "";
                    else {
                        object.payload = [];
                        if (options.bytes !== Array)
                            object.payload = $util.newBuffer(object.payload);
                    }
                    object.signature = null;
                }
                if (message.payload != null && message.hasOwnProperty("payload"))
                    object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = $root.m10.sdk.Signature.toObject(message.signature, options);
                return object;
            };

            /**
             * Converts this RequestEnvelope to JSON.
             * @function toJSON
             * @memberof m10.sdk.RequestEnvelope
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RequestEnvelope.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RequestEnvelope;
        })();

        sdk.Signature = (function() {

            /**
             * Properties of a Signature.
             * @memberof m10.sdk
             * @interface ISignature
             * @property {Uint8Array|null} [publicKey] Signature publicKey
             * @property {Uint8Array|null} [signature] Signature signature
             * @property {m10.sdk.Signature.Algorithm|null} [algorithm] Signature algorithm
             */

            /**
             * Constructs a new Signature.
             * @memberof m10.sdk
             * @classdesc Represents a Signature.
             * @implements ISignature
             * @constructor
             * @param {m10.sdk.ISignature=} [properties] Properties to set
             */
            function Signature(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Signature publicKey.
             * @member {Uint8Array} publicKey
             * @memberof m10.sdk.Signature
             * @instance
             */
            Signature.prototype.publicKey = $util.newBuffer([]);

            /**
             * Signature signature.
             * @member {Uint8Array} signature
             * @memberof m10.sdk.Signature
             * @instance
             */
            Signature.prototype.signature = $util.newBuffer([]);

            /**
             * Signature algorithm.
             * @member {m10.sdk.Signature.Algorithm} algorithm
             * @memberof m10.sdk.Signature
             * @instance
             */
            Signature.prototype.algorithm = 0;

            /**
             * Creates a new Signature instance using the specified properties.
             * @function create
             * @memberof m10.sdk.Signature
             * @static
             * @param {m10.sdk.ISignature=} [properties] Properties to set
             * @returns {m10.sdk.Signature} Signature instance
             */
            Signature.create = function create(properties) {
                return new Signature(properties);
            };

            /**
             * Encodes the specified Signature message. Does not implicitly {@link m10.sdk.Signature.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.Signature
             * @static
             * @param {m10.sdk.ISignature} message Signature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Signature.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.publicKey);
                if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.signature);
                if (message.algorithm != null && Object.hasOwnProperty.call(message, "algorithm"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.algorithm);
                return writer;
            };

            /**
             * Encodes the specified Signature message, length delimited. Does not implicitly {@link m10.sdk.Signature.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.Signature
             * @static
             * @param {m10.sdk.ISignature} message Signature message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Signature.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Signature message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.Signature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.Signature} Signature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Signature.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.Signature();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.publicKey = reader.bytes();
                        break;
                    case 3:
                        message.signature = reader.bytes();
                        break;
                    case 4:
                        message.algorithm = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Signature message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.Signature
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.Signature} Signature
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Signature.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Signature message.
             * @function verify
             * @memberof m10.sdk.Signature
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Signature.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                        return "publicKey: buffer expected";
                if (message.signature != null && message.hasOwnProperty("signature"))
                    if (!(message.signature && typeof message.signature.length === "number" || $util.isString(message.signature)))
                        return "signature: buffer expected";
                if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                    switch (message.algorithm) {
                    default:
                        return "algorithm: enum value expected";
                    case 0:
                    case 1:
                        break;
                    }
                return null;
            };

            /**
             * Creates a Signature message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.Signature
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.Signature} Signature
             */
            Signature.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.Signature)
                    return object;
                var message = new $root.m10.sdk.Signature();
                if (object.publicKey != null)
                    if (typeof object.publicKey === "string")
                        $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                    else if (object.publicKey.length)
                        message.publicKey = object.publicKey;
                if (object.signature != null)
                    if (typeof object.signature === "string")
                        $util.base64.decode(object.signature, message.signature = $util.newBuffer($util.base64.length(object.signature)), 0);
                    else if (object.signature.length)
                        message.signature = object.signature;
                switch (object.algorithm) {
                case "P256_SHA256_ASN1":
                case 0:
                    message.algorithm = 0;
                    break;
                case "ED25519":
                case 1:
                    message.algorithm = 1;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from a Signature message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.Signature
             * @static
             * @param {m10.sdk.Signature} message Signature
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Signature.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.publicKey = "";
                    else {
                        object.publicKey = [];
                        if (options.bytes !== Array)
                            object.publicKey = $util.newBuffer(object.publicKey);
                    }
                    if (options.bytes === String)
                        object.signature = "";
                    else {
                        object.signature = [];
                        if (options.bytes !== Array)
                            object.signature = $util.newBuffer(object.signature);
                    }
                    object.algorithm = options.enums === String ? "P256_SHA256_ASN1" : 0;
                }
                if (message.publicKey != null && message.hasOwnProperty("publicKey"))
                    object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                if (message.signature != null && message.hasOwnProperty("signature"))
                    object.signature = options.bytes === String ? $util.base64.encode(message.signature, 0, message.signature.length) : options.bytes === Array ? Array.prototype.slice.call(message.signature) : message.signature;
                if (message.algorithm != null && message.hasOwnProperty("algorithm"))
                    object.algorithm = options.enums === String ? $root.m10.sdk.Signature.Algorithm[message.algorithm] : message.algorithm;
                return object;
            };

            /**
             * Converts this Signature to JSON.
             * @function toJSON
             * @memberof m10.sdk.Signature
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Signature.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Algorithm enum.
             * @name m10.sdk.Signature.Algorithm
             * @enum {number}
             * @property {number} P256_SHA256_ASN1=0 P256_SHA256_ASN1 value
             * @property {number} ED25519=1 ED25519 value
             */
            Signature.Algorithm = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "P256_SHA256_ASN1"] = 0;
                values[valuesById[1] = "ED25519"] = 1;
                return values;
            })();

            return Signature;
        })();

        sdk.Page = (function() {

            /**
             * Properties of a Page.
             * @memberof m10.sdk
             * @interface IPage
             * @property {number|null} [limit] Page limit
             * @property {Uint8Array|null} [lastId] Page lastId
             */

            /**
             * Constructs a new Page.
             * @memberof m10.sdk
             * @classdesc Represents a Page.
             * @implements IPage
             * @constructor
             * @param {m10.sdk.IPage=} [properties] Properties to set
             */
            function Page(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Page limit.
             * @member {number} limit
             * @memberof m10.sdk.Page
             * @instance
             */
            Page.prototype.limit = 0;

            /**
             * Page lastId.
             * @member {Uint8Array} lastId
             * @memberof m10.sdk.Page
             * @instance
             */
            Page.prototype.lastId = $util.newBuffer([]);

            /**
             * Creates a new Page instance using the specified properties.
             * @function create
             * @memberof m10.sdk.Page
             * @static
             * @param {m10.sdk.IPage=} [properties] Properties to set
             * @returns {m10.sdk.Page} Page instance
             */
            Page.create = function create(properties) {
                return new Page(properties);
            };

            /**
             * Encodes the specified Page message. Does not implicitly {@link m10.sdk.Page.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.Page
             * @static
             * @param {m10.sdk.IPage} message Page message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Page.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint32(message.limit);
                if (message.lastId != null && Object.hasOwnProperty.call(message, "lastId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.lastId);
                return writer;
            };

            /**
             * Encodes the specified Page message, length delimited. Does not implicitly {@link m10.sdk.Page.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.Page
             * @static
             * @param {m10.sdk.IPage} message Page message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Page.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Page message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.Page
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.Page} Page
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Page.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.Page();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.limit = reader.uint32();
                        break;
                    case 2:
                        message.lastId = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Page message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.Page
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.Page} Page
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Page.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Page message.
             * @function verify
             * @memberof m10.sdk.Page
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Page.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit))
                        return "limit: integer expected";
                if (message.lastId != null && message.hasOwnProperty("lastId"))
                    if (!(message.lastId && typeof message.lastId.length === "number" || $util.isString(message.lastId)))
                        return "lastId: buffer expected";
                return null;
            };

            /**
             * Creates a Page message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.Page
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.Page} Page
             */
            Page.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.Page)
                    return object;
                var message = new $root.m10.sdk.Page();
                if (object.limit != null)
                    message.limit = object.limit >>> 0;
                if (object.lastId != null)
                    if (typeof object.lastId === "string")
                        $util.base64.decode(object.lastId, message.lastId = $util.newBuffer($util.base64.length(object.lastId)), 0);
                    else if (object.lastId.length)
                        message.lastId = object.lastId;
                return message;
            };

            /**
             * Creates a plain object from a Page message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.Page
             * @static
             * @param {m10.sdk.Page} message Page
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Page.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.limit = 0;
                    if (options.bytes === String)
                        object.lastId = "";
                    else {
                        object.lastId = [];
                        if (options.bytes !== Array)
                            object.lastId = $util.newBuffer(object.lastId);
                    }
                }
                if (message.limit != null && message.hasOwnProperty("limit"))
                    object.limit = message.limit;
                if (message.lastId != null && message.hasOwnProperty("lastId"))
                    object.lastId = options.bytes === String ? $util.base64.encode(message.lastId, 0, message.lastId.length) : options.bytes === Array ? Array.prototype.slice.call(message.lastId) : message.lastId;
                return object;
            };

            /**
             * Converts this Page to JSON.
             * @function toJSON
             * @memberof m10.sdk.Page
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Page.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Page;
        })();

        sdk.GetAccountSetRequest = (function() {

            /**
             * Properties of a GetAccountSetRequest.
             * @memberof m10.sdk
             * @interface IGetAccountSetRequest
             * @property {Uint8Array|null} [id] GetAccountSetRequest id
             */

            /**
             * Constructs a new GetAccountSetRequest.
             * @memberof m10.sdk
             * @classdesc Represents a GetAccountSetRequest.
             * @implements IGetAccountSetRequest
             * @constructor
             * @param {m10.sdk.IGetAccountSetRequest=} [properties] Properties to set
             */
            function GetAccountSetRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetAccountSetRequest id.
             * @member {Uint8Array} id
             * @memberof m10.sdk.GetAccountSetRequest
             * @instance
             */
            GetAccountSetRequest.prototype.id = $util.newBuffer([]);

            /**
             * Creates a new GetAccountSetRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.GetAccountSetRequest
             * @static
             * @param {m10.sdk.IGetAccountSetRequest=} [properties] Properties to set
             * @returns {m10.sdk.GetAccountSetRequest} GetAccountSetRequest instance
             */
            GetAccountSetRequest.create = function create(properties) {
                return new GetAccountSetRequest(properties);
            };

            /**
             * Encodes the specified GetAccountSetRequest message. Does not implicitly {@link m10.sdk.GetAccountSetRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.GetAccountSetRequest
             * @static
             * @param {m10.sdk.IGetAccountSetRequest} message GetAccountSetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAccountSetRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                return writer;
            };

            /**
             * Encodes the specified GetAccountSetRequest message, length delimited. Does not implicitly {@link m10.sdk.GetAccountSetRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.GetAccountSetRequest
             * @static
             * @param {m10.sdk.IGetAccountSetRequest} message GetAccountSetRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetAccountSetRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetAccountSetRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.GetAccountSetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.GetAccountSetRequest} GetAccountSetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAccountSetRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.GetAccountSetRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetAccountSetRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.GetAccountSetRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.GetAccountSetRequest} GetAccountSetRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetAccountSetRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetAccountSetRequest message.
             * @function verify
             * @memberof m10.sdk.GetAccountSetRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetAccountSetRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                        return "id: buffer expected";
                return null;
            };

            /**
             * Creates a GetAccountSetRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.GetAccountSetRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.GetAccountSetRequest} GetAccountSetRequest
             */
            GetAccountSetRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.GetAccountSetRequest)
                    return object;
                var message = new $root.m10.sdk.GetAccountSetRequest();
                if (object.id != null)
                    if (typeof object.id === "string")
                        $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                    else if (object.id.length)
                        message.id = object.id;
                return message;
            };

            /**
             * Creates a plain object from a GetAccountSetRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.GetAccountSetRequest
             * @static
             * @param {m10.sdk.GetAccountSetRequest} message GetAccountSetRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetAccountSetRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.id = "";
                    else {
                        object.id = [];
                        if (options.bytes !== Array)
                            object.id = $util.newBuffer(object.id);
                    }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                return object;
            };

            /**
             * Converts this GetAccountSetRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.GetAccountSetRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetAccountSetRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetAccountSetRequest;
        })();

        sdk.ListAccountSetsRequest = (function() {

            /**
             * Properties of a ListAccountSetsRequest.
             * @memberof m10.sdk
             * @interface IListAccountSetsRequest
             * @property {Uint8Array|null} [owner] ListAccountSetsRequest owner
             * @property {string|null} [name] ListAccountSetsRequest name
             * @property {m10.sdk.IPage|null} [page] ListAccountSetsRequest page
             */

            /**
             * Constructs a new ListAccountSetsRequest.
             * @memberof m10.sdk
             * @classdesc Represents a ListAccountSetsRequest.
             * @implements IListAccountSetsRequest
             * @constructor
             * @param {m10.sdk.IListAccountSetsRequest=} [properties] Properties to set
             */
            function ListAccountSetsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListAccountSetsRequest owner.
             * @member {Uint8Array|null|undefined} owner
             * @memberof m10.sdk.ListAccountSetsRequest
             * @instance
             */
            ListAccountSetsRequest.prototype.owner = null;

            /**
             * ListAccountSetsRequest name.
             * @member {string|null|undefined} name
             * @memberof m10.sdk.ListAccountSetsRequest
             * @instance
             */
            ListAccountSetsRequest.prototype.name = null;

            /**
             * ListAccountSetsRequest page.
             * @member {m10.sdk.IPage|null|undefined} page
             * @memberof m10.sdk.ListAccountSetsRequest
             * @instance
             */
            ListAccountSetsRequest.prototype.page = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ListAccountSetsRequest filter.
             * @member {"owner"|"name"|undefined} filter
             * @memberof m10.sdk.ListAccountSetsRequest
             * @instance
             */
            Object.defineProperty(ListAccountSetsRequest.prototype, "filter", {
                get: $util.oneOfGetter($oneOfFields = ["owner", "name"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ListAccountSetsRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ListAccountSetsRequest
             * @static
             * @param {m10.sdk.IListAccountSetsRequest=} [properties] Properties to set
             * @returns {m10.sdk.ListAccountSetsRequest} ListAccountSetsRequest instance
             */
            ListAccountSetsRequest.create = function create(properties) {
                return new ListAccountSetsRequest(properties);
            };

            /**
             * Encodes the specified ListAccountSetsRequest message. Does not implicitly {@link m10.sdk.ListAccountSetsRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ListAccountSetsRequest
             * @static
             * @param {m10.sdk.IListAccountSetsRequest} message ListAccountSetsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListAccountSetsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                    $root.m10.sdk.Page.encode(message.page, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListAccountSetsRequest message, length delimited. Does not implicitly {@link m10.sdk.ListAccountSetsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ListAccountSetsRequest
             * @static
             * @param {m10.sdk.IListAccountSetsRequest} message ListAccountSetsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListAccountSetsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListAccountSetsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ListAccountSetsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ListAccountSetsRequest} ListAccountSetsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListAccountSetsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ListAccountSetsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.owner = reader.bytes();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 4:
                        message.page = $root.m10.sdk.Page.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListAccountSetsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ListAccountSetsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ListAccountSetsRequest} ListAccountSetsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListAccountSetsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListAccountSetsRequest message.
             * @function verify
             * @memberof m10.sdk.ListAccountSetsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListAccountSetsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.owner != null && message.hasOwnProperty("owner")) {
                    properties.filter = 1;
                    if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                        return "owner: buffer expected";
                }
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (properties.filter === 1)
                        return "filter: multiple values";
                    properties.filter = 1;
                    if (!$util.isString(message.name))
                        return "name: string expected";
                }
                if (message.page != null && message.hasOwnProperty("page")) {
                    var error = $root.m10.sdk.Page.verify(message.page);
                    if (error)
                        return "page." + error;
                }
                return null;
            };

            /**
             * Creates a ListAccountSetsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ListAccountSetsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ListAccountSetsRequest} ListAccountSetsRequest
             */
            ListAccountSetsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ListAccountSetsRequest)
                    return object;
                var message = new $root.m10.sdk.ListAccountSetsRequest();
                if (object.owner != null)
                    if (typeof object.owner === "string")
                        $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                    else if (object.owner.length)
                        message.owner = object.owner;
                if (object.name != null)
                    message.name = String(object.name);
                if (object.page != null) {
                    if (typeof object.page !== "object")
                        throw TypeError(".m10.sdk.ListAccountSetsRequest.page: object expected");
                    message.page = $root.m10.sdk.Page.fromObject(object.page);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListAccountSetsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ListAccountSetsRequest
             * @static
             * @param {m10.sdk.ListAccountSetsRequest} message ListAccountSetsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListAccountSetsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.page = null;
                if (message.owner != null && message.hasOwnProperty("owner")) {
                    object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
                    if (options.oneofs)
                        object.filter = "owner";
                }
                if (message.name != null && message.hasOwnProperty("name")) {
                    object.name = message.name;
                    if (options.oneofs)
                        object.filter = "name";
                }
                if (message.page != null && message.hasOwnProperty("page"))
                    object.page = $root.m10.sdk.Page.toObject(message.page, options);
                return object;
            };

            /**
             * Converts this ListAccountSetsRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.ListAccountSetsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListAccountSetsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListAccountSetsRequest;
        })();

        sdk.ListAccountSetsResponse = (function() {

            /**
             * Properties of a ListAccountSetsResponse.
             * @memberof m10.sdk
             * @interface IListAccountSetsResponse
             * @property {Array.<m10.sdk.model.IAccountSet>|null} [accountSets] ListAccountSetsResponse accountSets
             * @property {m10.sdk.IListAccountSetsRequest|null} [nextRequest] ListAccountSetsResponse nextRequest
             */

            /**
             * Constructs a new ListAccountSetsResponse.
             * @memberof m10.sdk
             * @classdesc Represents a ListAccountSetsResponse.
             * @implements IListAccountSetsResponse
             * @constructor
             * @param {m10.sdk.IListAccountSetsResponse=} [properties] Properties to set
             */
            function ListAccountSetsResponse(properties) {
                this.accountSets = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListAccountSetsResponse accountSets.
             * @member {Array.<m10.sdk.model.IAccountSet>} accountSets
             * @memberof m10.sdk.ListAccountSetsResponse
             * @instance
             */
            ListAccountSetsResponse.prototype.accountSets = $util.emptyArray;

            /**
             * ListAccountSetsResponse nextRequest.
             * @member {m10.sdk.IListAccountSetsRequest|null|undefined} nextRequest
             * @memberof m10.sdk.ListAccountSetsResponse
             * @instance
             */
            ListAccountSetsResponse.prototype.nextRequest = null;

            /**
             * Creates a new ListAccountSetsResponse instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ListAccountSetsResponse
             * @static
             * @param {m10.sdk.IListAccountSetsResponse=} [properties] Properties to set
             * @returns {m10.sdk.ListAccountSetsResponse} ListAccountSetsResponse instance
             */
            ListAccountSetsResponse.create = function create(properties) {
                return new ListAccountSetsResponse(properties);
            };

            /**
             * Encodes the specified ListAccountSetsResponse message. Does not implicitly {@link m10.sdk.ListAccountSetsResponse.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ListAccountSetsResponse
             * @static
             * @param {m10.sdk.IListAccountSetsResponse} message ListAccountSetsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListAccountSetsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accountSets != null && message.accountSets.length)
                    for (var i = 0; i < message.accountSets.length; ++i)
                        $root.m10.sdk.model.AccountSet.encode(message.accountSets[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.nextRequest != null && Object.hasOwnProperty.call(message, "nextRequest"))
                    $root.m10.sdk.ListAccountSetsRequest.encode(message.nextRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListAccountSetsResponse message, length delimited. Does not implicitly {@link m10.sdk.ListAccountSetsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ListAccountSetsResponse
             * @static
             * @param {m10.sdk.IListAccountSetsResponse} message ListAccountSetsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListAccountSetsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListAccountSetsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ListAccountSetsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ListAccountSetsResponse} ListAccountSetsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListAccountSetsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ListAccountSetsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.accountSets && message.accountSets.length))
                            message.accountSets = [];
                        message.accountSets.push($root.m10.sdk.model.AccountSet.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.nextRequest = $root.m10.sdk.ListAccountSetsRequest.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListAccountSetsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ListAccountSetsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ListAccountSetsResponse} ListAccountSetsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListAccountSetsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListAccountSetsResponse message.
             * @function verify
             * @memberof m10.sdk.ListAccountSetsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListAccountSetsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accountSets != null && message.hasOwnProperty("accountSets")) {
                    if (!Array.isArray(message.accountSets))
                        return "accountSets: array expected";
                    for (var i = 0; i < message.accountSets.length; ++i) {
                        var error = $root.m10.sdk.model.AccountSet.verify(message.accountSets[i]);
                        if (error)
                            return "accountSets." + error;
                    }
                }
                if (message.nextRequest != null && message.hasOwnProperty("nextRequest")) {
                    var error = $root.m10.sdk.ListAccountSetsRequest.verify(message.nextRequest);
                    if (error)
                        return "nextRequest." + error;
                }
                return null;
            };

            /**
             * Creates a ListAccountSetsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ListAccountSetsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ListAccountSetsResponse} ListAccountSetsResponse
             */
            ListAccountSetsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ListAccountSetsResponse)
                    return object;
                var message = new $root.m10.sdk.ListAccountSetsResponse();
                if (object.accountSets) {
                    if (!Array.isArray(object.accountSets))
                        throw TypeError(".m10.sdk.ListAccountSetsResponse.accountSets: array expected");
                    message.accountSets = [];
                    for (var i = 0; i < object.accountSets.length; ++i) {
                        if (typeof object.accountSets[i] !== "object")
                            throw TypeError(".m10.sdk.ListAccountSetsResponse.accountSets: object expected");
                        message.accountSets[i] = $root.m10.sdk.model.AccountSet.fromObject(object.accountSets[i]);
                    }
                }
                if (object.nextRequest != null) {
                    if (typeof object.nextRequest !== "object")
                        throw TypeError(".m10.sdk.ListAccountSetsResponse.nextRequest: object expected");
                    message.nextRequest = $root.m10.sdk.ListAccountSetsRequest.fromObject(object.nextRequest);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListAccountSetsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ListAccountSetsResponse
             * @static
             * @param {m10.sdk.ListAccountSetsResponse} message ListAccountSetsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListAccountSetsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.accountSets = [];
                if (options.defaults)
                    object.nextRequest = null;
                if (message.accountSets && message.accountSets.length) {
                    object.accountSets = [];
                    for (var j = 0; j < message.accountSets.length; ++j)
                        object.accountSets[j] = $root.m10.sdk.model.AccountSet.toObject(message.accountSets[j], options);
                }
                if (message.nextRequest != null && message.hasOwnProperty("nextRequest"))
                    object.nextRequest = $root.m10.sdk.ListAccountSetsRequest.toObject(message.nextRequest, options);
                return object;
            };

            /**
             * Converts this ListAccountSetsResponse to JSON.
             * @function toJSON
             * @memberof m10.sdk.ListAccountSetsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListAccountSetsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListAccountSetsResponse;
        })();

        sdk.ListAccountsRequest = (function() {

            /**
             * Properties of a ListAccountsRequest.
             * @memberof m10.sdk
             * @interface IListAccountsRequest
             * @property {Uint8Array|null} [owner] ListAccountsRequest owner
             * @property {m10.sdk.IPage|null} [page] ListAccountsRequest page
             */

            /**
             * Constructs a new ListAccountsRequest.
             * @memberof m10.sdk
             * @classdesc Represents a ListAccountsRequest.
             * @implements IListAccountsRequest
             * @constructor
             * @param {m10.sdk.IListAccountsRequest=} [properties] Properties to set
             */
            function ListAccountsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListAccountsRequest owner.
             * @member {Uint8Array|null|undefined} owner
             * @memberof m10.sdk.ListAccountsRequest
             * @instance
             */
            ListAccountsRequest.prototype.owner = null;

            /**
             * ListAccountsRequest page.
             * @member {m10.sdk.IPage|null|undefined} page
             * @memberof m10.sdk.ListAccountsRequest
             * @instance
             */
            ListAccountsRequest.prototype.page = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ListAccountsRequest filter.
             * @member {"owner"|undefined} filter
             * @memberof m10.sdk.ListAccountsRequest
             * @instance
             */
            Object.defineProperty(ListAccountsRequest.prototype, "filter", {
                get: $util.oneOfGetter($oneOfFields = ["owner"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ListAccountsRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ListAccountsRequest
             * @static
             * @param {m10.sdk.IListAccountsRequest=} [properties] Properties to set
             * @returns {m10.sdk.ListAccountsRequest} ListAccountsRequest instance
             */
            ListAccountsRequest.create = function create(properties) {
                return new ListAccountsRequest(properties);
            };

            /**
             * Encodes the specified ListAccountsRequest message. Does not implicitly {@link m10.sdk.ListAccountsRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ListAccountsRequest
             * @static
             * @param {m10.sdk.IListAccountsRequest} message ListAccountsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListAccountsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner);
                if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                    $root.m10.sdk.Page.encode(message.page, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListAccountsRequest message, length delimited. Does not implicitly {@link m10.sdk.ListAccountsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ListAccountsRequest
             * @static
             * @param {m10.sdk.IListAccountsRequest} message ListAccountsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListAccountsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListAccountsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ListAccountsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ListAccountsRequest} ListAccountsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListAccountsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ListAccountsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.owner = reader.bytes();
                        break;
                    case 4:
                        message.page = $root.m10.sdk.Page.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListAccountsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ListAccountsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ListAccountsRequest} ListAccountsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListAccountsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListAccountsRequest message.
             * @function verify
             * @memberof m10.sdk.ListAccountsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListAccountsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.owner != null && message.hasOwnProperty("owner")) {
                    properties.filter = 1;
                    if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                        return "owner: buffer expected";
                }
                if (message.page != null && message.hasOwnProperty("page")) {
                    var error = $root.m10.sdk.Page.verify(message.page);
                    if (error)
                        return "page." + error;
                }
                return null;
            };

            /**
             * Creates a ListAccountsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ListAccountsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ListAccountsRequest} ListAccountsRequest
             */
            ListAccountsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ListAccountsRequest)
                    return object;
                var message = new $root.m10.sdk.ListAccountsRequest();
                if (object.owner != null)
                    if (typeof object.owner === "string")
                        $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                    else if (object.owner.length)
                        message.owner = object.owner;
                if (object.page != null) {
                    if (typeof object.page !== "object")
                        throw TypeError(".m10.sdk.ListAccountsRequest.page: object expected");
                    message.page = $root.m10.sdk.Page.fromObject(object.page);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListAccountsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ListAccountsRequest
             * @static
             * @param {m10.sdk.ListAccountsRequest} message ListAccountsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListAccountsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.page = null;
                if (message.owner != null && message.hasOwnProperty("owner")) {
                    object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
                    if (options.oneofs)
                        object.filter = "owner";
                }
                if (message.page != null && message.hasOwnProperty("page"))
                    object.page = $root.m10.sdk.Page.toObject(message.page, options);
                return object;
            };

            /**
             * Converts this ListAccountsRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.ListAccountsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListAccountsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListAccountsRequest;
        })();

        sdk.ListAccountsResponse = (function() {

            /**
             * Properties of a ListAccountsResponse.
             * @memberof m10.sdk
             * @interface IListAccountsResponse
             * @property {Array.<m10.sdk.model.IAccount>|null} [accounts] ListAccountsResponse accounts
             * @property {m10.sdk.IListAccountsRequest|null} [nextRequest] ListAccountsResponse nextRequest
             */

            /**
             * Constructs a new ListAccountsResponse.
             * @memberof m10.sdk
             * @classdesc Represents a ListAccountsResponse.
             * @implements IListAccountsResponse
             * @constructor
             * @param {m10.sdk.IListAccountsResponse=} [properties] Properties to set
             */
            function ListAccountsResponse(properties) {
                this.accounts = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListAccountsResponse accounts.
             * @member {Array.<m10.sdk.model.IAccount>} accounts
             * @memberof m10.sdk.ListAccountsResponse
             * @instance
             */
            ListAccountsResponse.prototype.accounts = $util.emptyArray;

            /**
             * ListAccountsResponse nextRequest.
             * @member {m10.sdk.IListAccountsRequest|null|undefined} nextRequest
             * @memberof m10.sdk.ListAccountsResponse
             * @instance
             */
            ListAccountsResponse.prototype.nextRequest = null;

            /**
             * Creates a new ListAccountsResponse instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ListAccountsResponse
             * @static
             * @param {m10.sdk.IListAccountsResponse=} [properties] Properties to set
             * @returns {m10.sdk.ListAccountsResponse} ListAccountsResponse instance
             */
            ListAccountsResponse.create = function create(properties) {
                return new ListAccountsResponse(properties);
            };

            /**
             * Encodes the specified ListAccountsResponse message. Does not implicitly {@link m10.sdk.ListAccountsResponse.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ListAccountsResponse
             * @static
             * @param {m10.sdk.IListAccountsResponse} message ListAccountsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListAccountsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accounts != null && message.accounts.length)
                    for (var i = 0; i < message.accounts.length; ++i)
                        $root.m10.sdk.model.Account.encode(message.accounts[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.nextRequest != null && Object.hasOwnProperty.call(message, "nextRequest"))
                    $root.m10.sdk.ListAccountsRequest.encode(message.nextRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListAccountsResponse message, length delimited. Does not implicitly {@link m10.sdk.ListAccountsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ListAccountsResponse
             * @static
             * @param {m10.sdk.IListAccountsResponse} message ListAccountsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListAccountsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListAccountsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ListAccountsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ListAccountsResponse} ListAccountsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListAccountsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ListAccountsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.accounts && message.accounts.length))
                            message.accounts = [];
                        message.accounts.push($root.m10.sdk.model.Account.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.nextRequest = $root.m10.sdk.ListAccountsRequest.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListAccountsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ListAccountsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ListAccountsResponse} ListAccountsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListAccountsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListAccountsResponse message.
             * @function verify
             * @memberof m10.sdk.ListAccountsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListAccountsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accounts != null && message.hasOwnProperty("accounts")) {
                    if (!Array.isArray(message.accounts))
                        return "accounts: array expected";
                    for (var i = 0; i < message.accounts.length; ++i) {
                        var error = $root.m10.sdk.model.Account.verify(message.accounts[i]);
                        if (error)
                            return "accounts." + error;
                    }
                }
                if (message.nextRequest != null && message.hasOwnProperty("nextRequest")) {
                    var error = $root.m10.sdk.ListAccountsRequest.verify(message.nextRequest);
                    if (error)
                        return "nextRequest." + error;
                }
                return null;
            };

            /**
             * Creates a ListAccountsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ListAccountsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ListAccountsResponse} ListAccountsResponse
             */
            ListAccountsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ListAccountsResponse)
                    return object;
                var message = new $root.m10.sdk.ListAccountsResponse();
                if (object.accounts) {
                    if (!Array.isArray(object.accounts))
                        throw TypeError(".m10.sdk.ListAccountsResponse.accounts: array expected");
                    message.accounts = [];
                    for (var i = 0; i < object.accounts.length; ++i) {
                        if (typeof object.accounts[i] !== "object")
                            throw TypeError(".m10.sdk.ListAccountsResponse.accounts: object expected");
                        message.accounts[i] = $root.m10.sdk.model.Account.fromObject(object.accounts[i]);
                    }
                }
                if (object.nextRequest != null) {
                    if (typeof object.nextRequest !== "object")
                        throw TypeError(".m10.sdk.ListAccountsResponse.nextRequest: object expected");
                    message.nextRequest = $root.m10.sdk.ListAccountsRequest.fromObject(object.nextRequest);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListAccountsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ListAccountsResponse
             * @static
             * @param {m10.sdk.ListAccountsResponse} message ListAccountsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListAccountsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.accounts = [];
                if (options.defaults)
                    object.nextRequest = null;
                if (message.accounts && message.accounts.length) {
                    object.accounts = [];
                    for (var j = 0; j < message.accounts.length; ++j)
                        object.accounts[j] = $root.m10.sdk.model.Account.toObject(message.accounts[j], options);
                }
                if (message.nextRequest != null && message.hasOwnProperty("nextRequest"))
                    object.nextRequest = $root.m10.sdk.ListAccountsRequest.toObject(message.nextRequest, options);
                return object;
            };

            /**
             * Converts this ListAccountsResponse to JSON.
             * @function toJSON
             * @memberof m10.sdk.ListAccountsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListAccountsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListAccountsResponse;
        })();

        sdk.GetRoleBindingRequest = (function() {

            /**
             * Properties of a GetRoleBindingRequest.
             * @memberof m10.sdk
             * @interface IGetRoleBindingRequest
             * @property {Uint8Array|null} [id] GetRoleBindingRequest id
             */

            /**
             * Constructs a new GetRoleBindingRequest.
             * @memberof m10.sdk
             * @classdesc Represents a GetRoleBindingRequest.
             * @implements IGetRoleBindingRequest
             * @constructor
             * @param {m10.sdk.IGetRoleBindingRequest=} [properties] Properties to set
             */
            function GetRoleBindingRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRoleBindingRequest id.
             * @member {Uint8Array} id
             * @memberof m10.sdk.GetRoleBindingRequest
             * @instance
             */
            GetRoleBindingRequest.prototype.id = $util.newBuffer([]);

            /**
             * Creates a new GetRoleBindingRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.GetRoleBindingRequest
             * @static
             * @param {m10.sdk.IGetRoleBindingRequest=} [properties] Properties to set
             * @returns {m10.sdk.GetRoleBindingRequest} GetRoleBindingRequest instance
             */
            GetRoleBindingRequest.create = function create(properties) {
                return new GetRoleBindingRequest(properties);
            };

            /**
             * Encodes the specified GetRoleBindingRequest message. Does not implicitly {@link m10.sdk.GetRoleBindingRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.GetRoleBindingRequest
             * @static
             * @param {m10.sdk.IGetRoleBindingRequest} message GetRoleBindingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRoleBindingRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                return writer;
            };

            /**
             * Encodes the specified GetRoleBindingRequest message, length delimited. Does not implicitly {@link m10.sdk.GetRoleBindingRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.GetRoleBindingRequest
             * @static
             * @param {m10.sdk.IGetRoleBindingRequest} message GetRoleBindingRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRoleBindingRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRoleBindingRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.GetRoleBindingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.GetRoleBindingRequest} GetRoleBindingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRoleBindingRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.GetRoleBindingRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRoleBindingRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.GetRoleBindingRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.GetRoleBindingRequest} GetRoleBindingRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRoleBindingRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRoleBindingRequest message.
             * @function verify
             * @memberof m10.sdk.GetRoleBindingRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRoleBindingRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                        return "id: buffer expected";
                return null;
            };

            /**
             * Creates a GetRoleBindingRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.GetRoleBindingRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.GetRoleBindingRequest} GetRoleBindingRequest
             */
            GetRoleBindingRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.GetRoleBindingRequest)
                    return object;
                var message = new $root.m10.sdk.GetRoleBindingRequest();
                if (object.id != null)
                    if (typeof object.id === "string")
                        $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                    else if (object.id.length)
                        message.id = object.id;
                return message;
            };

            /**
             * Creates a plain object from a GetRoleBindingRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.GetRoleBindingRequest
             * @static
             * @param {m10.sdk.GetRoleBindingRequest} message GetRoleBindingRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRoleBindingRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.id = "";
                    else {
                        object.id = [];
                        if (options.bytes !== Array)
                            object.id = $util.newBuffer(object.id);
                    }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                return object;
            };

            /**
             * Converts this GetRoleBindingRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.GetRoleBindingRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRoleBindingRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetRoleBindingRequest;
        })();

        sdk.ListRoleBindingsRequest = (function() {

            /**
             * Properties of a ListRoleBindingsRequest.
             * @memberof m10.sdk
             * @interface IListRoleBindingsRequest
             * @property {string|null} [name] ListRoleBindingsRequest name
             * @property {m10.sdk.IPage|null} [page] ListRoleBindingsRequest page
             */

            /**
             * Constructs a new ListRoleBindingsRequest.
             * @memberof m10.sdk
             * @classdesc Represents a ListRoleBindingsRequest.
             * @implements IListRoleBindingsRequest
             * @constructor
             * @param {m10.sdk.IListRoleBindingsRequest=} [properties] Properties to set
             */
            function ListRoleBindingsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListRoleBindingsRequest name.
             * @member {string|null|undefined} name
             * @memberof m10.sdk.ListRoleBindingsRequest
             * @instance
             */
            ListRoleBindingsRequest.prototype.name = null;

            /**
             * ListRoleBindingsRequest page.
             * @member {m10.sdk.IPage|null|undefined} page
             * @memberof m10.sdk.ListRoleBindingsRequest
             * @instance
             */
            ListRoleBindingsRequest.prototype.page = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ListRoleBindingsRequest filter.
             * @member {"name"|undefined} filter
             * @memberof m10.sdk.ListRoleBindingsRequest
             * @instance
             */
            Object.defineProperty(ListRoleBindingsRequest.prototype, "filter", {
                get: $util.oneOfGetter($oneOfFields = ["name"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ListRoleBindingsRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ListRoleBindingsRequest
             * @static
             * @param {m10.sdk.IListRoleBindingsRequest=} [properties] Properties to set
             * @returns {m10.sdk.ListRoleBindingsRequest} ListRoleBindingsRequest instance
             */
            ListRoleBindingsRequest.create = function create(properties) {
                return new ListRoleBindingsRequest(properties);
            };

            /**
             * Encodes the specified ListRoleBindingsRequest message. Does not implicitly {@link m10.sdk.ListRoleBindingsRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ListRoleBindingsRequest
             * @static
             * @param {m10.sdk.IListRoleBindingsRequest} message ListRoleBindingsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListRoleBindingsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                    $root.m10.sdk.Page.encode(message.page, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListRoleBindingsRequest message, length delimited. Does not implicitly {@link m10.sdk.ListRoleBindingsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ListRoleBindingsRequest
             * @static
             * @param {m10.sdk.IListRoleBindingsRequest} message ListRoleBindingsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListRoleBindingsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListRoleBindingsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ListRoleBindingsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ListRoleBindingsRequest} ListRoleBindingsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListRoleBindingsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ListRoleBindingsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 4:
                        message.page = $root.m10.sdk.Page.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListRoleBindingsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ListRoleBindingsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ListRoleBindingsRequest} ListRoleBindingsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListRoleBindingsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListRoleBindingsRequest message.
             * @function verify
             * @memberof m10.sdk.ListRoleBindingsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListRoleBindingsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.name != null && message.hasOwnProperty("name")) {
                    properties.filter = 1;
                    if (!$util.isString(message.name))
                        return "name: string expected";
                }
                if (message.page != null && message.hasOwnProperty("page")) {
                    var error = $root.m10.sdk.Page.verify(message.page);
                    if (error)
                        return "page." + error;
                }
                return null;
            };

            /**
             * Creates a ListRoleBindingsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ListRoleBindingsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ListRoleBindingsRequest} ListRoleBindingsRequest
             */
            ListRoleBindingsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ListRoleBindingsRequest)
                    return object;
                var message = new $root.m10.sdk.ListRoleBindingsRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.page != null) {
                    if (typeof object.page !== "object")
                        throw TypeError(".m10.sdk.ListRoleBindingsRequest.page: object expected");
                    message.page = $root.m10.sdk.Page.fromObject(object.page);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListRoleBindingsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ListRoleBindingsRequest
             * @static
             * @param {m10.sdk.ListRoleBindingsRequest} message ListRoleBindingsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListRoleBindingsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.page = null;
                if (message.name != null && message.hasOwnProperty("name")) {
                    object.name = message.name;
                    if (options.oneofs)
                        object.filter = "name";
                }
                if (message.page != null && message.hasOwnProperty("page"))
                    object.page = $root.m10.sdk.Page.toObject(message.page, options);
                return object;
            };

            /**
             * Converts this ListRoleBindingsRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.ListRoleBindingsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListRoleBindingsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListRoleBindingsRequest;
        })();

        sdk.ListRoleBindingsResponse = (function() {

            /**
             * Properties of a ListRoleBindingsResponse.
             * @memberof m10.sdk
             * @interface IListRoleBindingsResponse
             * @property {Array.<m10.sdk.IRoleBinding>|null} [roleBindings] ListRoleBindingsResponse roleBindings
             * @property {m10.sdk.IListRoleBindingsRequest|null} [nextRequest] ListRoleBindingsResponse nextRequest
             */

            /**
             * Constructs a new ListRoleBindingsResponse.
             * @memberof m10.sdk
             * @classdesc Represents a ListRoleBindingsResponse.
             * @implements IListRoleBindingsResponse
             * @constructor
             * @param {m10.sdk.IListRoleBindingsResponse=} [properties] Properties to set
             */
            function ListRoleBindingsResponse(properties) {
                this.roleBindings = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListRoleBindingsResponse roleBindings.
             * @member {Array.<m10.sdk.IRoleBinding>} roleBindings
             * @memberof m10.sdk.ListRoleBindingsResponse
             * @instance
             */
            ListRoleBindingsResponse.prototype.roleBindings = $util.emptyArray;

            /**
             * ListRoleBindingsResponse nextRequest.
             * @member {m10.sdk.IListRoleBindingsRequest|null|undefined} nextRequest
             * @memberof m10.sdk.ListRoleBindingsResponse
             * @instance
             */
            ListRoleBindingsResponse.prototype.nextRequest = null;

            /**
             * Creates a new ListRoleBindingsResponse instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ListRoleBindingsResponse
             * @static
             * @param {m10.sdk.IListRoleBindingsResponse=} [properties] Properties to set
             * @returns {m10.sdk.ListRoleBindingsResponse} ListRoleBindingsResponse instance
             */
            ListRoleBindingsResponse.create = function create(properties) {
                return new ListRoleBindingsResponse(properties);
            };

            /**
             * Encodes the specified ListRoleBindingsResponse message. Does not implicitly {@link m10.sdk.ListRoleBindingsResponse.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ListRoleBindingsResponse
             * @static
             * @param {m10.sdk.IListRoleBindingsResponse} message ListRoleBindingsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListRoleBindingsResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roleBindings != null && message.roleBindings.length)
                    for (var i = 0; i < message.roleBindings.length; ++i)
                        $root.m10.sdk.RoleBinding.encode(message.roleBindings[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.nextRequest != null && Object.hasOwnProperty.call(message, "nextRequest"))
                    $root.m10.sdk.ListRoleBindingsRequest.encode(message.nextRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListRoleBindingsResponse message, length delimited. Does not implicitly {@link m10.sdk.ListRoleBindingsResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ListRoleBindingsResponse
             * @static
             * @param {m10.sdk.IListRoleBindingsResponse} message ListRoleBindingsResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListRoleBindingsResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListRoleBindingsResponse message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ListRoleBindingsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ListRoleBindingsResponse} ListRoleBindingsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListRoleBindingsResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ListRoleBindingsResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.roleBindings && message.roleBindings.length))
                            message.roleBindings = [];
                        message.roleBindings.push($root.m10.sdk.RoleBinding.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.nextRequest = $root.m10.sdk.ListRoleBindingsRequest.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListRoleBindingsResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ListRoleBindingsResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ListRoleBindingsResponse} ListRoleBindingsResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListRoleBindingsResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListRoleBindingsResponse message.
             * @function verify
             * @memberof m10.sdk.ListRoleBindingsResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListRoleBindingsResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.roleBindings != null && message.hasOwnProperty("roleBindings")) {
                    if (!Array.isArray(message.roleBindings))
                        return "roleBindings: array expected";
                    for (var i = 0; i < message.roleBindings.length; ++i) {
                        var error = $root.m10.sdk.RoleBinding.verify(message.roleBindings[i]);
                        if (error)
                            return "roleBindings." + error;
                    }
                }
                if (message.nextRequest != null && message.hasOwnProperty("nextRequest")) {
                    var error = $root.m10.sdk.ListRoleBindingsRequest.verify(message.nextRequest);
                    if (error)
                        return "nextRequest." + error;
                }
                return null;
            };

            /**
             * Creates a ListRoleBindingsResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ListRoleBindingsResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ListRoleBindingsResponse} ListRoleBindingsResponse
             */
            ListRoleBindingsResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ListRoleBindingsResponse)
                    return object;
                var message = new $root.m10.sdk.ListRoleBindingsResponse();
                if (object.roleBindings) {
                    if (!Array.isArray(object.roleBindings))
                        throw TypeError(".m10.sdk.ListRoleBindingsResponse.roleBindings: array expected");
                    message.roleBindings = [];
                    for (var i = 0; i < object.roleBindings.length; ++i) {
                        if (typeof object.roleBindings[i] !== "object")
                            throw TypeError(".m10.sdk.ListRoleBindingsResponse.roleBindings: object expected");
                        message.roleBindings[i] = $root.m10.sdk.RoleBinding.fromObject(object.roleBindings[i]);
                    }
                }
                if (object.nextRequest != null) {
                    if (typeof object.nextRequest !== "object")
                        throw TypeError(".m10.sdk.ListRoleBindingsResponse.nextRequest: object expected");
                    message.nextRequest = $root.m10.sdk.ListRoleBindingsRequest.fromObject(object.nextRequest);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListRoleBindingsResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ListRoleBindingsResponse
             * @static
             * @param {m10.sdk.ListRoleBindingsResponse} message ListRoleBindingsResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListRoleBindingsResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.roleBindings = [];
                if (options.defaults)
                    object.nextRequest = null;
                if (message.roleBindings && message.roleBindings.length) {
                    object.roleBindings = [];
                    for (var j = 0; j < message.roleBindings.length; ++j)
                        object.roleBindings[j] = $root.m10.sdk.RoleBinding.toObject(message.roleBindings[j], options);
                }
                if (message.nextRequest != null && message.hasOwnProperty("nextRequest"))
                    object.nextRequest = $root.m10.sdk.ListRoleBindingsRequest.toObject(message.nextRequest, options);
                return object;
            };

            /**
             * Converts this ListRoleBindingsResponse to JSON.
             * @function toJSON
             * @memberof m10.sdk.ListRoleBindingsResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListRoleBindingsResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListRoleBindingsResponse;
        })();

        sdk.GetRoleRequest = (function() {

            /**
             * Properties of a GetRoleRequest.
             * @memberof m10.sdk
             * @interface IGetRoleRequest
             * @property {Uint8Array|null} [id] GetRoleRequest id
             */

            /**
             * Constructs a new GetRoleRequest.
             * @memberof m10.sdk
             * @classdesc Represents a GetRoleRequest.
             * @implements IGetRoleRequest
             * @constructor
             * @param {m10.sdk.IGetRoleRequest=} [properties] Properties to set
             */
            function GetRoleRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetRoleRequest id.
             * @member {Uint8Array} id
             * @memberof m10.sdk.GetRoleRequest
             * @instance
             */
            GetRoleRequest.prototype.id = $util.newBuffer([]);

            /**
             * Creates a new GetRoleRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.GetRoleRequest
             * @static
             * @param {m10.sdk.IGetRoleRequest=} [properties] Properties to set
             * @returns {m10.sdk.GetRoleRequest} GetRoleRequest instance
             */
            GetRoleRequest.create = function create(properties) {
                return new GetRoleRequest(properties);
            };

            /**
             * Encodes the specified GetRoleRequest message. Does not implicitly {@link m10.sdk.GetRoleRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.GetRoleRequest
             * @static
             * @param {m10.sdk.IGetRoleRequest} message GetRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRoleRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                return writer;
            };

            /**
             * Encodes the specified GetRoleRequest message, length delimited. Does not implicitly {@link m10.sdk.GetRoleRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.GetRoleRequest
             * @static
             * @param {m10.sdk.IGetRoleRequest} message GetRoleRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetRoleRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetRoleRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.GetRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.GetRoleRequest} GetRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRoleRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.GetRoleRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetRoleRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.GetRoleRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.GetRoleRequest} GetRoleRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetRoleRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetRoleRequest message.
             * @function verify
             * @memberof m10.sdk.GetRoleRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetRoleRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                        return "id: buffer expected";
                return null;
            };

            /**
             * Creates a GetRoleRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.GetRoleRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.GetRoleRequest} GetRoleRequest
             */
            GetRoleRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.GetRoleRequest)
                    return object;
                var message = new $root.m10.sdk.GetRoleRequest();
                if (object.id != null)
                    if (typeof object.id === "string")
                        $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                    else if (object.id.length)
                        message.id = object.id;
                return message;
            };

            /**
             * Creates a plain object from a GetRoleRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.GetRoleRequest
             * @static
             * @param {m10.sdk.GetRoleRequest} message GetRoleRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetRoleRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.id = "";
                    else {
                        object.id = [];
                        if (options.bytes !== Array)
                            object.id = $util.newBuffer(object.id);
                    }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                return object;
            };

            /**
             * Converts this GetRoleRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.GetRoleRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetRoleRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetRoleRequest;
        })();

        sdk.ListRolesRequest = (function() {

            /**
             * Properties of a ListRolesRequest.
             * @memberof m10.sdk
             * @interface IListRolesRequest
             * @property {string|null} [name] ListRolesRequest name
             * @property {m10.sdk.IPage|null} [page] ListRolesRequest page
             */

            /**
             * Constructs a new ListRolesRequest.
             * @memberof m10.sdk
             * @classdesc Represents a ListRolesRequest.
             * @implements IListRolesRequest
             * @constructor
             * @param {m10.sdk.IListRolesRequest=} [properties] Properties to set
             */
            function ListRolesRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListRolesRequest name.
             * @member {string|null|undefined} name
             * @memberof m10.sdk.ListRolesRequest
             * @instance
             */
            ListRolesRequest.prototype.name = null;

            /**
             * ListRolesRequest page.
             * @member {m10.sdk.IPage|null|undefined} page
             * @memberof m10.sdk.ListRolesRequest
             * @instance
             */
            ListRolesRequest.prototype.page = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * ListRolesRequest filter.
             * @member {"name"|undefined} filter
             * @memberof m10.sdk.ListRolesRequest
             * @instance
             */
            Object.defineProperty(ListRolesRequest.prototype, "filter", {
                get: $util.oneOfGetter($oneOfFields = ["name"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new ListRolesRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ListRolesRequest
             * @static
             * @param {m10.sdk.IListRolesRequest=} [properties] Properties to set
             * @returns {m10.sdk.ListRolesRequest} ListRolesRequest instance
             */
            ListRolesRequest.create = function create(properties) {
                return new ListRolesRequest(properties);
            };

            /**
             * Encodes the specified ListRolesRequest message. Does not implicitly {@link m10.sdk.ListRolesRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ListRolesRequest
             * @static
             * @param {m10.sdk.IListRolesRequest} message ListRolesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListRolesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.page != null && Object.hasOwnProperty.call(message, "page"))
                    $root.m10.sdk.Page.encode(message.page, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListRolesRequest message, length delimited. Does not implicitly {@link m10.sdk.ListRolesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ListRolesRequest
             * @static
             * @param {m10.sdk.IListRolesRequest} message ListRolesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListRolesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListRolesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ListRolesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ListRolesRequest} ListRolesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListRolesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ListRolesRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 4:
                        message.page = $root.m10.sdk.Page.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListRolesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ListRolesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ListRolesRequest} ListRolesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListRolesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListRolesRequest message.
             * @function verify
             * @memberof m10.sdk.ListRolesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListRolesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.name != null && message.hasOwnProperty("name")) {
                    properties.filter = 1;
                    if (!$util.isString(message.name))
                        return "name: string expected";
                }
                if (message.page != null && message.hasOwnProperty("page")) {
                    var error = $root.m10.sdk.Page.verify(message.page);
                    if (error)
                        return "page." + error;
                }
                return null;
            };

            /**
             * Creates a ListRolesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ListRolesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ListRolesRequest} ListRolesRequest
             */
            ListRolesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ListRolesRequest)
                    return object;
                var message = new $root.m10.sdk.ListRolesRequest();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.page != null) {
                    if (typeof object.page !== "object")
                        throw TypeError(".m10.sdk.ListRolesRequest.page: object expected");
                    message.page = $root.m10.sdk.Page.fromObject(object.page);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListRolesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ListRolesRequest
             * @static
             * @param {m10.sdk.ListRolesRequest} message ListRolesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListRolesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.page = null;
                if (message.name != null && message.hasOwnProperty("name")) {
                    object.name = message.name;
                    if (options.oneofs)
                        object.filter = "name";
                }
                if (message.page != null && message.hasOwnProperty("page"))
                    object.page = $root.m10.sdk.Page.toObject(message.page, options);
                return object;
            };

            /**
             * Converts this ListRolesRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.ListRolesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListRolesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListRolesRequest;
        })();

        sdk.ListRolesResponse = (function() {

            /**
             * Properties of a ListRolesResponse.
             * @memberof m10.sdk
             * @interface IListRolesResponse
             * @property {Array.<m10.sdk.IRole>|null} [roles] ListRolesResponse roles
             * @property {m10.sdk.IListRolesRequest|null} [nextRequest] ListRolesResponse nextRequest
             */

            /**
             * Constructs a new ListRolesResponse.
             * @memberof m10.sdk
             * @classdesc Represents a ListRolesResponse.
             * @implements IListRolesResponse
             * @constructor
             * @param {m10.sdk.IListRolesResponse=} [properties] Properties to set
             */
            function ListRolesResponse(properties) {
                this.roles = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListRolesResponse roles.
             * @member {Array.<m10.sdk.IRole>} roles
             * @memberof m10.sdk.ListRolesResponse
             * @instance
             */
            ListRolesResponse.prototype.roles = $util.emptyArray;

            /**
             * ListRolesResponse nextRequest.
             * @member {m10.sdk.IListRolesRequest|null|undefined} nextRequest
             * @memberof m10.sdk.ListRolesResponse
             * @instance
             */
            ListRolesResponse.prototype.nextRequest = null;

            /**
             * Creates a new ListRolesResponse instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ListRolesResponse
             * @static
             * @param {m10.sdk.IListRolesResponse=} [properties] Properties to set
             * @returns {m10.sdk.ListRolesResponse} ListRolesResponse instance
             */
            ListRolesResponse.create = function create(properties) {
                return new ListRolesResponse(properties);
            };

            /**
             * Encodes the specified ListRolesResponse message. Does not implicitly {@link m10.sdk.ListRolesResponse.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ListRolesResponse
             * @static
             * @param {m10.sdk.IListRolesResponse} message ListRolesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListRolesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.roles != null && message.roles.length)
                    for (var i = 0; i < message.roles.length; ++i)
                        $root.m10.sdk.Role.encode(message.roles[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.nextRequest != null && Object.hasOwnProperty.call(message, "nextRequest"))
                    $root.m10.sdk.ListRolesRequest.encode(message.nextRequest, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListRolesResponse message, length delimited. Does not implicitly {@link m10.sdk.ListRolesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ListRolesResponse
             * @static
             * @param {m10.sdk.IListRolesResponse} message ListRolesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListRolesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListRolesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ListRolesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ListRolesResponse} ListRolesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListRolesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ListRolesResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.roles && message.roles.length))
                            message.roles = [];
                        message.roles.push($root.m10.sdk.Role.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.nextRequest = $root.m10.sdk.ListRolesRequest.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListRolesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ListRolesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ListRolesResponse} ListRolesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListRolesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListRolesResponse message.
             * @function verify
             * @memberof m10.sdk.ListRolesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListRolesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.roles != null && message.hasOwnProperty("roles")) {
                    if (!Array.isArray(message.roles))
                        return "roles: array expected";
                    for (var i = 0; i < message.roles.length; ++i) {
                        var error = $root.m10.sdk.Role.verify(message.roles[i]);
                        if (error)
                            return "roles." + error;
                    }
                }
                if (message.nextRequest != null && message.hasOwnProperty("nextRequest")) {
                    var error = $root.m10.sdk.ListRolesRequest.verify(message.nextRequest);
                    if (error)
                        return "nextRequest." + error;
                }
                return null;
            };

            /**
             * Creates a ListRolesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ListRolesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ListRolesResponse} ListRolesResponse
             */
            ListRolesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ListRolesResponse)
                    return object;
                var message = new $root.m10.sdk.ListRolesResponse();
                if (object.roles) {
                    if (!Array.isArray(object.roles))
                        throw TypeError(".m10.sdk.ListRolesResponse.roles: array expected");
                    message.roles = [];
                    for (var i = 0; i < object.roles.length; ++i) {
                        if (typeof object.roles[i] !== "object")
                            throw TypeError(".m10.sdk.ListRolesResponse.roles: object expected");
                        message.roles[i] = $root.m10.sdk.Role.fromObject(object.roles[i]);
                    }
                }
                if (object.nextRequest != null) {
                    if (typeof object.nextRequest !== "object")
                        throw TypeError(".m10.sdk.ListRolesResponse.nextRequest: object expected");
                    message.nextRequest = $root.m10.sdk.ListRolesRequest.fromObject(object.nextRequest);
                }
                return message;
            };

            /**
             * Creates a plain object from a ListRolesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ListRolesResponse
             * @static
             * @param {m10.sdk.ListRolesResponse} message ListRolesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListRolesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.roles = [];
                if (options.defaults)
                    object.nextRequest = null;
                if (message.roles && message.roles.length) {
                    object.roles = [];
                    for (var j = 0; j < message.roles.length; ++j)
                        object.roles[j] = $root.m10.sdk.Role.toObject(message.roles[j], options);
                }
                if (message.nextRequest != null && message.hasOwnProperty("nextRequest"))
                    object.nextRequest = $root.m10.sdk.ListRolesRequest.toObject(message.nextRequest, options);
                return object;
            };

            /**
             * Converts this ListRolesResponse to JSON.
             * @function toJSON
             * @memberof m10.sdk.ListRolesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListRolesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListRolesResponse;
        })();

        sdk.GetTransactionRequest = (function() {

            /**
             * Properties of a GetTransactionRequest.
             * @memberof m10.sdk
             * @interface IGetTransactionRequest
             * @property {number|Long|null} [txId] GetTransactionRequest txId
             */

            /**
             * Constructs a new GetTransactionRequest.
             * @memberof m10.sdk
             * @classdesc Represents a GetTransactionRequest.
             * @implements IGetTransactionRequest
             * @constructor
             * @param {m10.sdk.IGetTransactionRequest=} [properties] Properties to set
             */
            function GetTransactionRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetTransactionRequest txId.
             * @member {number|Long} txId
             * @memberof m10.sdk.GetTransactionRequest
             * @instance
             */
            GetTransactionRequest.prototype.txId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GetTransactionRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.GetTransactionRequest
             * @static
             * @param {m10.sdk.IGetTransactionRequest=} [properties] Properties to set
             * @returns {m10.sdk.GetTransactionRequest} GetTransactionRequest instance
             */
            GetTransactionRequest.create = function create(properties) {
                return new GetTransactionRequest(properties);
            };

            /**
             * Encodes the specified GetTransactionRequest message. Does not implicitly {@link m10.sdk.GetTransactionRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.GetTransactionRequest
             * @static
             * @param {m10.sdk.IGetTransactionRequest} message GetTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTransactionRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.txId);
                return writer;
            };

            /**
             * Encodes the specified GetTransactionRequest message, length delimited. Does not implicitly {@link m10.sdk.GetTransactionRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.GetTransactionRequest
             * @static
             * @param {m10.sdk.IGetTransactionRequest} message GetTransactionRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetTransactionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetTransactionRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.GetTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.GetTransactionRequest} GetTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTransactionRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.GetTransactionRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txId = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetTransactionRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.GetTransactionRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.GetTransactionRequest} GetTransactionRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetTransactionRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetTransactionRequest message.
             * @function verify
             * @memberof m10.sdk.GetTransactionRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetTransactionRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isInteger(message.txId) && !(message.txId && $util.isInteger(message.txId.low) && $util.isInteger(message.txId.high)))
                        return "txId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GetTransactionRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.GetTransactionRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.GetTransactionRequest} GetTransactionRequest
             */
            GetTransactionRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.GetTransactionRequest)
                    return object;
                var message = new $root.m10.sdk.GetTransactionRequest();
                if (object.txId != null)
                    if ($util.Long)
                        (message.txId = $util.Long.fromValue(object.txId)).unsigned = true;
                    else if (typeof object.txId === "string")
                        message.txId = parseInt(object.txId, 10);
                    else if (typeof object.txId === "number")
                        message.txId = object.txId;
                    else if (typeof object.txId === "object")
                        message.txId = new $util.LongBits(object.txId.low >>> 0, object.txId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GetTransactionRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.GetTransactionRequest
             * @static
             * @param {m10.sdk.GetTransactionRequest} message GetTransactionRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetTransactionRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.txId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.txId = options.longs === String ? "0" : 0;
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (typeof message.txId === "number")
                        object.txId = options.longs === String ? String(message.txId) : message.txId;
                    else
                        object.txId = options.longs === String ? $util.Long.prototype.toString.call(message.txId) : options.longs === Number ? new $util.LongBits(message.txId.low >>> 0, message.txId.high >>> 0).toNumber(true) : message.txId;
                return object;
            };

            /**
             * Converts this GetTransactionRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.GetTransactionRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetTransactionRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetTransactionRequest;
        })();

        sdk.ListTransactionsRequest = (function() {

            /**
             * Properties of a ListTransactionsRequest.
             * @memberof m10.sdk
             * @interface IListTransactionsRequest
             * @property {Uint8Array|null} [contextId] ListTransactionsRequest contextId
             * @property {number|Long|null} [limit] ListTransactionsRequest limit
             * @property {number|Long|null} [minTxId] ListTransactionsRequest minTxId
             * @property {number|Long|null} [maxTxId] ListTransactionsRequest maxTxId
             */

            /**
             * Constructs a new ListTransactionsRequest.
             * @memberof m10.sdk
             * @classdesc Represents a ListTransactionsRequest.
             * @implements IListTransactionsRequest
             * @constructor
             * @param {m10.sdk.IListTransactionsRequest=} [properties] Properties to set
             */
            function ListTransactionsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListTransactionsRequest contextId.
             * @member {Uint8Array} contextId
             * @memberof m10.sdk.ListTransactionsRequest
             * @instance
             */
            ListTransactionsRequest.prototype.contextId = $util.newBuffer([]);

            /**
             * ListTransactionsRequest limit.
             * @member {number|Long} limit
             * @memberof m10.sdk.ListTransactionsRequest
             * @instance
             */
            ListTransactionsRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ListTransactionsRequest minTxId.
             * @member {number|Long} minTxId
             * @memberof m10.sdk.ListTransactionsRequest
             * @instance
             */
            ListTransactionsRequest.prototype.minTxId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * ListTransactionsRequest maxTxId.
             * @member {number|Long} maxTxId
             * @memberof m10.sdk.ListTransactionsRequest
             * @instance
             */
            ListTransactionsRequest.prototype.maxTxId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ListTransactionsRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ListTransactionsRequest
             * @static
             * @param {m10.sdk.IListTransactionsRequest=} [properties] Properties to set
             * @returns {m10.sdk.ListTransactionsRequest} ListTransactionsRequest instance
             */
            ListTransactionsRequest.create = function create(properties) {
                return new ListTransactionsRequest(properties);
            };

            /**
             * Encodes the specified ListTransactionsRequest message. Does not implicitly {@link m10.sdk.ListTransactionsRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ListTransactionsRequest
             * @static
             * @param {m10.sdk.IListTransactionsRequest} message ListTransactionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListTransactionsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.contextId);
                if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.limit);
                if (message.minTxId != null && Object.hasOwnProperty.call(message, "minTxId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.minTxId);
                if (message.maxTxId != null && Object.hasOwnProperty.call(message, "maxTxId"))
                    writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.maxTxId);
                return writer;
            };

            /**
             * Encodes the specified ListTransactionsRequest message, length delimited. Does not implicitly {@link m10.sdk.ListTransactionsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ListTransactionsRequest
             * @static
             * @param {m10.sdk.IListTransactionsRequest} message ListTransactionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListTransactionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListTransactionsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ListTransactionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ListTransactionsRequest} ListTransactionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListTransactionsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ListTransactionsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.contextId = reader.bytes();
                        break;
                    case 3:
                        message.limit = reader.uint64();
                        break;
                    case 4:
                        message.minTxId = reader.uint64();
                        break;
                    case 5:
                        message.maxTxId = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListTransactionsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ListTransactionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ListTransactionsRequest} ListTransactionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListTransactionsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListTransactionsRequest message.
             * @function verify
             * @memberof m10.sdk.ListTransactionsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListTransactionsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.contextId != null && message.hasOwnProperty("contextId"))
                    if (!(message.contextId && typeof message.contextId.length === "number" || $util.isString(message.contextId)))
                        return "contextId: buffer expected";
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                        return "limit: integer|Long expected";
                if (message.minTxId != null && message.hasOwnProperty("minTxId"))
                    if (!$util.isInteger(message.minTxId) && !(message.minTxId && $util.isInteger(message.minTxId.low) && $util.isInteger(message.minTxId.high)))
                        return "minTxId: integer|Long expected";
                if (message.maxTxId != null && message.hasOwnProperty("maxTxId"))
                    if (!$util.isInteger(message.maxTxId) && !(message.maxTxId && $util.isInteger(message.maxTxId.low) && $util.isInteger(message.maxTxId.high)))
                        return "maxTxId: integer|Long expected";
                return null;
            };

            /**
             * Creates a ListTransactionsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ListTransactionsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ListTransactionsRequest} ListTransactionsRequest
             */
            ListTransactionsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ListTransactionsRequest)
                    return object;
                var message = new $root.m10.sdk.ListTransactionsRequest();
                if (object.contextId != null)
                    if (typeof object.contextId === "string")
                        $util.base64.decode(object.contextId, message.contextId = $util.newBuffer($util.base64.length(object.contextId)), 0);
                    else if (object.contextId.length)
                        message.contextId = object.contextId;
                if (object.limit != null)
                    if ($util.Long)
                        (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                    else if (typeof object.limit === "string")
                        message.limit = parseInt(object.limit, 10);
                    else if (typeof object.limit === "number")
                        message.limit = object.limit;
                    else if (typeof object.limit === "object")
                        message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                if (object.minTxId != null)
                    if ($util.Long)
                        (message.minTxId = $util.Long.fromValue(object.minTxId)).unsigned = true;
                    else if (typeof object.minTxId === "string")
                        message.minTxId = parseInt(object.minTxId, 10);
                    else if (typeof object.minTxId === "number")
                        message.minTxId = object.minTxId;
                    else if (typeof object.minTxId === "object")
                        message.minTxId = new $util.LongBits(object.minTxId.low >>> 0, object.minTxId.high >>> 0).toNumber(true);
                if (object.maxTxId != null)
                    if ($util.Long)
                        (message.maxTxId = $util.Long.fromValue(object.maxTxId)).unsigned = true;
                    else if (typeof object.maxTxId === "string")
                        message.maxTxId = parseInt(object.maxTxId, 10);
                    else if (typeof object.maxTxId === "number")
                        message.maxTxId = object.maxTxId;
                    else if (typeof object.maxTxId === "object")
                        message.maxTxId = new $util.LongBits(object.maxTxId.low >>> 0, object.maxTxId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ListTransactionsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ListTransactionsRequest
             * @static
             * @param {m10.sdk.ListTransactionsRequest} message ListTransactionsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListTransactionsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.contextId = "";
                    else {
                        object.contextId = [];
                        if (options.bytes !== Array)
                            object.contextId = $util.newBuffer(object.contextId);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.limit = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.minTxId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.minTxId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.maxTxId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxTxId = options.longs === String ? "0" : 0;
                }
                if (message.contextId != null && message.hasOwnProperty("contextId"))
                    object.contextId = options.bytes === String ? $util.base64.encode(message.contextId, 0, message.contextId.length) : options.bytes === Array ? Array.prototype.slice.call(message.contextId) : message.contextId;
                if (message.limit != null && message.hasOwnProperty("limit"))
                    if (typeof message.limit === "number")
                        object.limit = options.longs === String ? String(message.limit) : message.limit;
                    else
                        object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                if (message.minTxId != null && message.hasOwnProperty("minTxId"))
                    if (typeof message.minTxId === "number")
                        object.minTxId = options.longs === String ? String(message.minTxId) : message.minTxId;
                    else
                        object.minTxId = options.longs === String ? $util.Long.prototype.toString.call(message.minTxId) : options.longs === Number ? new $util.LongBits(message.minTxId.low >>> 0, message.minTxId.high >>> 0).toNumber(true) : message.minTxId;
                if (message.maxTxId != null && message.hasOwnProperty("maxTxId"))
                    if (typeof message.maxTxId === "number")
                        object.maxTxId = options.longs === String ? String(message.maxTxId) : message.maxTxId;
                    else
                        object.maxTxId = options.longs === String ? $util.Long.prototype.toString.call(message.maxTxId) : options.longs === Number ? new $util.LongBits(message.maxTxId.low >>> 0, message.maxTxId.high >>> 0).toNumber(true) : message.maxTxId;
                return object;
            };

            /**
             * Converts this ListTransactionsRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.ListTransactionsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListTransactionsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListTransactionsRequest;
        })();

        sdk.GroupTransactionsRequest = (function() {

            /**
             * Properties of a GroupTransactionsRequest.
             * @memberof m10.sdk
             * @interface IGroupTransactionsRequest
             * @property {Uint8Array|null} [accountId] GroupTransactionsRequest accountId
             * @property {number|Long|null} [limitGroups] GroupTransactionsRequest limitGroups
             * @property {number|Long|null} [minTxId] GroupTransactionsRequest minTxId
             * @property {number|Long|null} [maxTxId] GroupTransactionsRequest maxTxId
             */

            /**
             * Constructs a new GroupTransactionsRequest.
             * @memberof m10.sdk
             * @classdesc Represents a GroupTransactionsRequest.
             * @implements IGroupTransactionsRequest
             * @constructor
             * @param {m10.sdk.IGroupTransactionsRequest=} [properties] Properties to set
             */
            function GroupTransactionsRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupTransactionsRequest accountId.
             * @member {Uint8Array} accountId
             * @memberof m10.sdk.GroupTransactionsRequest
             * @instance
             */
            GroupTransactionsRequest.prototype.accountId = $util.newBuffer([]);

            /**
             * GroupTransactionsRequest limitGroups.
             * @member {number|Long} limitGroups
             * @memberof m10.sdk.GroupTransactionsRequest
             * @instance
             */
            GroupTransactionsRequest.prototype.limitGroups = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupTransactionsRequest minTxId.
             * @member {number|Long} minTxId
             * @memberof m10.sdk.GroupTransactionsRequest
             * @instance
             */
            GroupTransactionsRequest.prototype.minTxId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * GroupTransactionsRequest maxTxId.
             * @member {number|Long} maxTxId
             * @memberof m10.sdk.GroupTransactionsRequest
             * @instance
             */
            GroupTransactionsRequest.prototype.maxTxId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new GroupTransactionsRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.GroupTransactionsRequest
             * @static
             * @param {m10.sdk.IGroupTransactionsRequest=} [properties] Properties to set
             * @returns {m10.sdk.GroupTransactionsRequest} GroupTransactionsRequest instance
             */
            GroupTransactionsRequest.create = function create(properties) {
                return new GroupTransactionsRequest(properties);
            };

            /**
             * Encodes the specified GroupTransactionsRequest message. Does not implicitly {@link m10.sdk.GroupTransactionsRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.GroupTransactionsRequest
             * @static
             * @param {m10.sdk.IGroupTransactionsRequest} message GroupTransactionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupTransactionsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountId);
                if (message.limitGroups != null && Object.hasOwnProperty.call(message, "limitGroups"))
                    writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.limitGroups);
                if (message.minTxId != null && Object.hasOwnProperty.call(message, "minTxId"))
                    writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.minTxId);
                if (message.maxTxId != null && Object.hasOwnProperty.call(message, "maxTxId"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.maxTxId);
                return writer;
            };

            /**
             * Encodes the specified GroupTransactionsRequest message, length delimited. Does not implicitly {@link m10.sdk.GroupTransactionsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.GroupTransactionsRequest
             * @static
             * @param {m10.sdk.IGroupTransactionsRequest} message GroupTransactionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupTransactionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupTransactionsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.GroupTransactionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.GroupTransactionsRequest} GroupTransactionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupTransactionsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.GroupTransactionsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.accountId = reader.bytes();
                        break;
                    case 2:
                        message.limitGroups = reader.uint64();
                        break;
                    case 3:
                        message.minTxId = reader.uint64();
                        break;
                    case 4:
                        message.maxTxId = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupTransactionsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.GroupTransactionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.GroupTransactionsRequest} GroupTransactionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupTransactionsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupTransactionsRequest message.
             * @function verify
             * @memberof m10.sdk.GroupTransactionsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupTransactionsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.accountId != null && message.hasOwnProperty("accountId"))
                    if (!(message.accountId && typeof message.accountId.length === "number" || $util.isString(message.accountId)))
                        return "accountId: buffer expected";
                if (message.limitGroups != null && message.hasOwnProperty("limitGroups"))
                    if (!$util.isInteger(message.limitGroups) && !(message.limitGroups && $util.isInteger(message.limitGroups.low) && $util.isInteger(message.limitGroups.high)))
                        return "limitGroups: integer|Long expected";
                if (message.minTxId != null && message.hasOwnProperty("minTxId"))
                    if (!$util.isInteger(message.minTxId) && !(message.minTxId && $util.isInteger(message.minTxId.low) && $util.isInteger(message.minTxId.high)))
                        return "minTxId: integer|Long expected";
                if (message.maxTxId != null && message.hasOwnProperty("maxTxId"))
                    if (!$util.isInteger(message.maxTxId) && !(message.maxTxId && $util.isInteger(message.maxTxId.low) && $util.isInteger(message.maxTxId.high)))
                        return "maxTxId: integer|Long expected";
                return null;
            };

            /**
             * Creates a GroupTransactionsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.GroupTransactionsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.GroupTransactionsRequest} GroupTransactionsRequest
             */
            GroupTransactionsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.GroupTransactionsRequest)
                    return object;
                var message = new $root.m10.sdk.GroupTransactionsRequest();
                if (object.accountId != null)
                    if (typeof object.accountId === "string")
                        $util.base64.decode(object.accountId, message.accountId = $util.newBuffer($util.base64.length(object.accountId)), 0);
                    else if (object.accountId.length)
                        message.accountId = object.accountId;
                if (object.limitGroups != null)
                    if ($util.Long)
                        (message.limitGroups = $util.Long.fromValue(object.limitGroups)).unsigned = true;
                    else if (typeof object.limitGroups === "string")
                        message.limitGroups = parseInt(object.limitGroups, 10);
                    else if (typeof object.limitGroups === "number")
                        message.limitGroups = object.limitGroups;
                    else if (typeof object.limitGroups === "object")
                        message.limitGroups = new $util.LongBits(object.limitGroups.low >>> 0, object.limitGroups.high >>> 0).toNumber(true);
                if (object.minTxId != null)
                    if ($util.Long)
                        (message.minTxId = $util.Long.fromValue(object.minTxId)).unsigned = true;
                    else if (typeof object.minTxId === "string")
                        message.minTxId = parseInt(object.minTxId, 10);
                    else if (typeof object.minTxId === "number")
                        message.minTxId = object.minTxId;
                    else if (typeof object.minTxId === "object")
                        message.minTxId = new $util.LongBits(object.minTxId.low >>> 0, object.minTxId.high >>> 0).toNumber(true);
                if (object.maxTxId != null)
                    if ($util.Long)
                        (message.maxTxId = $util.Long.fromValue(object.maxTxId)).unsigned = true;
                    else if (typeof object.maxTxId === "string")
                        message.maxTxId = parseInt(object.maxTxId, 10);
                    else if (typeof object.maxTxId === "number")
                        message.maxTxId = object.maxTxId;
                    else if (typeof object.maxTxId === "object")
                        message.maxTxId = new $util.LongBits(object.maxTxId.low >>> 0, object.maxTxId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a GroupTransactionsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.GroupTransactionsRequest
             * @static
             * @param {m10.sdk.GroupTransactionsRequest} message GroupTransactionsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupTransactionsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    if (options.bytes === String)
                        object.accountId = "";
                    else {
                        object.accountId = [];
                        if (options.bytes !== Array)
                            object.accountId = $util.newBuffer(object.accountId);
                    }
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.limitGroups = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.limitGroups = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.minTxId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.minTxId = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.maxTxId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.maxTxId = options.longs === String ? "0" : 0;
                }
                if (message.accountId != null && message.hasOwnProperty("accountId"))
                    object.accountId = options.bytes === String ? $util.base64.encode(message.accountId, 0, message.accountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountId) : message.accountId;
                if (message.limitGroups != null && message.hasOwnProperty("limitGroups"))
                    if (typeof message.limitGroups === "number")
                        object.limitGroups = options.longs === String ? String(message.limitGroups) : message.limitGroups;
                    else
                        object.limitGroups = options.longs === String ? $util.Long.prototype.toString.call(message.limitGroups) : options.longs === Number ? new $util.LongBits(message.limitGroups.low >>> 0, message.limitGroups.high >>> 0).toNumber(true) : message.limitGroups;
                if (message.minTxId != null && message.hasOwnProperty("minTxId"))
                    if (typeof message.minTxId === "number")
                        object.minTxId = options.longs === String ? String(message.minTxId) : message.minTxId;
                    else
                        object.minTxId = options.longs === String ? $util.Long.prototype.toString.call(message.minTxId) : options.longs === Number ? new $util.LongBits(message.minTxId.low >>> 0, message.minTxId.high >>> 0).toNumber(true) : message.minTxId;
                if (message.maxTxId != null && message.hasOwnProperty("maxTxId"))
                    if (typeof message.maxTxId === "number")
                        object.maxTxId = options.longs === String ? String(message.maxTxId) : message.maxTxId;
                    else
                        object.maxTxId = options.longs === String ? $util.Long.prototype.toString.call(message.maxTxId) : options.longs === Number ? new $util.LongBits(message.maxTxId.low >>> 0, message.maxTxId.high >>> 0).toNumber(true) : message.maxTxId;
                return object;
            };

            /**
             * Converts this GroupTransactionsRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.GroupTransactionsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupTransactionsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupTransactionsRequest;
        })();

        sdk.ObserveAccountsRequest = (function() {

            /**
             * Properties of an ObserveAccountsRequest.
             * @memberof m10.sdk
             * @interface IObserveAccountsRequest
             * @property {m10.sdk.ITxId|null} [startingFrom] ObserveAccountsRequest startingFrom
             * @property {Array.<Uint8Array>|null} [involvedAccounts] ObserveAccountsRequest involvedAccounts
             */

            /**
             * Constructs a new ObserveAccountsRequest.
             * @memberof m10.sdk
             * @classdesc Represents an ObserveAccountsRequest.
             * @implements IObserveAccountsRequest
             * @constructor
             * @param {m10.sdk.IObserveAccountsRequest=} [properties] Properties to set
             */
            function ObserveAccountsRequest(properties) {
                this.involvedAccounts = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ObserveAccountsRequest startingFrom.
             * @member {m10.sdk.ITxId|null|undefined} startingFrom
             * @memberof m10.sdk.ObserveAccountsRequest
             * @instance
             */
            ObserveAccountsRequest.prototype.startingFrom = null;

            /**
             * ObserveAccountsRequest involvedAccounts.
             * @member {Array.<Uint8Array>} involvedAccounts
             * @memberof m10.sdk.ObserveAccountsRequest
             * @instance
             */
            ObserveAccountsRequest.prototype.involvedAccounts = $util.emptyArray;

            /**
             * Creates a new ObserveAccountsRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ObserveAccountsRequest
             * @static
             * @param {m10.sdk.IObserveAccountsRequest=} [properties] Properties to set
             * @returns {m10.sdk.ObserveAccountsRequest} ObserveAccountsRequest instance
             */
            ObserveAccountsRequest.create = function create(properties) {
                return new ObserveAccountsRequest(properties);
            };

            /**
             * Encodes the specified ObserveAccountsRequest message. Does not implicitly {@link m10.sdk.ObserveAccountsRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ObserveAccountsRequest
             * @static
             * @param {m10.sdk.IObserveAccountsRequest} message ObserveAccountsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObserveAccountsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.startingFrom != null && Object.hasOwnProperty.call(message, "startingFrom"))
                    $root.m10.sdk.TxId.encode(message.startingFrom, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.involvedAccounts != null && message.involvedAccounts.length)
                    for (var i = 0; i < message.involvedAccounts.length; ++i)
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.involvedAccounts[i]);
                return writer;
            };

            /**
             * Encodes the specified ObserveAccountsRequest message, length delimited. Does not implicitly {@link m10.sdk.ObserveAccountsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ObserveAccountsRequest
             * @static
             * @param {m10.sdk.IObserveAccountsRequest} message ObserveAccountsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObserveAccountsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ObserveAccountsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ObserveAccountsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ObserveAccountsRequest} ObserveAccountsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObserveAccountsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ObserveAccountsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.startingFrom = $root.m10.sdk.TxId.decode(reader, reader.uint32());
                        break;
                    case 2:
                        if (!(message.involvedAccounts && message.involvedAccounts.length))
                            message.involvedAccounts = [];
                        message.involvedAccounts.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ObserveAccountsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ObserveAccountsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ObserveAccountsRequest} ObserveAccountsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObserveAccountsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ObserveAccountsRequest message.
             * @function verify
             * @memberof m10.sdk.ObserveAccountsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ObserveAccountsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.startingFrom != null && message.hasOwnProperty("startingFrom")) {
                    var error = $root.m10.sdk.TxId.verify(message.startingFrom);
                    if (error)
                        return "startingFrom." + error;
                }
                if (message.involvedAccounts != null && message.hasOwnProperty("involvedAccounts")) {
                    if (!Array.isArray(message.involvedAccounts))
                        return "involvedAccounts: array expected";
                    for (var i = 0; i < message.involvedAccounts.length; ++i)
                        if (!(message.involvedAccounts[i] && typeof message.involvedAccounts[i].length === "number" || $util.isString(message.involvedAccounts[i])))
                            return "involvedAccounts: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates an ObserveAccountsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ObserveAccountsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ObserveAccountsRequest} ObserveAccountsRequest
             */
            ObserveAccountsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ObserveAccountsRequest)
                    return object;
                var message = new $root.m10.sdk.ObserveAccountsRequest();
                if (object.startingFrom != null) {
                    if (typeof object.startingFrom !== "object")
                        throw TypeError(".m10.sdk.ObserveAccountsRequest.startingFrom: object expected");
                    message.startingFrom = $root.m10.sdk.TxId.fromObject(object.startingFrom);
                }
                if (object.involvedAccounts) {
                    if (!Array.isArray(object.involvedAccounts))
                        throw TypeError(".m10.sdk.ObserveAccountsRequest.involvedAccounts: array expected");
                    message.involvedAccounts = [];
                    for (var i = 0; i < object.involvedAccounts.length; ++i)
                        if (typeof object.involvedAccounts[i] === "string")
                            $util.base64.decode(object.involvedAccounts[i], message.involvedAccounts[i] = $util.newBuffer($util.base64.length(object.involvedAccounts[i])), 0);
                        else if (object.involvedAccounts[i].length)
                            message.involvedAccounts[i] = object.involvedAccounts[i];
                }
                return message;
            };

            /**
             * Creates a plain object from an ObserveAccountsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ObserveAccountsRequest
             * @static
             * @param {m10.sdk.ObserveAccountsRequest} message ObserveAccountsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ObserveAccountsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.involvedAccounts = [];
                if (options.defaults)
                    object.startingFrom = null;
                if (message.startingFrom != null && message.hasOwnProperty("startingFrom"))
                    object.startingFrom = $root.m10.sdk.TxId.toObject(message.startingFrom, options);
                if (message.involvedAccounts && message.involvedAccounts.length) {
                    object.involvedAccounts = [];
                    for (var j = 0; j < message.involvedAccounts.length; ++j)
                        object.involvedAccounts[j] = options.bytes === String ? $util.base64.encode(message.involvedAccounts[j], 0, message.involvedAccounts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.involvedAccounts[j]) : message.involvedAccounts[j];
                }
                return object;
            };

            /**
             * Converts this ObserveAccountsRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.ObserveAccountsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ObserveAccountsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ObserveAccountsRequest;
        })();

        sdk.ObserveResourcesRequest = (function() {

            /**
             * Properties of an ObserveResourcesRequest.
             * @memberof m10.sdk
             * @interface IObserveResourcesRequest
             * @property {m10.sdk.IExp|null} [expression] ObserveResourcesRequest expression
             * @property {string|null} [collection] ObserveResourcesRequest collection
             * @property {m10.sdk.ITxId|null} [startingFrom] ObserveResourcesRequest startingFrom
             */

            /**
             * Constructs a new ObserveResourcesRequest.
             * @memberof m10.sdk
             * @classdesc Represents an ObserveResourcesRequest.
             * @implements IObserveResourcesRequest
             * @constructor
             * @param {m10.sdk.IObserveResourcesRequest=} [properties] Properties to set
             */
            function ObserveResourcesRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ObserveResourcesRequest expression.
             * @member {m10.sdk.IExp|null|undefined} expression
             * @memberof m10.sdk.ObserveResourcesRequest
             * @instance
             */
            ObserveResourcesRequest.prototype.expression = null;

            /**
             * ObserveResourcesRequest collection.
             * @member {string} collection
             * @memberof m10.sdk.ObserveResourcesRequest
             * @instance
             */
            ObserveResourcesRequest.prototype.collection = "";

            /**
             * ObserveResourcesRequest startingFrom.
             * @member {m10.sdk.ITxId|null|undefined} startingFrom
             * @memberof m10.sdk.ObserveResourcesRequest
             * @instance
             */
            ObserveResourcesRequest.prototype.startingFrom = null;

            /**
             * Creates a new ObserveResourcesRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ObserveResourcesRequest
             * @static
             * @param {m10.sdk.IObserveResourcesRequest=} [properties] Properties to set
             * @returns {m10.sdk.ObserveResourcesRequest} ObserveResourcesRequest instance
             */
            ObserveResourcesRequest.create = function create(properties) {
                return new ObserveResourcesRequest(properties);
            };

            /**
             * Encodes the specified ObserveResourcesRequest message. Does not implicitly {@link m10.sdk.ObserveResourcesRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ObserveResourcesRequest
             * @static
             * @param {m10.sdk.IObserveResourcesRequest} message ObserveResourcesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObserveResourcesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.expression != null && Object.hasOwnProperty.call(message, "expression"))
                    $root.m10.sdk.Exp.encode(message.expression, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                if (message.startingFrom != null && Object.hasOwnProperty.call(message, "startingFrom"))
                    $root.m10.sdk.TxId.encode(message.startingFrom, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ObserveResourcesRequest message, length delimited. Does not implicitly {@link m10.sdk.ObserveResourcesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ObserveResourcesRequest
             * @static
             * @param {m10.sdk.IObserveResourcesRequest} message ObserveResourcesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObserveResourcesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ObserveResourcesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ObserveResourcesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ObserveResourcesRequest} ObserveResourcesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObserveResourcesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ObserveResourcesRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.expression = $root.m10.sdk.Exp.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.collection = reader.string();
                        break;
                    case 3:
                        message.startingFrom = $root.m10.sdk.TxId.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ObserveResourcesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ObserveResourcesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ObserveResourcesRequest} ObserveResourcesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObserveResourcesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ObserveResourcesRequest message.
             * @function verify
             * @memberof m10.sdk.ObserveResourcesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ObserveResourcesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.expression != null && message.hasOwnProperty("expression")) {
                    var error = $root.m10.sdk.Exp.verify(message.expression);
                    if (error)
                        return "expression." + error;
                }
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.startingFrom != null && message.hasOwnProperty("startingFrom")) {
                    var error = $root.m10.sdk.TxId.verify(message.startingFrom);
                    if (error)
                        return "startingFrom." + error;
                }
                return null;
            };

            /**
             * Creates an ObserveResourcesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ObserveResourcesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ObserveResourcesRequest} ObserveResourcesRequest
             */
            ObserveResourcesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ObserveResourcesRequest)
                    return object;
                var message = new $root.m10.sdk.ObserveResourcesRequest();
                if (object.expression != null) {
                    if (typeof object.expression !== "object")
                        throw TypeError(".m10.sdk.ObserveResourcesRequest.expression: object expected");
                    message.expression = $root.m10.sdk.Exp.fromObject(object.expression);
                }
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.startingFrom != null) {
                    if (typeof object.startingFrom !== "object")
                        throw TypeError(".m10.sdk.ObserveResourcesRequest.startingFrom: object expected");
                    message.startingFrom = $root.m10.sdk.TxId.fromObject(object.startingFrom);
                }
                return message;
            };

            /**
             * Creates a plain object from an ObserveResourcesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ObserveResourcesRequest
             * @static
             * @param {m10.sdk.ObserveResourcesRequest} message ObserveResourcesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ObserveResourcesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.expression = null;
                    object.collection = "";
                    object.startingFrom = null;
                }
                if (message.expression != null && message.hasOwnProperty("expression"))
                    object.expression = $root.m10.sdk.Exp.toObject(message.expression, options);
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.startingFrom != null && message.hasOwnProperty("startingFrom"))
                    object.startingFrom = $root.m10.sdk.TxId.toObject(message.startingFrom, options);
                return object;
            };

            /**
             * Converts this ObserveResourcesRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.ObserveResourcesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ObserveResourcesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ObserveResourcesRequest;
        })();

        sdk.TxId = (function() {

            /**
             * Properties of a TxId.
             * @memberof m10.sdk
             * @interface ITxId
             * @property {number|Long|null} [txId] TxId txId
             */

            /**
             * Constructs a new TxId.
             * @memberof m10.sdk
             * @classdesc Represents a TxId.
             * @implements ITxId
             * @constructor
             * @param {m10.sdk.ITxId=} [properties] Properties to set
             */
            function TxId(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * TxId txId.
             * @member {number|Long} txId
             * @memberof m10.sdk.TxId
             * @instance
             */
            TxId.prototype.txId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new TxId instance using the specified properties.
             * @function create
             * @memberof m10.sdk.TxId
             * @static
             * @param {m10.sdk.ITxId=} [properties] Properties to set
             * @returns {m10.sdk.TxId} TxId instance
             */
            TxId.create = function create(properties) {
                return new TxId(properties);
            };

            /**
             * Encodes the specified TxId message. Does not implicitly {@link m10.sdk.TxId.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.TxId
             * @static
             * @param {m10.sdk.ITxId} message TxId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxId.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.txId);
                return writer;
            };

            /**
             * Encodes the specified TxId message, length delimited. Does not implicitly {@link m10.sdk.TxId.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.TxId
             * @static
             * @param {m10.sdk.ITxId} message TxId message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            TxId.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a TxId message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.TxId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.TxId} TxId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxId.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.TxId();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.txId = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a TxId message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.TxId
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.TxId} TxId
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            TxId.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a TxId message.
             * @function verify
             * @memberof m10.sdk.TxId
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            TxId.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (!$util.isInteger(message.txId) && !(message.txId && $util.isInteger(message.txId.low) && $util.isInteger(message.txId.high)))
                        return "txId: integer|Long expected";
                return null;
            };

            /**
             * Creates a TxId message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.TxId
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.TxId} TxId
             */
            TxId.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.TxId)
                    return object;
                var message = new $root.m10.sdk.TxId();
                if (object.txId != null)
                    if ($util.Long)
                        (message.txId = $util.Long.fromValue(object.txId)).unsigned = true;
                    else if (typeof object.txId === "string")
                        message.txId = parseInt(object.txId, 10);
                    else if (typeof object.txId === "number")
                        message.txId = object.txId;
                    else if (typeof object.txId === "object")
                        message.txId = new $util.LongBits(object.txId.low >>> 0, object.txId.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a TxId message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.TxId
             * @static
             * @param {m10.sdk.TxId} message TxId
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            TxId.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.txId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.txId = options.longs === String ? "0" : 0;
                if (message.txId != null && message.hasOwnProperty("txId"))
                    if (typeof message.txId === "number")
                        object.txId = options.longs === String ? String(message.txId) : message.txId;
                    else
                        object.txId = options.longs === String ? $util.Long.prototype.toString.call(message.txId) : options.longs === Number ? new $util.LongBits(message.txId.low >>> 0, message.txId.high >>> 0).toNumber(true) : message.txId;
                return object;
            };

            /**
             * Converts this TxId to JSON.
             * @function toJSON
             * @memberof m10.sdk.TxId
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            TxId.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return TxId;
        })();

        sdk.ObserveActionsRequest = (function() {

            /**
             * Properties of an ObserveActionsRequest.
             * @memberof m10.sdk
             * @interface IObserveActionsRequest
             * @property {m10.sdk.ITxId|null} [startingFrom] ObserveActionsRequest startingFrom
             * @property {string|null} [name] ObserveActionsRequest name
             * @property {Array.<Uint8Array>|null} [involvesAccounts] ObserveActionsRequest involvesAccounts
             */

            /**
             * Constructs a new ObserveActionsRequest.
             * @memberof m10.sdk
             * @classdesc Represents an ObserveActionsRequest.
             * @implements IObserveActionsRequest
             * @constructor
             * @param {m10.sdk.IObserveActionsRequest=} [properties] Properties to set
             */
            function ObserveActionsRequest(properties) {
                this.involvesAccounts = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ObserveActionsRequest startingFrom.
             * @member {m10.sdk.ITxId|null|undefined} startingFrom
             * @memberof m10.sdk.ObserveActionsRequest
             * @instance
             */
            ObserveActionsRequest.prototype.startingFrom = null;

            /**
             * ObserveActionsRequest name.
             * @member {string} name
             * @memberof m10.sdk.ObserveActionsRequest
             * @instance
             */
            ObserveActionsRequest.prototype.name = "";

            /**
             * ObserveActionsRequest involvesAccounts.
             * @member {Array.<Uint8Array>} involvesAccounts
             * @memberof m10.sdk.ObserveActionsRequest
             * @instance
             */
            ObserveActionsRequest.prototype.involvesAccounts = $util.emptyArray;

            /**
             * Creates a new ObserveActionsRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ObserveActionsRequest
             * @static
             * @param {m10.sdk.IObserveActionsRequest=} [properties] Properties to set
             * @returns {m10.sdk.ObserveActionsRequest} ObserveActionsRequest instance
             */
            ObserveActionsRequest.create = function create(properties) {
                return new ObserveActionsRequest(properties);
            };

            /**
             * Encodes the specified ObserveActionsRequest message. Does not implicitly {@link m10.sdk.ObserveActionsRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ObserveActionsRequest
             * @static
             * @param {m10.sdk.IObserveActionsRequest} message ObserveActionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObserveActionsRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.startingFrom != null && Object.hasOwnProperty.call(message, "startingFrom"))
                    $root.m10.sdk.TxId.encode(message.startingFrom, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.involvesAccounts != null && message.involvesAccounts.length)
                    for (var i = 0; i < message.involvesAccounts.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.involvesAccounts[i]);
                return writer;
            };

            /**
             * Encodes the specified ObserveActionsRequest message, length delimited. Does not implicitly {@link m10.sdk.ObserveActionsRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ObserveActionsRequest
             * @static
             * @param {m10.sdk.IObserveActionsRequest} message ObserveActionsRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObserveActionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ObserveActionsRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ObserveActionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ObserveActionsRequest} ObserveActionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObserveActionsRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ObserveActionsRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.startingFrom = $root.m10.sdk.TxId.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        if (!(message.involvesAccounts && message.involvesAccounts.length))
                            message.involvesAccounts = [];
                        message.involvesAccounts.push(reader.bytes());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ObserveActionsRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ObserveActionsRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ObserveActionsRequest} ObserveActionsRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObserveActionsRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ObserveActionsRequest message.
             * @function verify
             * @memberof m10.sdk.ObserveActionsRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ObserveActionsRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.startingFrom != null && message.hasOwnProperty("startingFrom")) {
                    var error = $root.m10.sdk.TxId.verify(message.startingFrom);
                    if (error)
                        return "startingFrom." + error;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.involvesAccounts != null && message.hasOwnProperty("involvesAccounts")) {
                    if (!Array.isArray(message.involvesAccounts))
                        return "involvesAccounts: array expected";
                    for (var i = 0; i < message.involvesAccounts.length; ++i)
                        if (!(message.involvesAccounts[i] && typeof message.involvesAccounts[i].length === "number" || $util.isString(message.involvesAccounts[i])))
                            return "involvesAccounts: buffer[] expected";
                }
                return null;
            };

            /**
             * Creates an ObserveActionsRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ObserveActionsRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ObserveActionsRequest} ObserveActionsRequest
             */
            ObserveActionsRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ObserveActionsRequest)
                    return object;
                var message = new $root.m10.sdk.ObserveActionsRequest();
                if (object.startingFrom != null) {
                    if (typeof object.startingFrom !== "object")
                        throw TypeError(".m10.sdk.ObserveActionsRequest.startingFrom: object expected");
                    message.startingFrom = $root.m10.sdk.TxId.fromObject(object.startingFrom);
                }
                if (object.name != null)
                    message.name = String(object.name);
                if (object.involvesAccounts) {
                    if (!Array.isArray(object.involvesAccounts))
                        throw TypeError(".m10.sdk.ObserveActionsRequest.involvesAccounts: array expected");
                    message.involvesAccounts = [];
                    for (var i = 0; i < object.involvesAccounts.length; ++i)
                        if (typeof object.involvesAccounts[i] === "string")
                            $util.base64.decode(object.involvesAccounts[i], message.involvesAccounts[i] = $util.newBuffer($util.base64.length(object.involvesAccounts[i])), 0);
                        else if (object.involvesAccounts[i].length)
                            message.involvesAccounts[i] = object.involvesAccounts[i];
                }
                return message;
            };

            /**
             * Creates a plain object from an ObserveActionsRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ObserveActionsRequest
             * @static
             * @param {m10.sdk.ObserveActionsRequest} message ObserveActionsRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ObserveActionsRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.involvesAccounts = [];
                if (options.defaults) {
                    object.startingFrom = null;
                    object.name = "";
                }
                if (message.startingFrom != null && message.hasOwnProperty("startingFrom"))
                    object.startingFrom = $root.m10.sdk.TxId.toObject(message.startingFrom, options);
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.involvesAccounts && message.involvesAccounts.length) {
                    object.involvesAccounts = [];
                    for (var j = 0; j < message.involvesAccounts.length; ++j)
                        object.involvesAccounts[j] = options.bytes === String ? $util.base64.encode(message.involvesAccounts[j], 0, message.involvesAccounts[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.involvesAccounts[j]) : message.involvesAccounts[j];
                }
                return object;
            };

            /**
             * Converts this ObserveActionsRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.ObserveActionsRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ObserveActionsRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ObserveActionsRequest;
        })();

        sdk.FinalizedTransaction = (function() {

            /**
             * Properties of a FinalizedTransaction.
             * @memberof m10.sdk
             * @interface IFinalizedTransaction
             * @property {m10.sdk.transaction.ITransactionRequestPayload|null} [request] FinalizedTransaction request
             * @property {m10.sdk.transaction.ITransactionResponse|null} [response] FinalizedTransaction response
             */

            /**
             * Constructs a new FinalizedTransaction.
             * @memberof m10.sdk
             * @classdesc Represents a FinalizedTransaction.
             * @implements IFinalizedTransaction
             * @constructor
             * @param {m10.sdk.IFinalizedTransaction=} [properties] Properties to set
             */
            function FinalizedTransaction(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FinalizedTransaction request.
             * @member {m10.sdk.transaction.ITransactionRequestPayload|null|undefined} request
             * @memberof m10.sdk.FinalizedTransaction
             * @instance
             */
            FinalizedTransaction.prototype.request = null;

            /**
             * FinalizedTransaction response.
             * @member {m10.sdk.transaction.ITransactionResponse|null|undefined} response
             * @memberof m10.sdk.FinalizedTransaction
             * @instance
             */
            FinalizedTransaction.prototype.response = null;

            /**
             * Creates a new FinalizedTransaction instance using the specified properties.
             * @function create
             * @memberof m10.sdk.FinalizedTransaction
             * @static
             * @param {m10.sdk.IFinalizedTransaction=} [properties] Properties to set
             * @returns {m10.sdk.FinalizedTransaction} FinalizedTransaction instance
             */
            FinalizedTransaction.create = function create(properties) {
                return new FinalizedTransaction(properties);
            };

            /**
             * Encodes the specified FinalizedTransaction message. Does not implicitly {@link m10.sdk.FinalizedTransaction.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.FinalizedTransaction
             * @static
             * @param {m10.sdk.IFinalizedTransaction} message FinalizedTransaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FinalizedTransaction.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.request != null && Object.hasOwnProperty.call(message, "request"))
                    $root.m10.sdk.transaction.TransactionRequestPayload.encode(message.request, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.response != null && Object.hasOwnProperty.call(message, "response"))
                    $root.m10.sdk.transaction.TransactionResponse.encode(message.response, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FinalizedTransaction message, length delimited. Does not implicitly {@link m10.sdk.FinalizedTransaction.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.FinalizedTransaction
             * @static
             * @param {m10.sdk.IFinalizedTransaction} message FinalizedTransaction message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FinalizedTransaction.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FinalizedTransaction message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.FinalizedTransaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.FinalizedTransaction} FinalizedTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FinalizedTransaction.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.FinalizedTransaction();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.request = $root.m10.sdk.transaction.TransactionRequestPayload.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.response = $root.m10.sdk.transaction.TransactionResponse.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FinalizedTransaction message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.FinalizedTransaction
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.FinalizedTransaction} FinalizedTransaction
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FinalizedTransaction.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FinalizedTransaction message.
             * @function verify
             * @memberof m10.sdk.FinalizedTransaction
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FinalizedTransaction.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.request != null && message.hasOwnProperty("request")) {
                    var error = $root.m10.sdk.transaction.TransactionRequestPayload.verify(message.request);
                    if (error)
                        return "request." + error;
                }
                if (message.response != null && message.hasOwnProperty("response")) {
                    var error = $root.m10.sdk.transaction.TransactionResponse.verify(message.response);
                    if (error)
                        return "response." + error;
                }
                return null;
            };

            /**
             * Creates a FinalizedTransaction message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.FinalizedTransaction
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.FinalizedTransaction} FinalizedTransaction
             */
            FinalizedTransaction.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.FinalizedTransaction)
                    return object;
                var message = new $root.m10.sdk.FinalizedTransaction();
                if (object.request != null) {
                    if (typeof object.request !== "object")
                        throw TypeError(".m10.sdk.FinalizedTransaction.request: object expected");
                    message.request = $root.m10.sdk.transaction.TransactionRequestPayload.fromObject(object.request);
                }
                if (object.response != null) {
                    if (typeof object.response !== "object")
                        throw TypeError(".m10.sdk.FinalizedTransaction.response: object expected");
                    message.response = $root.m10.sdk.transaction.TransactionResponse.fromObject(object.response);
                }
                return message;
            };

            /**
             * Creates a plain object from a FinalizedTransaction message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.FinalizedTransaction
             * @static
             * @param {m10.sdk.FinalizedTransaction} message FinalizedTransaction
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FinalizedTransaction.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.request = null;
                    object.response = null;
                }
                if (message.request != null && message.hasOwnProperty("request"))
                    object.request = $root.m10.sdk.transaction.TransactionRequestPayload.toObject(message.request, options);
                if (message.response != null && message.hasOwnProperty("response"))
                    object.response = $root.m10.sdk.transaction.TransactionResponse.toObject(message.response, options);
                return object;
            };

            /**
             * Converts this FinalizedTransaction to JSON.
             * @function toJSON
             * @memberof m10.sdk.FinalizedTransaction
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FinalizedTransaction.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FinalizedTransaction;
        })();

        sdk.FinalizedTransactions = (function() {

            /**
             * Properties of a FinalizedTransactions.
             * @memberof m10.sdk
             * @interface IFinalizedTransactions
             * @property {Array.<m10.sdk.IFinalizedTransaction>|null} [transactions] FinalizedTransactions transactions
             */

            /**
             * Constructs a new FinalizedTransactions.
             * @memberof m10.sdk
             * @classdesc Represents a FinalizedTransactions.
             * @implements IFinalizedTransactions
             * @constructor
             * @param {m10.sdk.IFinalizedTransactions=} [properties] Properties to set
             */
            function FinalizedTransactions(properties) {
                this.transactions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FinalizedTransactions transactions.
             * @member {Array.<m10.sdk.IFinalizedTransaction>} transactions
             * @memberof m10.sdk.FinalizedTransactions
             * @instance
             */
            FinalizedTransactions.prototype.transactions = $util.emptyArray;

            /**
             * Creates a new FinalizedTransactions instance using the specified properties.
             * @function create
             * @memberof m10.sdk.FinalizedTransactions
             * @static
             * @param {m10.sdk.IFinalizedTransactions=} [properties] Properties to set
             * @returns {m10.sdk.FinalizedTransactions} FinalizedTransactions instance
             */
            FinalizedTransactions.create = function create(properties) {
                return new FinalizedTransactions(properties);
            };

            /**
             * Encodes the specified FinalizedTransactions message. Does not implicitly {@link m10.sdk.FinalizedTransactions.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.FinalizedTransactions
             * @static
             * @param {m10.sdk.IFinalizedTransactions} message FinalizedTransactions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FinalizedTransactions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.transactions != null && message.transactions.length)
                    for (var i = 0; i < message.transactions.length; ++i)
                        $root.m10.sdk.FinalizedTransaction.encode(message.transactions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FinalizedTransactions message, length delimited. Does not implicitly {@link m10.sdk.FinalizedTransactions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.FinalizedTransactions
             * @static
             * @param {m10.sdk.IFinalizedTransactions} message FinalizedTransactions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FinalizedTransactions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FinalizedTransactions message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.FinalizedTransactions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.FinalizedTransactions} FinalizedTransactions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FinalizedTransactions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.FinalizedTransactions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.transactions && message.transactions.length))
                            message.transactions = [];
                        message.transactions.push($root.m10.sdk.FinalizedTransaction.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FinalizedTransactions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.FinalizedTransactions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.FinalizedTransactions} FinalizedTransactions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FinalizedTransactions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FinalizedTransactions message.
             * @function verify
             * @memberof m10.sdk.FinalizedTransactions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FinalizedTransactions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.transactions != null && message.hasOwnProperty("transactions")) {
                    if (!Array.isArray(message.transactions))
                        return "transactions: array expected";
                    for (var i = 0; i < message.transactions.length; ++i) {
                        var error = $root.m10.sdk.FinalizedTransaction.verify(message.transactions[i]);
                        if (error)
                            return "transactions." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FinalizedTransactions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.FinalizedTransactions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.FinalizedTransactions} FinalizedTransactions
             */
            FinalizedTransactions.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.FinalizedTransactions)
                    return object;
                var message = new $root.m10.sdk.FinalizedTransactions();
                if (object.transactions) {
                    if (!Array.isArray(object.transactions))
                        throw TypeError(".m10.sdk.FinalizedTransactions.transactions: array expected");
                    message.transactions = [];
                    for (var i = 0; i < object.transactions.length; ++i) {
                        if (typeof object.transactions[i] !== "object")
                            throw TypeError(".m10.sdk.FinalizedTransactions.transactions: object expected");
                        message.transactions[i] = $root.m10.sdk.FinalizedTransaction.fromObject(object.transactions[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FinalizedTransactions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.FinalizedTransactions
             * @static
             * @param {m10.sdk.FinalizedTransactions} message FinalizedTransactions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FinalizedTransactions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.transactions = [];
                if (message.transactions && message.transactions.length) {
                    object.transactions = [];
                    for (var j = 0; j < message.transactions.length; ++j)
                        object.transactions[j] = $root.m10.sdk.FinalizedTransaction.toObject(message.transactions[j], options);
                }
                return object;
            };

            /**
             * Converts this FinalizedTransactions to JSON.
             * @function toJSON
             * @memberof m10.sdk.FinalizedTransactions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FinalizedTransactions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FinalizedTransactions;
        })();

        sdk.GroupedFinalizedTransactions = (function() {

            /**
             * Properties of a GroupedFinalizedTransactions.
             * @memberof m10.sdk
             * @interface IGroupedFinalizedTransactions
             * @property {Array.<m10.sdk.IFinalizedTransactions>|null} [groups] GroupedFinalizedTransactions groups
             */

            /**
             * Constructs a new GroupedFinalizedTransactions.
             * @memberof m10.sdk
             * @classdesc Represents a GroupedFinalizedTransactions.
             * @implements IGroupedFinalizedTransactions
             * @constructor
             * @param {m10.sdk.IGroupedFinalizedTransactions=} [properties] Properties to set
             */
            function GroupedFinalizedTransactions(properties) {
                this.groups = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GroupedFinalizedTransactions groups.
             * @member {Array.<m10.sdk.IFinalizedTransactions>} groups
             * @memberof m10.sdk.GroupedFinalizedTransactions
             * @instance
             */
            GroupedFinalizedTransactions.prototype.groups = $util.emptyArray;

            /**
             * Creates a new GroupedFinalizedTransactions instance using the specified properties.
             * @function create
             * @memberof m10.sdk.GroupedFinalizedTransactions
             * @static
             * @param {m10.sdk.IGroupedFinalizedTransactions=} [properties] Properties to set
             * @returns {m10.sdk.GroupedFinalizedTransactions} GroupedFinalizedTransactions instance
             */
            GroupedFinalizedTransactions.create = function create(properties) {
                return new GroupedFinalizedTransactions(properties);
            };

            /**
             * Encodes the specified GroupedFinalizedTransactions message. Does not implicitly {@link m10.sdk.GroupedFinalizedTransactions.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.GroupedFinalizedTransactions
             * @static
             * @param {m10.sdk.IGroupedFinalizedTransactions} message GroupedFinalizedTransactions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupedFinalizedTransactions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.groups != null && message.groups.length)
                    for (var i = 0; i < message.groups.length; ++i)
                        $root.m10.sdk.FinalizedTransactions.encode(message.groups[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GroupedFinalizedTransactions message, length delimited. Does not implicitly {@link m10.sdk.GroupedFinalizedTransactions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.GroupedFinalizedTransactions
             * @static
             * @param {m10.sdk.IGroupedFinalizedTransactions} message GroupedFinalizedTransactions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GroupedFinalizedTransactions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GroupedFinalizedTransactions message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.GroupedFinalizedTransactions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.GroupedFinalizedTransactions} GroupedFinalizedTransactions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupedFinalizedTransactions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.GroupedFinalizedTransactions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.groups && message.groups.length))
                            message.groups = [];
                        message.groups.push($root.m10.sdk.FinalizedTransactions.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GroupedFinalizedTransactions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.GroupedFinalizedTransactions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.GroupedFinalizedTransactions} GroupedFinalizedTransactions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GroupedFinalizedTransactions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GroupedFinalizedTransactions message.
             * @function verify
             * @memberof m10.sdk.GroupedFinalizedTransactions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GroupedFinalizedTransactions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.groups != null && message.hasOwnProperty("groups")) {
                    if (!Array.isArray(message.groups))
                        return "groups: array expected";
                    for (var i = 0; i < message.groups.length; ++i) {
                        var error = $root.m10.sdk.FinalizedTransactions.verify(message.groups[i]);
                        if (error)
                            return "groups." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GroupedFinalizedTransactions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.GroupedFinalizedTransactions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.GroupedFinalizedTransactions} GroupedFinalizedTransactions
             */
            GroupedFinalizedTransactions.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.GroupedFinalizedTransactions)
                    return object;
                var message = new $root.m10.sdk.GroupedFinalizedTransactions();
                if (object.groups) {
                    if (!Array.isArray(object.groups))
                        throw TypeError(".m10.sdk.GroupedFinalizedTransactions.groups: array expected");
                    message.groups = [];
                    for (var i = 0; i < object.groups.length; ++i) {
                        if (typeof object.groups[i] !== "object")
                            throw TypeError(".m10.sdk.GroupedFinalizedTransactions.groups: object expected");
                        message.groups[i] = $root.m10.sdk.FinalizedTransactions.fromObject(object.groups[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GroupedFinalizedTransactions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.GroupedFinalizedTransactions
             * @static
             * @param {m10.sdk.GroupedFinalizedTransactions} message GroupedFinalizedTransactions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GroupedFinalizedTransactions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.groups = [];
                if (message.groups && message.groups.length) {
                    object.groups = [];
                    for (var j = 0; j < message.groups.length; ++j)
                        object.groups[j] = $root.m10.sdk.FinalizedTransactions.toObject(message.groups[j], options);
                }
                return object;
            };

            /**
             * Converts this GroupedFinalizedTransactions to JSON.
             * @function toJSON
             * @memberof m10.sdk.GroupedFinalizedTransactions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GroupedFinalizedTransactions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GroupedFinalizedTransactions;
        })();

        sdk.ChainInfo = (function() {

            /**
             * Properties of a ChainInfo.
             * @memberof m10.sdk
             * @interface IChainInfo
             * @property {number|Long|null} [blockHeight] ChainInfo blockHeight
             */

            /**
             * Constructs a new ChainInfo.
             * @memberof m10.sdk
             * @classdesc Represents a ChainInfo.
             * @implements IChainInfo
             * @constructor
             * @param {m10.sdk.IChainInfo=} [properties] Properties to set
             */
            function ChainInfo(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ChainInfo blockHeight.
             * @member {number|Long} blockHeight
             * @memberof m10.sdk.ChainInfo
             * @instance
             */
            ChainInfo.prototype.blockHeight = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Creates a new ChainInfo instance using the specified properties.
             * @function create
             * @memberof m10.sdk.ChainInfo
             * @static
             * @param {m10.sdk.IChainInfo=} [properties] Properties to set
             * @returns {m10.sdk.ChainInfo} ChainInfo instance
             */
            ChainInfo.create = function create(properties) {
                return new ChainInfo(properties);
            };

            /**
             * Encodes the specified ChainInfo message. Does not implicitly {@link m10.sdk.ChainInfo.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.ChainInfo
             * @static
             * @param {m10.sdk.IChainInfo} message ChainInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChainInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.blockHeight != null && Object.hasOwnProperty.call(message, "blockHeight"))
                    writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.blockHeight);
                return writer;
            };

            /**
             * Encodes the specified ChainInfo message, length delimited. Does not implicitly {@link m10.sdk.ChainInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.ChainInfo
             * @static
             * @param {m10.sdk.IChainInfo} message ChainInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ChainInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ChainInfo message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.ChainInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.ChainInfo} ChainInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChainInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.ChainInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.blockHeight = reader.uint64();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ChainInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.ChainInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.ChainInfo} ChainInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ChainInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ChainInfo message.
             * @function verify
             * @memberof m10.sdk.ChainInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ChainInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                    if (!$util.isInteger(message.blockHeight) && !(message.blockHeight && $util.isInteger(message.blockHeight.low) && $util.isInteger(message.blockHeight.high)))
                        return "blockHeight: integer|Long expected";
                return null;
            };

            /**
             * Creates a ChainInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.ChainInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.ChainInfo} ChainInfo
             */
            ChainInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.ChainInfo)
                    return object;
                var message = new $root.m10.sdk.ChainInfo();
                if (object.blockHeight != null)
                    if ($util.Long)
                        (message.blockHeight = $util.Long.fromValue(object.blockHeight)).unsigned = true;
                    else if (typeof object.blockHeight === "string")
                        message.blockHeight = parseInt(object.blockHeight, 10);
                    else if (typeof object.blockHeight === "number")
                        message.blockHeight = object.blockHeight;
                    else if (typeof object.blockHeight === "object")
                        message.blockHeight = new $util.LongBits(object.blockHeight.low >>> 0, object.blockHeight.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a ChainInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.ChainInfo
             * @static
             * @param {m10.sdk.ChainInfo} message ChainInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ChainInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.blockHeight = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.blockHeight = options.longs === String ? "0" : 0;
                if (message.blockHeight != null && message.hasOwnProperty("blockHeight"))
                    if (typeof message.blockHeight === "number")
                        object.blockHeight = options.longs === String ? String(message.blockHeight) : message.blockHeight;
                    else
                        object.blockHeight = options.longs === String ? $util.Long.prototype.toString.call(message.blockHeight) : options.longs === Number ? new $util.LongBits(message.blockHeight.low >>> 0, message.blockHeight.high >>> 0).toNumber(true) : message.blockHeight;
                return object;
            };

            /**
             * Converts this ChainInfo to JSON.
             * @function toJSON
             * @memberof m10.sdk.ChainInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ChainInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ChainInfo;
        })();

        sdk.DocumentOperations = (function() {

            /**
             * Properties of a DocumentOperations.
             * @memberof m10.sdk
             * @interface IDocumentOperations
             * @property {Array.<m10.sdk.IOperation>|null} [operations] DocumentOperations operations
             */

            /**
             * Constructs a new DocumentOperations.
             * @memberof m10.sdk
             * @classdesc Represents a DocumentOperations.
             * @implements IDocumentOperations
             * @constructor
             * @param {m10.sdk.IDocumentOperations=} [properties] Properties to set
             */
            function DocumentOperations(properties) {
                this.operations = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DocumentOperations operations.
             * @member {Array.<m10.sdk.IOperation>} operations
             * @memberof m10.sdk.DocumentOperations
             * @instance
             */
            DocumentOperations.prototype.operations = $util.emptyArray;

            /**
             * Creates a new DocumentOperations instance using the specified properties.
             * @function create
             * @memberof m10.sdk.DocumentOperations
             * @static
             * @param {m10.sdk.IDocumentOperations=} [properties] Properties to set
             * @returns {m10.sdk.DocumentOperations} DocumentOperations instance
             */
            DocumentOperations.create = function create(properties) {
                return new DocumentOperations(properties);
            };

            /**
             * Encodes the specified DocumentOperations message. Does not implicitly {@link m10.sdk.DocumentOperations.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.DocumentOperations
             * @static
             * @param {m10.sdk.IDocumentOperations} message DocumentOperations message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DocumentOperations.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operations != null && message.operations.length)
                    for (var i = 0; i < message.operations.length; ++i)
                        $root.m10.sdk.Operation.encode(message.operations[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified DocumentOperations message, length delimited. Does not implicitly {@link m10.sdk.DocumentOperations.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.DocumentOperations
             * @static
             * @param {m10.sdk.IDocumentOperations} message DocumentOperations message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DocumentOperations.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DocumentOperations message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.DocumentOperations
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.DocumentOperations} DocumentOperations
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DocumentOperations.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.DocumentOperations();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.operations && message.operations.length))
                            message.operations = [];
                        message.operations.push($root.m10.sdk.Operation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DocumentOperations message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.DocumentOperations
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.DocumentOperations} DocumentOperations
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DocumentOperations.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DocumentOperations message.
             * @function verify
             * @memberof m10.sdk.DocumentOperations
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DocumentOperations.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operations != null && message.hasOwnProperty("operations")) {
                    if (!Array.isArray(message.operations))
                        return "operations: array expected";
                    for (var i = 0; i < message.operations.length; ++i) {
                        var error = $root.m10.sdk.Operation.verify(message.operations[i]);
                        if (error)
                            return "operations." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a DocumentOperations message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.DocumentOperations
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.DocumentOperations} DocumentOperations
             */
            DocumentOperations.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.DocumentOperations)
                    return object;
                var message = new $root.m10.sdk.DocumentOperations();
                if (object.operations) {
                    if (!Array.isArray(object.operations))
                        throw TypeError(".m10.sdk.DocumentOperations.operations: array expected");
                    message.operations = [];
                    for (var i = 0; i < object.operations.length; ++i) {
                        if (typeof object.operations[i] !== "object")
                            throw TypeError(".m10.sdk.DocumentOperations.operations: object expected");
                        message.operations[i] = $root.m10.sdk.Operation.fromObject(object.operations[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a DocumentOperations message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.DocumentOperations
             * @static
             * @param {m10.sdk.DocumentOperations} message DocumentOperations
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DocumentOperations.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.operations = [];
                if (message.operations && message.operations.length) {
                    object.operations = [];
                    for (var j = 0; j < message.operations.length; ++j)
                        object.operations[j] = $root.m10.sdk.Operation.toObject(message.operations[j], options);
                }
                return object;
            };

            /**
             * Converts this DocumentOperations to JSON.
             * @function toJSON
             * @memberof m10.sdk.DocumentOperations
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DocumentOperations.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DocumentOperations;
        })();

        sdk.Operation = (function() {

            /**
             * Properties of an Operation.
             * @memberof m10.sdk
             * @interface IOperation
             * @property {m10.sdk.Operation.IInsertDocument|null} [insertDocument] Operation insertDocument
             * @property {m10.sdk.Operation.IUpdateDocument|null} [updateDocument] Operation updateDocument
             * @property {m10.sdk.Operation.IDeleteDocument|null} [deleteDocument] Operation deleteDocument
             * @property {m10.sdk.ICollectionMetadata|null} [insertCollection] Operation insertCollection
             * @property {m10.sdk.Operation.IInsertIndex|null} [insertIndex] Operation insertIndex
             */

            /**
             * Constructs a new Operation.
             * @memberof m10.sdk
             * @classdesc Represents an Operation.
             * @implements IOperation
             * @constructor
             * @param {m10.sdk.IOperation=} [properties] Properties to set
             */
            function Operation(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Operation insertDocument.
             * @member {m10.sdk.Operation.IInsertDocument|null|undefined} insertDocument
             * @memberof m10.sdk.Operation
             * @instance
             */
            Operation.prototype.insertDocument = null;

            /**
             * Operation updateDocument.
             * @member {m10.sdk.Operation.IUpdateDocument|null|undefined} updateDocument
             * @memberof m10.sdk.Operation
             * @instance
             */
            Operation.prototype.updateDocument = null;

            /**
             * Operation deleteDocument.
             * @member {m10.sdk.Operation.IDeleteDocument|null|undefined} deleteDocument
             * @memberof m10.sdk.Operation
             * @instance
             */
            Operation.prototype.deleteDocument = null;

            /**
             * Operation insertCollection.
             * @member {m10.sdk.ICollectionMetadata|null|undefined} insertCollection
             * @memberof m10.sdk.Operation
             * @instance
             */
            Operation.prototype.insertCollection = null;

            /**
             * Operation insertIndex.
             * @member {m10.sdk.Operation.IInsertIndex|null|undefined} insertIndex
             * @memberof m10.sdk.Operation
             * @instance
             */
            Operation.prototype.insertIndex = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Operation operation.
             * @member {"insertDocument"|"updateDocument"|"deleteDocument"|"insertCollection"|"insertIndex"|undefined} operation
             * @memberof m10.sdk.Operation
             * @instance
             */
            Object.defineProperty(Operation.prototype, "operation", {
                get: $util.oneOfGetter($oneOfFields = ["insertDocument", "updateDocument", "deleteDocument", "insertCollection", "insertIndex"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Operation instance using the specified properties.
             * @function create
             * @memberof m10.sdk.Operation
             * @static
             * @param {m10.sdk.IOperation=} [properties] Properties to set
             * @returns {m10.sdk.Operation} Operation instance
             */
            Operation.create = function create(properties) {
                return new Operation(properties);
            };

            /**
             * Encodes the specified Operation message. Does not implicitly {@link m10.sdk.Operation.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.Operation
             * @static
             * @param {m10.sdk.IOperation} message Operation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operation.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.insertDocument != null && Object.hasOwnProperty.call(message, "insertDocument"))
                    $root.m10.sdk.Operation.InsertDocument.encode(message.insertDocument, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.updateDocument != null && Object.hasOwnProperty.call(message, "updateDocument"))
                    $root.m10.sdk.Operation.UpdateDocument.encode(message.updateDocument, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.deleteDocument != null && Object.hasOwnProperty.call(message, "deleteDocument"))
                    $root.m10.sdk.Operation.DeleteDocument.encode(message.deleteDocument, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.insertCollection != null && Object.hasOwnProperty.call(message, "insertCollection"))
                    $root.m10.sdk.CollectionMetadata.encode(message.insertCollection, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.insertIndex != null && Object.hasOwnProperty.call(message, "insertIndex"))
                    $root.m10.sdk.Operation.InsertIndex.encode(message.insertIndex, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Operation message, length delimited. Does not implicitly {@link m10.sdk.Operation.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.Operation
             * @static
             * @param {m10.sdk.IOperation} message Operation message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Operation.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Operation message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.Operation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.Operation} Operation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operation.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.Operation();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.insertDocument = $root.m10.sdk.Operation.InsertDocument.decode(reader, reader.uint32());
                        break;
                    case 2:
                        message.updateDocument = $root.m10.sdk.Operation.UpdateDocument.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.deleteDocument = $root.m10.sdk.Operation.DeleteDocument.decode(reader, reader.uint32());
                        break;
                    case 4:
                        message.insertCollection = $root.m10.sdk.CollectionMetadata.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.insertIndex = $root.m10.sdk.Operation.InsertIndex.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Operation message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.Operation
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.Operation} Operation
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Operation.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Operation message.
             * @function verify
             * @memberof m10.sdk.Operation
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Operation.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.insertDocument != null && message.hasOwnProperty("insertDocument")) {
                    properties.operation = 1;
                    {
                        var error = $root.m10.sdk.Operation.InsertDocument.verify(message.insertDocument);
                        if (error)
                            return "insertDocument." + error;
                    }
                }
                if (message.updateDocument != null && message.hasOwnProperty("updateDocument")) {
                    if (properties.operation === 1)
                        return "operation: multiple values";
                    properties.operation = 1;
                    {
                        var error = $root.m10.sdk.Operation.UpdateDocument.verify(message.updateDocument);
                        if (error)
                            return "updateDocument." + error;
                    }
                }
                if (message.deleteDocument != null && message.hasOwnProperty("deleteDocument")) {
                    if (properties.operation === 1)
                        return "operation: multiple values";
                    properties.operation = 1;
                    {
                        var error = $root.m10.sdk.Operation.DeleteDocument.verify(message.deleteDocument);
                        if (error)
                            return "deleteDocument." + error;
                    }
                }
                if (message.insertCollection != null && message.hasOwnProperty("insertCollection")) {
                    if (properties.operation === 1)
                        return "operation: multiple values";
                    properties.operation = 1;
                    {
                        var error = $root.m10.sdk.CollectionMetadata.verify(message.insertCollection);
                        if (error)
                            return "insertCollection." + error;
                    }
                }
                if (message.insertIndex != null && message.hasOwnProperty("insertIndex")) {
                    if (properties.operation === 1)
                        return "operation: multiple values";
                    properties.operation = 1;
                    {
                        var error = $root.m10.sdk.Operation.InsertIndex.verify(message.insertIndex);
                        if (error)
                            return "insertIndex." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Operation message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.Operation
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.Operation} Operation
             */
            Operation.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.Operation)
                    return object;
                var message = new $root.m10.sdk.Operation();
                if (object.insertDocument != null) {
                    if (typeof object.insertDocument !== "object")
                        throw TypeError(".m10.sdk.Operation.insertDocument: object expected");
                    message.insertDocument = $root.m10.sdk.Operation.InsertDocument.fromObject(object.insertDocument);
                }
                if (object.updateDocument != null) {
                    if (typeof object.updateDocument !== "object")
                        throw TypeError(".m10.sdk.Operation.updateDocument: object expected");
                    message.updateDocument = $root.m10.sdk.Operation.UpdateDocument.fromObject(object.updateDocument);
                }
                if (object.deleteDocument != null) {
                    if (typeof object.deleteDocument !== "object")
                        throw TypeError(".m10.sdk.Operation.deleteDocument: object expected");
                    message.deleteDocument = $root.m10.sdk.Operation.DeleteDocument.fromObject(object.deleteDocument);
                }
                if (object.insertCollection != null) {
                    if (typeof object.insertCollection !== "object")
                        throw TypeError(".m10.sdk.Operation.insertCollection: object expected");
                    message.insertCollection = $root.m10.sdk.CollectionMetadata.fromObject(object.insertCollection);
                }
                if (object.insertIndex != null) {
                    if (typeof object.insertIndex !== "object")
                        throw TypeError(".m10.sdk.Operation.insertIndex: object expected");
                    message.insertIndex = $root.m10.sdk.Operation.InsertIndex.fromObject(object.insertIndex);
                }
                return message;
            };

            /**
             * Creates a plain object from an Operation message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.Operation
             * @static
             * @param {m10.sdk.Operation} message Operation
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Operation.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.insertDocument != null && message.hasOwnProperty("insertDocument")) {
                    object.insertDocument = $root.m10.sdk.Operation.InsertDocument.toObject(message.insertDocument, options);
                    if (options.oneofs)
                        object.operation = "insertDocument";
                }
                if (message.updateDocument != null && message.hasOwnProperty("updateDocument")) {
                    object.updateDocument = $root.m10.sdk.Operation.UpdateDocument.toObject(message.updateDocument, options);
                    if (options.oneofs)
                        object.operation = "updateDocument";
                }
                if (message.deleteDocument != null && message.hasOwnProperty("deleteDocument")) {
                    object.deleteDocument = $root.m10.sdk.Operation.DeleteDocument.toObject(message.deleteDocument, options);
                    if (options.oneofs)
                        object.operation = "deleteDocument";
                }
                if (message.insertCollection != null && message.hasOwnProperty("insertCollection")) {
                    object.insertCollection = $root.m10.sdk.CollectionMetadata.toObject(message.insertCollection, options);
                    if (options.oneofs)
                        object.operation = "insertCollection";
                }
                if (message.insertIndex != null && message.hasOwnProperty("insertIndex")) {
                    object.insertIndex = $root.m10.sdk.Operation.InsertIndex.toObject(message.insertIndex, options);
                    if (options.oneofs)
                        object.operation = "insertIndex";
                }
                return object;
            };

            /**
             * Converts this Operation to JSON.
             * @function toJSON
             * @memberof m10.sdk.Operation
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Operation.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            Operation.InsertDocument = (function() {

                /**
                 * Properties of an InsertDocument.
                 * @memberof m10.sdk.Operation
                 * @interface IInsertDocument
                 * @property {string|null} [collection] InsertDocument collection
                 * @property {Uint8Array|null} [document] InsertDocument document
                 */

                /**
                 * Constructs a new InsertDocument.
                 * @memberof m10.sdk.Operation
                 * @classdesc Represents an InsertDocument.
                 * @implements IInsertDocument
                 * @constructor
                 * @param {m10.sdk.Operation.IInsertDocument=} [properties] Properties to set
                 */
                function InsertDocument(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * InsertDocument collection.
                 * @member {string} collection
                 * @memberof m10.sdk.Operation.InsertDocument
                 * @instance
                 */
                InsertDocument.prototype.collection = "";

                /**
                 * InsertDocument document.
                 * @member {Uint8Array} document
                 * @memberof m10.sdk.Operation.InsertDocument
                 * @instance
                 */
                InsertDocument.prototype.document = $util.newBuffer([]);

                /**
                 * Creates a new InsertDocument instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.Operation.InsertDocument
                 * @static
                 * @param {m10.sdk.Operation.IInsertDocument=} [properties] Properties to set
                 * @returns {m10.sdk.Operation.InsertDocument} InsertDocument instance
                 */
                InsertDocument.create = function create(properties) {
                    return new InsertDocument(properties);
                };

                /**
                 * Encodes the specified InsertDocument message. Does not implicitly {@link m10.sdk.Operation.InsertDocument.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.Operation.InsertDocument
                 * @static
                 * @param {m10.sdk.Operation.IInsertDocument} message InsertDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InsertDocument.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.collection);
                    if (message.document != null && Object.hasOwnProperty.call(message, "document"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.document);
                    return writer;
                };

                /**
                 * Encodes the specified InsertDocument message, length delimited. Does not implicitly {@link m10.sdk.Operation.InsertDocument.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.Operation.InsertDocument
                 * @static
                 * @param {m10.sdk.Operation.IInsertDocument} message InsertDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InsertDocument.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an InsertDocument message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.Operation.InsertDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.Operation.InsertDocument} InsertDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InsertDocument.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.Operation.InsertDocument();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.collection = reader.string();
                            break;
                        case 3:
                            message.document = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an InsertDocument message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.Operation.InsertDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.Operation.InsertDocument} InsertDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InsertDocument.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an InsertDocument message.
                 * @function verify
                 * @memberof m10.sdk.Operation.InsertDocument
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InsertDocument.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.collection != null && message.hasOwnProperty("collection"))
                        if (!$util.isString(message.collection))
                            return "collection: string expected";
                    if (message.document != null && message.hasOwnProperty("document"))
                        if (!(message.document && typeof message.document.length === "number" || $util.isString(message.document)))
                            return "document: buffer expected";
                    return null;
                };

                /**
                 * Creates an InsertDocument message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.Operation.InsertDocument
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.Operation.InsertDocument} InsertDocument
                 */
                InsertDocument.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.Operation.InsertDocument)
                        return object;
                    var message = new $root.m10.sdk.Operation.InsertDocument();
                    if (object.collection != null)
                        message.collection = String(object.collection);
                    if (object.document != null)
                        if (typeof object.document === "string")
                            $util.base64.decode(object.document, message.document = $util.newBuffer($util.base64.length(object.document)), 0);
                        else if (object.document.length)
                            message.document = object.document;
                    return message;
                };

                /**
                 * Creates a plain object from an InsertDocument message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.Operation.InsertDocument
                 * @static
                 * @param {m10.sdk.Operation.InsertDocument} message InsertDocument
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InsertDocument.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.collection = "";
                        if (options.bytes === String)
                            object.document = "";
                        else {
                            object.document = [];
                            if (options.bytes !== Array)
                                object.document = $util.newBuffer(object.document);
                        }
                    }
                    if (message.collection != null && message.hasOwnProperty("collection"))
                        object.collection = message.collection;
                    if (message.document != null && message.hasOwnProperty("document"))
                        object.document = options.bytes === String ? $util.base64.encode(message.document, 0, message.document.length) : options.bytes === Array ? Array.prototype.slice.call(message.document) : message.document;
                    return object;
                };

                /**
                 * Converts this InsertDocument to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.Operation.InsertDocument
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InsertDocument.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InsertDocument;
            })();

            Operation.UpdateDocument = (function() {

                /**
                 * Properties of an UpdateDocument.
                 * @memberof m10.sdk.Operation
                 * @interface IUpdateDocument
                 * @property {string|null} [collection] UpdateDocument collection
                 * @property {m10.sdk.IValue|null} [primaryKey] UpdateDocument primaryKey
                 * @property {Uint8Array|null} [document] UpdateDocument document
                 * @property {google.protobuf.IFieldMask|null} [fieldMask] UpdateDocument fieldMask
                 * @property {boolean|null} [mergeRepeated] UpdateDocument mergeRepeated
                 */

                /**
                 * Constructs a new UpdateDocument.
                 * @memberof m10.sdk.Operation
                 * @classdesc Represents an UpdateDocument.
                 * @implements IUpdateDocument
                 * @constructor
                 * @param {m10.sdk.Operation.IUpdateDocument=} [properties] Properties to set
                 */
                function UpdateDocument(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateDocument collection.
                 * @member {string} collection
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @instance
                 */
                UpdateDocument.prototype.collection = "";

                /**
                 * UpdateDocument primaryKey.
                 * @member {m10.sdk.IValue|null|undefined} primaryKey
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @instance
                 */
                UpdateDocument.prototype.primaryKey = null;

                /**
                 * UpdateDocument document.
                 * @member {Uint8Array} document
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @instance
                 */
                UpdateDocument.prototype.document = $util.newBuffer([]);

                /**
                 * UpdateDocument fieldMask.
                 * @member {google.protobuf.IFieldMask|null|undefined} fieldMask
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @instance
                 */
                UpdateDocument.prototype.fieldMask = null;

                /**
                 * UpdateDocument mergeRepeated.
                 * @member {boolean} mergeRepeated
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @instance
                 */
                UpdateDocument.prototype.mergeRepeated = false;

                /**
                 * Creates a new UpdateDocument instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @static
                 * @param {m10.sdk.Operation.IUpdateDocument=} [properties] Properties to set
                 * @returns {m10.sdk.Operation.UpdateDocument} UpdateDocument instance
                 */
                UpdateDocument.create = function create(properties) {
                    return new UpdateDocument(properties);
                };

                /**
                 * Encodes the specified UpdateDocument message. Does not implicitly {@link m10.sdk.Operation.UpdateDocument.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @static
                 * @param {m10.sdk.Operation.IUpdateDocument} message UpdateDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateDocument.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.collection);
                    if (message.primaryKey != null && Object.hasOwnProperty.call(message, "primaryKey"))
                        $root.m10.sdk.Value.encode(message.primaryKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.document != null && Object.hasOwnProperty.call(message, "document"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.document);
                    if (message.fieldMask != null && Object.hasOwnProperty.call(message, "fieldMask"))
                        $root.google.protobuf.FieldMask.encode(message.fieldMask, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.mergeRepeated != null && Object.hasOwnProperty.call(message, "mergeRepeated"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.mergeRepeated);
                    return writer;
                };

                /**
                 * Encodes the specified UpdateDocument message, length delimited. Does not implicitly {@link m10.sdk.Operation.UpdateDocument.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @static
                 * @param {m10.sdk.Operation.IUpdateDocument} message UpdateDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                UpdateDocument.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an UpdateDocument message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.Operation.UpdateDocument} UpdateDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateDocument.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.Operation.UpdateDocument();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.collection = reader.string();
                            break;
                        case 2:
                            message.primaryKey = $root.m10.sdk.Value.decode(reader, reader.uint32());
                            break;
                        case 3:
                            message.document = reader.bytes();
                            break;
                        case 4:
                            message.fieldMask = $root.google.protobuf.FieldMask.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.mergeRepeated = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an UpdateDocument message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.Operation.UpdateDocument} UpdateDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                UpdateDocument.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an UpdateDocument message.
                 * @function verify
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateDocument.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.collection != null && message.hasOwnProperty("collection"))
                        if (!$util.isString(message.collection))
                            return "collection: string expected";
                    if (message.primaryKey != null && message.hasOwnProperty("primaryKey")) {
                        var error = $root.m10.sdk.Value.verify(message.primaryKey);
                        if (error)
                            return "primaryKey." + error;
                    }
                    if (message.document != null && message.hasOwnProperty("document"))
                        if (!(message.document && typeof message.document.length === "number" || $util.isString(message.document)))
                            return "document: buffer expected";
                    if (message.fieldMask != null && message.hasOwnProperty("fieldMask")) {
                        var error = $root.google.protobuf.FieldMask.verify(message.fieldMask);
                        if (error)
                            return "fieldMask." + error;
                    }
                    if (message.mergeRepeated != null && message.hasOwnProperty("mergeRepeated"))
                        if (typeof message.mergeRepeated !== "boolean")
                            return "mergeRepeated: boolean expected";
                    return null;
                };

                /**
                 * Creates an UpdateDocument message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.Operation.UpdateDocument} UpdateDocument
                 */
                UpdateDocument.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.Operation.UpdateDocument)
                        return object;
                    var message = new $root.m10.sdk.Operation.UpdateDocument();
                    if (object.collection != null)
                        message.collection = String(object.collection);
                    if (object.primaryKey != null) {
                        if (typeof object.primaryKey !== "object")
                            throw TypeError(".m10.sdk.Operation.UpdateDocument.primaryKey: object expected");
                        message.primaryKey = $root.m10.sdk.Value.fromObject(object.primaryKey);
                    }
                    if (object.document != null)
                        if (typeof object.document === "string")
                            $util.base64.decode(object.document, message.document = $util.newBuffer($util.base64.length(object.document)), 0);
                        else if (object.document.length)
                            message.document = object.document;
                    if (object.fieldMask != null) {
                        if (typeof object.fieldMask !== "object")
                            throw TypeError(".m10.sdk.Operation.UpdateDocument.fieldMask: object expected");
                        message.fieldMask = $root.google.protobuf.FieldMask.fromObject(object.fieldMask);
                    }
                    if (object.mergeRepeated != null)
                        message.mergeRepeated = Boolean(object.mergeRepeated);
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateDocument message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @static
                 * @param {m10.sdk.Operation.UpdateDocument} message UpdateDocument
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateDocument.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.collection = "";
                        object.primaryKey = null;
                        if (options.bytes === String)
                            object.document = "";
                        else {
                            object.document = [];
                            if (options.bytes !== Array)
                                object.document = $util.newBuffer(object.document);
                        }
                        object.fieldMask = null;
                        object.mergeRepeated = false;
                    }
                    if (message.collection != null && message.hasOwnProperty("collection"))
                        object.collection = message.collection;
                    if (message.primaryKey != null && message.hasOwnProperty("primaryKey"))
                        object.primaryKey = $root.m10.sdk.Value.toObject(message.primaryKey, options);
                    if (message.document != null && message.hasOwnProperty("document"))
                        object.document = options.bytes === String ? $util.base64.encode(message.document, 0, message.document.length) : options.bytes === Array ? Array.prototype.slice.call(message.document) : message.document;
                    if (message.fieldMask != null && message.hasOwnProperty("fieldMask"))
                        object.fieldMask = $root.google.protobuf.FieldMask.toObject(message.fieldMask, options);
                    if (message.mergeRepeated != null && message.hasOwnProperty("mergeRepeated"))
                        object.mergeRepeated = message.mergeRepeated;
                    return object;
                };

                /**
                 * Converts this UpdateDocument to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.Operation.UpdateDocument
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateDocument.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateDocument;
            })();

            Operation.DeleteDocument = (function() {

                /**
                 * Properties of a DeleteDocument.
                 * @memberof m10.sdk.Operation
                 * @interface IDeleteDocument
                 * @property {string|null} [collection] DeleteDocument collection
                 * @property {m10.sdk.IValue|null} [primaryKey] DeleteDocument primaryKey
                 */

                /**
                 * Constructs a new DeleteDocument.
                 * @memberof m10.sdk.Operation
                 * @classdesc Represents a DeleteDocument.
                 * @implements IDeleteDocument
                 * @constructor
                 * @param {m10.sdk.Operation.IDeleteDocument=} [properties] Properties to set
                 */
                function DeleteDocument(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteDocument collection.
                 * @member {string} collection
                 * @memberof m10.sdk.Operation.DeleteDocument
                 * @instance
                 */
                DeleteDocument.prototype.collection = "";

                /**
                 * DeleteDocument primaryKey.
                 * @member {m10.sdk.IValue|null|undefined} primaryKey
                 * @memberof m10.sdk.Operation.DeleteDocument
                 * @instance
                 */
                DeleteDocument.prototype.primaryKey = null;

                /**
                 * Creates a new DeleteDocument instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.Operation.DeleteDocument
                 * @static
                 * @param {m10.sdk.Operation.IDeleteDocument=} [properties] Properties to set
                 * @returns {m10.sdk.Operation.DeleteDocument} DeleteDocument instance
                 */
                DeleteDocument.create = function create(properties) {
                    return new DeleteDocument(properties);
                };

                /**
                 * Encodes the specified DeleteDocument message. Does not implicitly {@link m10.sdk.Operation.DeleteDocument.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.Operation.DeleteDocument
                 * @static
                 * @param {m10.sdk.Operation.IDeleteDocument} message DeleteDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteDocument.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.collection);
                    if (message.primaryKey != null && Object.hasOwnProperty.call(message, "primaryKey"))
                        $root.m10.sdk.Value.encode(message.primaryKey, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified DeleteDocument message, length delimited. Does not implicitly {@link m10.sdk.Operation.DeleteDocument.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.Operation.DeleteDocument
                 * @static
                 * @param {m10.sdk.Operation.IDeleteDocument} message DeleteDocument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                DeleteDocument.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a DeleteDocument message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.Operation.DeleteDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.Operation.DeleteDocument} DeleteDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteDocument.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.Operation.DeleteDocument();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.collection = reader.string();
                            break;
                        case 2:
                            message.primaryKey = $root.m10.sdk.Value.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a DeleteDocument message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.Operation.DeleteDocument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.Operation.DeleteDocument} DeleteDocument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                DeleteDocument.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a DeleteDocument message.
                 * @function verify
                 * @memberof m10.sdk.Operation.DeleteDocument
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteDocument.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.collection != null && message.hasOwnProperty("collection"))
                        if (!$util.isString(message.collection))
                            return "collection: string expected";
                    if (message.primaryKey != null && message.hasOwnProperty("primaryKey")) {
                        var error = $root.m10.sdk.Value.verify(message.primaryKey);
                        if (error)
                            return "primaryKey." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DeleteDocument message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.Operation.DeleteDocument
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.Operation.DeleteDocument} DeleteDocument
                 */
                DeleteDocument.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.Operation.DeleteDocument)
                        return object;
                    var message = new $root.m10.sdk.Operation.DeleteDocument();
                    if (object.collection != null)
                        message.collection = String(object.collection);
                    if (object.primaryKey != null) {
                        if (typeof object.primaryKey !== "object")
                            throw TypeError(".m10.sdk.Operation.DeleteDocument.primaryKey: object expected");
                        message.primaryKey = $root.m10.sdk.Value.fromObject(object.primaryKey);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteDocument message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.Operation.DeleteDocument
                 * @static
                 * @param {m10.sdk.Operation.DeleteDocument} message DeleteDocument
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteDocument.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.collection = "";
                        object.primaryKey = null;
                    }
                    if (message.collection != null && message.hasOwnProperty("collection"))
                        object.collection = message.collection;
                    if (message.primaryKey != null && message.hasOwnProperty("primaryKey"))
                        object.primaryKey = $root.m10.sdk.Value.toObject(message.primaryKey, options);
                    return object;
                };

                /**
                 * Converts this DeleteDocument to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.Operation.DeleteDocument
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteDocument.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteDocument;
            })();

            Operation.InsertIndex = (function() {

                /**
                 * Properties of an InsertIndex.
                 * @memberof m10.sdk.Operation
                 * @interface IInsertIndex
                 * @property {string|null} [collection] InsertIndex collection
                 * @property {string|null} [path] InsertIndex path
                 */

                /**
                 * Constructs a new InsertIndex.
                 * @memberof m10.sdk.Operation
                 * @classdesc Represents an InsertIndex.
                 * @implements IInsertIndex
                 * @constructor
                 * @param {m10.sdk.Operation.IInsertIndex=} [properties] Properties to set
                 */
                function InsertIndex(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * InsertIndex collection.
                 * @member {string} collection
                 * @memberof m10.sdk.Operation.InsertIndex
                 * @instance
                 */
                InsertIndex.prototype.collection = "";

                /**
                 * InsertIndex path.
                 * @member {string} path
                 * @memberof m10.sdk.Operation.InsertIndex
                 * @instance
                 */
                InsertIndex.prototype.path = "";

                /**
                 * Creates a new InsertIndex instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.Operation.InsertIndex
                 * @static
                 * @param {m10.sdk.Operation.IInsertIndex=} [properties] Properties to set
                 * @returns {m10.sdk.Operation.InsertIndex} InsertIndex instance
                 */
                InsertIndex.create = function create(properties) {
                    return new InsertIndex(properties);
                };

                /**
                 * Encodes the specified InsertIndex message. Does not implicitly {@link m10.sdk.Operation.InsertIndex.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.Operation.InsertIndex
                 * @static
                 * @param {m10.sdk.Operation.IInsertIndex} message InsertIndex message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InsertIndex.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.collection);
                    if (message.path != null && Object.hasOwnProperty.call(message, "path"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.path);
                    return writer;
                };

                /**
                 * Encodes the specified InsertIndex message, length delimited. Does not implicitly {@link m10.sdk.Operation.InsertIndex.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.Operation.InsertIndex
                 * @static
                 * @param {m10.sdk.Operation.IInsertIndex} message InsertIndex message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InsertIndex.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an InsertIndex message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.Operation.InsertIndex
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.Operation.InsertIndex} InsertIndex
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InsertIndex.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.Operation.InsertIndex();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.collection = reader.string();
                            break;
                        case 2:
                            message.path = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an InsertIndex message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.Operation.InsertIndex
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.Operation.InsertIndex} InsertIndex
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InsertIndex.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an InsertIndex message.
                 * @function verify
                 * @memberof m10.sdk.Operation.InsertIndex
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InsertIndex.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.collection != null && message.hasOwnProperty("collection"))
                        if (!$util.isString(message.collection))
                            return "collection: string expected";
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    return null;
                };

                /**
                 * Creates an InsertIndex message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.Operation.InsertIndex
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.Operation.InsertIndex} InsertIndex
                 */
                InsertIndex.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.Operation.InsertIndex)
                        return object;
                    var message = new $root.m10.sdk.Operation.InsertIndex();
                    if (object.collection != null)
                        message.collection = String(object.collection);
                    if (object.path != null)
                        message.path = String(object.path);
                    return message;
                };

                /**
                 * Creates a plain object from an InsertIndex message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.Operation.InsertIndex
                 * @static
                 * @param {m10.sdk.Operation.InsertIndex} message InsertIndex
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InsertIndex.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.collection = "";
                        object.path = "";
                    }
                    if (message.collection != null && message.hasOwnProperty("collection"))
                        object.collection = message.collection;
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    return object;
                };

                /**
                 * Converts this InsertIndex to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.Operation.InsertIndex
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InsertIndex.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InsertIndex;
            })();

            return Operation;
        })();

        sdk.CollectionMetadata = (function() {

            /**
             * Properties of a CollectionMetadata.
             * @memberof m10.sdk
             * @interface ICollectionMetadata
             * @property {string|null} [name] CollectionMetadata name
             * @property {string|null} [descriptorName] CollectionMetadata descriptorName
             * @property {google.protobuf.IFileDescriptorSet|null} [fileDescriptorSet] CollectionMetadata fileDescriptorSet
             * @property {Array.<m10.sdk.IIndexMetadata>|null} [indexMetadata] CollectionMetadata indexMetadata
             * @property {string|null} [primaryKeyPath] CollectionMetadata primaryKeyPath
             */

            /**
             * Constructs a new CollectionMetadata.
             * @memberof m10.sdk
             * @classdesc Represents a CollectionMetadata.
             * @implements ICollectionMetadata
             * @constructor
             * @param {m10.sdk.ICollectionMetadata=} [properties] Properties to set
             */
            function CollectionMetadata(properties) {
                this.indexMetadata = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CollectionMetadata name.
             * @member {string} name
             * @memberof m10.sdk.CollectionMetadata
             * @instance
             */
            CollectionMetadata.prototype.name = "";

            /**
             * CollectionMetadata descriptorName.
             * @member {string} descriptorName
             * @memberof m10.sdk.CollectionMetadata
             * @instance
             */
            CollectionMetadata.prototype.descriptorName = "";

            /**
             * CollectionMetadata fileDescriptorSet.
             * @member {google.protobuf.IFileDescriptorSet|null|undefined} fileDescriptorSet
             * @memberof m10.sdk.CollectionMetadata
             * @instance
             */
            CollectionMetadata.prototype.fileDescriptorSet = null;

            /**
             * CollectionMetadata indexMetadata.
             * @member {Array.<m10.sdk.IIndexMetadata>} indexMetadata
             * @memberof m10.sdk.CollectionMetadata
             * @instance
             */
            CollectionMetadata.prototype.indexMetadata = $util.emptyArray;

            /**
             * CollectionMetadata primaryKeyPath.
             * @member {string} primaryKeyPath
             * @memberof m10.sdk.CollectionMetadata
             * @instance
             */
            CollectionMetadata.prototype.primaryKeyPath = "";

            /**
             * Creates a new CollectionMetadata instance using the specified properties.
             * @function create
             * @memberof m10.sdk.CollectionMetadata
             * @static
             * @param {m10.sdk.ICollectionMetadata=} [properties] Properties to set
             * @returns {m10.sdk.CollectionMetadata} CollectionMetadata instance
             */
            CollectionMetadata.create = function create(properties) {
                return new CollectionMetadata(properties);
            };

            /**
             * Encodes the specified CollectionMetadata message. Does not implicitly {@link m10.sdk.CollectionMetadata.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.CollectionMetadata
             * @static
             * @param {m10.sdk.ICollectionMetadata} message CollectionMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.descriptorName != null && Object.hasOwnProperty.call(message, "descriptorName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.descriptorName);
                if (message.fileDescriptorSet != null && Object.hasOwnProperty.call(message, "fileDescriptorSet"))
                    $root.google.protobuf.FileDescriptorSet.encode(message.fileDescriptorSet, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.indexMetadata != null && message.indexMetadata.length)
                    for (var i = 0; i < message.indexMetadata.length; ++i)
                        $root.m10.sdk.IndexMetadata.encode(message.indexMetadata[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.primaryKeyPath != null && Object.hasOwnProperty.call(message, "primaryKeyPath"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.primaryKeyPath);
                return writer;
            };

            /**
             * Encodes the specified CollectionMetadata message, length delimited. Does not implicitly {@link m10.sdk.CollectionMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.CollectionMetadata
             * @static
             * @param {m10.sdk.ICollectionMetadata} message CollectionMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CollectionMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CollectionMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.CollectionMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.CollectionMetadata} CollectionMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.CollectionMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.descriptorName = reader.string();
                        break;
                    case 3:
                        message.fileDescriptorSet = $root.google.protobuf.FileDescriptorSet.decode(reader, reader.uint32());
                        break;
                    case 4:
                        if (!(message.indexMetadata && message.indexMetadata.length))
                            message.indexMetadata = [];
                        message.indexMetadata.push($root.m10.sdk.IndexMetadata.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        message.primaryKeyPath = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CollectionMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.CollectionMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.CollectionMetadata} CollectionMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CollectionMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CollectionMetadata message.
             * @function verify
             * @memberof m10.sdk.CollectionMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CollectionMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.descriptorName != null && message.hasOwnProperty("descriptorName"))
                    if (!$util.isString(message.descriptorName))
                        return "descriptorName: string expected";
                if (message.fileDescriptorSet != null && message.hasOwnProperty("fileDescriptorSet")) {
                    var error = $root.google.protobuf.FileDescriptorSet.verify(message.fileDescriptorSet);
                    if (error)
                        return "fileDescriptorSet." + error;
                }
                if (message.indexMetadata != null && message.hasOwnProperty("indexMetadata")) {
                    if (!Array.isArray(message.indexMetadata))
                        return "indexMetadata: array expected";
                    for (var i = 0; i < message.indexMetadata.length; ++i) {
                        var error = $root.m10.sdk.IndexMetadata.verify(message.indexMetadata[i]);
                        if (error)
                            return "indexMetadata." + error;
                    }
                }
                if (message.primaryKeyPath != null && message.hasOwnProperty("primaryKeyPath"))
                    if (!$util.isString(message.primaryKeyPath))
                        return "primaryKeyPath: string expected";
                return null;
            };

            /**
             * Creates a CollectionMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.CollectionMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.CollectionMetadata} CollectionMetadata
             */
            CollectionMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.CollectionMetadata)
                    return object;
                var message = new $root.m10.sdk.CollectionMetadata();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.descriptorName != null)
                    message.descriptorName = String(object.descriptorName);
                if (object.fileDescriptorSet != null) {
                    if (typeof object.fileDescriptorSet !== "object")
                        throw TypeError(".m10.sdk.CollectionMetadata.fileDescriptorSet: object expected");
                    message.fileDescriptorSet = $root.google.protobuf.FileDescriptorSet.fromObject(object.fileDescriptorSet);
                }
                if (object.indexMetadata) {
                    if (!Array.isArray(object.indexMetadata))
                        throw TypeError(".m10.sdk.CollectionMetadata.indexMetadata: array expected");
                    message.indexMetadata = [];
                    for (var i = 0; i < object.indexMetadata.length; ++i) {
                        if (typeof object.indexMetadata[i] !== "object")
                            throw TypeError(".m10.sdk.CollectionMetadata.indexMetadata: object expected");
                        message.indexMetadata[i] = $root.m10.sdk.IndexMetadata.fromObject(object.indexMetadata[i]);
                    }
                }
                if (object.primaryKeyPath != null)
                    message.primaryKeyPath = String(object.primaryKeyPath);
                return message;
            };

            /**
             * Creates a plain object from a CollectionMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.CollectionMetadata
             * @static
             * @param {m10.sdk.CollectionMetadata} message CollectionMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CollectionMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.indexMetadata = [];
                if (options.defaults) {
                    object.name = "";
                    object.descriptorName = "";
                    object.fileDescriptorSet = null;
                    object.primaryKeyPath = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.descriptorName != null && message.hasOwnProperty("descriptorName"))
                    object.descriptorName = message.descriptorName;
                if (message.fileDescriptorSet != null && message.hasOwnProperty("fileDescriptorSet"))
                    object.fileDescriptorSet = $root.google.protobuf.FileDescriptorSet.toObject(message.fileDescriptorSet, options);
                if (message.indexMetadata && message.indexMetadata.length) {
                    object.indexMetadata = [];
                    for (var j = 0; j < message.indexMetadata.length; ++j)
                        object.indexMetadata[j] = $root.m10.sdk.IndexMetadata.toObject(message.indexMetadata[j], options);
                }
                if (message.primaryKeyPath != null && message.hasOwnProperty("primaryKeyPath"))
                    object.primaryKeyPath = message.primaryKeyPath;
                return object;
            };

            /**
             * Converts this CollectionMetadata to JSON.
             * @function toJSON
             * @memberof m10.sdk.CollectionMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CollectionMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CollectionMetadata;
        })();

        sdk.IndexMetadata = (function() {

            /**
             * Properties of an IndexMetadata.
             * @memberof m10.sdk
             * @interface IIndexMetadata
             * @property {Array.<string>|null} [path] IndexMetadata path
             */

            /**
             * Constructs a new IndexMetadata.
             * @memberof m10.sdk
             * @classdesc Represents an IndexMetadata.
             * @implements IIndexMetadata
             * @constructor
             * @param {m10.sdk.IIndexMetadata=} [properties] Properties to set
             */
            function IndexMetadata(properties) {
                this.path = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * IndexMetadata path.
             * @member {Array.<string>} path
             * @memberof m10.sdk.IndexMetadata
             * @instance
             */
            IndexMetadata.prototype.path = $util.emptyArray;

            /**
             * Creates a new IndexMetadata instance using the specified properties.
             * @function create
             * @memberof m10.sdk.IndexMetadata
             * @static
             * @param {m10.sdk.IIndexMetadata=} [properties] Properties to set
             * @returns {m10.sdk.IndexMetadata} IndexMetadata instance
             */
            IndexMetadata.create = function create(properties) {
                return new IndexMetadata(properties);
            };

            /**
             * Encodes the specified IndexMetadata message. Does not implicitly {@link m10.sdk.IndexMetadata.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.IndexMetadata
             * @static
             * @param {m10.sdk.IIndexMetadata} message IndexMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexMetadata.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.path != null && message.path.length)
                    for (var i = 0; i < message.path.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.path[i]);
                return writer;
            };

            /**
             * Encodes the specified IndexMetadata message, length delimited. Does not implicitly {@link m10.sdk.IndexMetadata.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.IndexMetadata
             * @static
             * @param {m10.sdk.IIndexMetadata} message IndexMetadata message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            IndexMetadata.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an IndexMetadata message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.IndexMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.IndexMetadata} IndexMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexMetadata.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.IndexMetadata();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.path && message.path.length))
                            message.path = [];
                        message.path.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an IndexMetadata message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.IndexMetadata
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.IndexMetadata} IndexMetadata
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            IndexMetadata.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an IndexMetadata message.
             * @function verify
             * @memberof m10.sdk.IndexMetadata
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            IndexMetadata.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.path != null && message.hasOwnProperty("path")) {
                    if (!Array.isArray(message.path))
                        return "path: array expected";
                    for (var i = 0; i < message.path.length; ++i)
                        if (!$util.isString(message.path[i]))
                            return "path: string[] expected";
                }
                return null;
            };

            /**
             * Creates an IndexMetadata message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.IndexMetadata
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.IndexMetadata} IndexMetadata
             */
            IndexMetadata.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.IndexMetadata)
                    return object;
                var message = new $root.m10.sdk.IndexMetadata();
                if (object.path) {
                    if (!Array.isArray(object.path))
                        throw TypeError(".m10.sdk.IndexMetadata.path: array expected");
                    message.path = [];
                    for (var i = 0; i < object.path.length; ++i)
                        message.path[i] = String(object.path[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from an IndexMetadata message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.IndexMetadata
             * @static
             * @param {m10.sdk.IndexMetadata} message IndexMetadata
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            IndexMetadata.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.path = [];
                if (message.path && message.path.length) {
                    object.path = [];
                    for (var j = 0; j < message.path.length; ++j)
                        object.path[j] = message.path[j];
                }
                return object;
            };

            /**
             * Converts this IndexMetadata to JSON.
             * @function toJSON
             * @memberof m10.sdk.IndexMetadata
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            IndexMetadata.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return IndexMetadata;
        })();

        sdk.Exp = (function() {

            /**
             * Properties of an Exp.
             * @memberof m10.sdk
             * @interface IExp
             * @property {string|null} [exp] Exp exp
             * @property {Object.<string,m10.sdk.IValue>|null} [vars] Exp vars
             */

            /**
             * Constructs a new Exp.
             * @memberof m10.sdk
             * @classdesc Represents an Exp.
             * @implements IExp
             * @constructor
             * @param {m10.sdk.IExp=} [properties] Properties to set
             */
            function Exp(properties) {
                this.vars = {};
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Exp exp.
             * @member {string} exp
             * @memberof m10.sdk.Exp
             * @instance
             */
            Exp.prototype.exp = "";

            /**
             * Exp vars.
             * @member {Object.<string,m10.sdk.IValue>} vars
             * @memberof m10.sdk.Exp
             * @instance
             */
            Exp.prototype.vars = $util.emptyObject;

            /**
             * Creates a new Exp instance using the specified properties.
             * @function create
             * @memberof m10.sdk.Exp
             * @static
             * @param {m10.sdk.IExp=} [properties] Properties to set
             * @returns {m10.sdk.Exp} Exp instance
             */
            Exp.create = function create(properties) {
                return new Exp(properties);
            };

            /**
             * Encodes the specified Exp message. Does not implicitly {@link m10.sdk.Exp.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.Exp
             * @static
             * @param {m10.sdk.IExp} message Exp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Exp.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.exp != null && Object.hasOwnProperty.call(message, "exp"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.exp);
                if (message.vars != null && Object.hasOwnProperty.call(message, "vars"))
                    for (var keys = Object.keys(message.vars), i = 0; i < keys.length; ++i) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork().uint32(/* id 1, wireType 2 =*/10).string(keys[i]);
                        $root.m10.sdk.Value.encode(message.vars[keys[i]], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim().ldelim();
                    }
                return writer;
            };

            /**
             * Encodes the specified Exp message, length delimited. Does not implicitly {@link m10.sdk.Exp.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.Exp
             * @static
             * @param {m10.sdk.IExp} message Exp message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Exp.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Exp message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.Exp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.Exp} Exp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Exp.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.Exp(), key, value;
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.exp = reader.string();
                        break;
                    case 2:
                        if (message.vars === $util.emptyObject)
                            message.vars = {};
                        var end2 = reader.uint32() + reader.pos;
                        key = "";
                        value = null;
                        while (reader.pos < end2) {
                            var tag2 = reader.uint32();
                            switch (tag2 >>> 3) {
                            case 1:
                                key = reader.string();
                                break;
                            case 2:
                                value = $root.m10.sdk.Value.decode(reader, reader.uint32());
                                break;
                            default:
                                reader.skipType(tag2 & 7);
                                break;
                            }
                        }
                        message.vars[key] = value;
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Exp message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.Exp
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.Exp} Exp
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Exp.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Exp message.
             * @function verify
             * @memberof m10.sdk.Exp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Exp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.exp != null && message.hasOwnProperty("exp"))
                    if (!$util.isString(message.exp))
                        return "exp: string expected";
                if (message.vars != null && message.hasOwnProperty("vars")) {
                    if (!$util.isObject(message.vars))
                        return "vars: object expected";
                    var key = Object.keys(message.vars);
                    for (var i = 0; i < key.length; ++i) {
                        var error = $root.m10.sdk.Value.verify(message.vars[key[i]]);
                        if (error)
                            return "vars." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an Exp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.Exp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.Exp} Exp
             */
            Exp.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.Exp)
                    return object;
                var message = new $root.m10.sdk.Exp();
                if (object.exp != null)
                    message.exp = String(object.exp);
                if (object.vars) {
                    if (typeof object.vars !== "object")
                        throw TypeError(".m10.sdk.Exp.vars: object expected");
                    message.vars = {};
                    for (var keys = Object.keys(object.vars), i = 0; i < keys.length; ++i) {
                        if (typeof object.vars[keys[i]] !== "object")
                            throw TypeError(".m10.sdk.Exp.vars: object expected");
                        message.vars[keys[i]] = $root.m10.sdk.Value.fromObject(object.vars[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an Exp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.Exp
             * @static
             * @param {m10.sdk.Exp} message Exp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Exp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.objects || options.defaults)
                    object.vars = {};
                if (options.defaults)
                    object.exp = "";
                if (message.exp != null && message.hasOwnProperty("exp"))
                    object.exp = message.exp;
                var keys2;
                if (message.vars && (keys2 = Object.keys(message.vars)).length) {
                    object.vars = {};
                    for (var j = 0; j < keys2.length; ++j)
                        object.vars[keys2[j]] = $root.m10.sdk.Value.toObject(message.vars[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this Exp to JSON.
             * @function toJSON
             * @memberof m10.sdk.Exp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Exp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Exp;
        })();

        sdk.Value = (function() {

            /**
             * Properties of a Value.
             * @memberof m10.sdk
             * @interface IValue
             * @property {string|null} [stringValue] Value stringValue
             * @property {number|null} [int8Value] Value int8Value
             * @property {number|null} [int16Value] Value int16Value
             * @property {number|null} [int32Value] Value int32Value
             * @property {number|Long|null} [int64Value] Value int64Value
             * @property {number|null} [uint8Value] Value uint8Value
             * @property {number|null} [uint16Value] Value uint16Value
             * @property {number|null} [uint32Value] Value uint32Value
             * @property {number|Long|null} [uint64Value] Value uint64Value
             * @property {number|null} [doubleValue] Value doubleValue
             * @property {number|null} [floatValue] Value floatValue
             * @property {boolean|null} [boolValue] Value boolValue
             * @property {Uint8Array|null} [bytesValue] Value bytesValue
             */

            /**
             * Constructs a new Value.
             * @memberof m10.sdk
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {m10.sdk.IValue=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Value stringValue.
             * @member {string|null|undefined} stringValue
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.stringValue = null;

            /**
             * Value int8Value.
             * @member {number|null|undefined} int8Value
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.int8Value = null;

            /**
             * Value int16Value.
             * @member {number|null|undefined} int16Value
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.int16Value = null;

            /**
             * Value int32Value.
             * @member {number|null|undefined} int32Value
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.int32Value = null;

            /**
             * Value int64Value.
             * @member {number|Long|null|undefined} int64Value
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.int64Value = null;

            /**
             * Value uint8Value.
             * @member {number|null|undefined} uint8Value
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.uint8Value = null;

            /**
             * Value uint16Value.
             * @member {number|null|undefined} uint16Value
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.uint16Value = null;

            /**
             * Value uint32Value.
             * @member {number|null|undefined} uint32Value
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.uint32Value = null;

            /**
             * Value uint64Value.
             * @member {number|Long|null|undefined} uint64Value
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.uint64Value = null;

            /**
             * Value doubleValue.
             * @member {number|null|undefined} doubleValue
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.doubleValue = null;

            /**
             * Value floatValue.
             * @member {number|null|undefined} floatValue
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.floatValue = null;

            /**
             * Value boolValue.
             * @member {boolean|null|undefined} boolValue
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.boolValue = null;

            /**
             * Value bytesValue.
             * @member {Uint8Array|null|undefined} bytesValue
             * @memberof m10.sdk.Value
             * @instance
             */
            Value.prototype.bytesValue = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * Value value.
             * @member {"stringValue"|"int8Value"|"int16Value"|"int32Value"|"int64Value"|"uint8Value"|"uint16Value"|"uint32Value"|"uint64Value"|"doubleValue"|"floatValue"|"boolValue"|"bytesValue"|undefined} value
             * @memberof m10.sdk.Value
             * @instance
             */
            Object.defineProperty(Value.prototype, "value", {
                get: $util.oneOfGetter($oneOfFields = ["stringValue", "int8Value", "int16Value", "int32Value", "int64Value", "uint8Value", "uint16Value", "uint32Value", "uint64Value", "doubleValue", "floatValue", "boolValue", "bytesValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new Value instance using the specified properties.
             * @function create
             * @memberof m10.sdk.Value
             * @static
             * @param {m10.sdk.IValue=} [properties] Properties to set
             * @returns {m10.sdk.Value} Value instance
             */
            Value.create = function create(properties) {
                return new Value(properties);
            };

            /**
             * Encodes the specified Value message. Does not implicitly {@link m10.sdk.Value.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.Value
             * @static
             * @param {m10.sdk.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.stringValue);
                if (message.int8Value != null && Object.hasOwnProperty.call(message, "int8Value"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.int8Value);
                if (message.int16Value != null && Object.hasOwnProperty.call(message, "int16Value"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.int16Value);
                if (message.int32Value != null && Object.hasOwnProperty.call(message, "int32Value"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.int32Value);
                if (message.int64Value != null && Object.hasOwnProperty.call(message, "int64Value"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.int64Value);
                if (message.uint8Value != null && Object.hasOwnProperty.call(message, "uint8Value"))
                    writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.uint8Value);
                if (message.uint16Value != null && Object.hasOwnProperty.call(message, "uint16Value"))
                    writer.uint32(/* id 7, wireType 0 =*/56).uint32(message.uint16Value);
                if (message.uint32Value != null && Object.hasOwnProperty.call(message, "uint32Value"))
                    writer.uint32(/* id 8, wireType 0 =*/64).uint32(message.uint32Value);
                if (message.uint64Value != null && Object.hasOwnProperty.call(message, "uint64Value"))
                    writer.uint32(/* id 9, wireType 0 =*/72).uint64(message.uint64Value);
                if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                    writer.uint32(/* id 10, wireType 1 =*/81).double(message.doubleValue);
                if (message.floatValue != null && Object.hasOwnProperty.call(message, "floatValue"))
                    writer.uint32(/* id 11, wireType 5 =*/93).float(message.floatValue);
                if (message.boolValue != null && Object.hasOwnProperty.call(message, "boolValue"))
                    writer.uint32(/* id 12, wireType 0 =*/96).bool(message.boolValue);
                if (message.bytesValue != null && Object.hasOwnProperty.call(message, "bytesValue"))
                    writer.uint32(/* id 13, wireType 2 =*/106).bytes(message.bytesValue);
                return writer;
            };

            /**
             * Encodes the specified Value message, length delimited. Does not implicitly {@link m10.sdk.Value.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.Value
             * @static
             * @param {m10.sdk.IValue} message Value message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Value.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Value message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.Value();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.stringValue = reader.string();
                        break;
                    case 2:
                        message.int8Value = reader.int32();
                        break;
                    case 3:
                        message.int16Value = reader.int32();
                        break;
                    case 4:
                        message.int32Value = reader.int32();
                        break;
                    case 5:
                        message.int64Value = reader.int64();
                        break;
                    case 6:
                        message.uint8Value = reader.uint32();
                        break;
                    case 7:
                        message.uint16Value = reader.uint32();
                        break;
                    case 8:
                        message.uint32Value = reader.uint32();
                        break;
                    case 9:
                        message.uint64Value = reader.uint64();
                        break;
                    case 10:
                        message.doubleValue = reader.double();
                        break;
                    case 11:
                        message.floatValue = reader.float();
                        break;
                    case 12:
                        message.boolValue = reader.bool();
                        break;
                    case 13:
                        message.bytesValue = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Value message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.Value
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.Value} Value
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Value.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Value message.
             * @function verify
             * @memberof m10.sdk.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    properties.value = 1;
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                }
                if (message.int8Value != null && message.hasOwnProperty("int8Value")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isInteger(message.int8Value))
                        return "int8Value: integer expected";
                }
                if (message.int16Value != null && message.hasOwnProperty("int16Value")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isInteger(message.int16Value))
                        return "int16Value: integer expected";
                }
                if (message.int32Value != null && message.hasOwnProperty("int32Value")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isInteger(message.int32Value))
                        return "int32Value: integer expected";
                }
                if (message.int64Value != null && message.hasOwnProperty("int64Value")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isInteger(message.int64Value) && !(message.int64Value && $util.isInteger(message.int64Value.low) && $util.isInteger(message.int64Value.high)))
                        return "int64Value: integer|Long expected";
                }
                if (message.uint8Value != null && message.hasOwnProperty("uint8Value")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isInteger(message.uint8Value))
                        return "uint8Value: integer expected";
                }
                if (message.uint16Value != null && message.hasOwnProperty("uint16Value")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isInteger(message.uint16Value))
                        return "uint16Value: integer expected";
                }
                if (message.uint32Value != null && message.hasOwnProperty("uint32Value")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isInteger(message.uint32Value))
                        return "uint32Value: integer expected";
                }
                if (message.uint64Value != null && message.hasOwnProperty("uint64Value")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!$util.isInteger(message.uint64Value) && !(message.uint64Value && $util.isInteger(message.uint64Value.low) && $util.isInteger(message.uint64Value.high)))
                        return "uint64Value: integer|Long expected";
                }
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                }
                if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (typeof message.floatValue !== "number")
                        return "floatValue: number expected";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (typeof message.boolValue !== "boolean")
                        return "boolValue: boolean expected";
                }
                if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                    if (properties.value === 1)
                        return "value: multiple values";
                    properties.value = 1;
                    if (!(message.bytesValue && typeof message.bytesValue.length === "number" || $util.isString(message.bytesValue)))
                        return "bytesValue: buffer expected";
                }
                return null;
            };

            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.Value} Value
             */
            Value.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.Value)
                    return object;
                var message = new $root.m10.sdk.Value();
                if (object.stringValue != null)
                    message.stringValue = String(object.stringValue);
                if (object.int8Value != null)
                    message.int8Value = object.int8Value | 0;
                if (object.int16Value != null)
                    message.int16Value = object.int16Value | 0;
                if (object.int32Value != null)
                    message.int32Value = object.int32Value | 0;
                if (object.int64Value != null)
                    if ($util.Long)
                        (message.int64Value = $util.Long.fromValue(object.int64Value)).unsigned = false;
                    else if (typeof object.int64Value === "string")
                        message.int64Value = parseInt(object.int64Value, 10);
                    else if (typeof object.int64Value === "number")
                        message.int64Value = object.int64Value;
                    else if (typeof object.int64Value === "object")
                        message.int64Value = new $util.LongBits(object.int64Value.low >>> 0, object.int64Value.high >>> 0).toNumber();
                if (object.uint8Value != null)
                    message.uint8Value = object.uint8Value >>> 0;
                if (object.uint16Value != null)
                    message.uint16Value = object.uint16Value >>> 0;
                if (object.uint32Value != null)
                    message.uint32Value = object.uint32Value >>> 0;
                if (object.uint64Value != null)
                    if ($util.Long)
                        (message.uint64Value = $util.Long.fromValue(object.uint64Value)).unsigned = true;
                    else if (typeof object.uint64Value === "string")
                        message.uint64Value = parseInt(object.uint64Value, 10);
                    else if (typeof object.uint64Value === "number")
                        message.uint64Value = object.uint64Value;
                    else if (typeof object.uint64Value === "object")
                        message.uint64Value = new $util.LongBits(object.uint64Value.low >>> 0, object.uint64Value.high >>> 0).toNumber(true);
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.floatValue != null)
                    message.floatValue = Number(object.floatValue);
                if (object.boolValue != null)
                    message.boolValue = Boolean(object.boolValue);
                if (object.bytesValue != null)
                    if (typeof object.bytesValue === "string")
                        $util.base64.decode(object.bytesValue, message.bytesValue = $util.newBuffer($util.base64.length(object.bytesValue)), 0);
                    else if (object.bytesValue.length)
                        message.bytesValue = object.bytesValue;
                return message;
            };

            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.Value
             * @static
             * @param {m10.sdk.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    object.stringValue = message.stringValue;
                    if (options.oneofs)
                        object.value = "stringValue";
                }
                if (message.int8Value != null && message.hasOwnProperty("int8Value")) {
                    object.int8Value = message.int8Value;
                    if (options.oneofs)
                        object.value = "int8Value";
                }
                if (message.int16Value != null && message.hasOwnProperty("int16Value")) {
                    object.int16Value = message.int16Value;
                    if (options.oneofs)
                        object.value = "int16Value";
                }
                if (message.int32Value != null && message.hasOwnProperty("int32Value")) {
                    object.int32Value = message.int32Value;
                    if (options.oneofs)
                        object.value = "int32Value";
                }
                if (message.int64Value != null && message.hasOwnProperty("int64Value")) {
                    if (typeof message.int64Value === "number")
                        object.int64Value = options.longs === String ? String(message.int64Value) : message.int64Value;
                    else
                        object.int64Value = options.longs === String ? $util.Long.prototype.toString.call(message.int64Value) : options.longs === Number ? new $util.LongBits(message.int64Value.low >>> 0, message.int64Value.high >>> 0).toNumber() : message.int64Value;
                    if (options.oneofs)
                        object.value = "int64Value";
                }
                if (message.uint8Value != null && message.hasOwnProperty("uint8Value")) {
                    object.uint8Value = message.uint8Value;
                    if (options.oneofs)
                        object.value = "uint8Value";
                }
                if (message.uint16Value != null && message.hasOwnProperty("uint16Value")) {
                    object.uint16Value = message.uint16Value;
                    if (options.oneofs)
                        object.value = "uint16Value";
                }
                if (message.uint32Value != null && message.hasOwnProperty("uint32Value")) {
                    object.uint32Value = message.uint32Value;
                    if (options.oneofs)
                        object.value = "uint32Value";
                }
                if (message.uint64Value != null && message.hasOwnProperty("uint64Value")) {
                    if (typeof message.uint64Value === "number")
                        object.uint64Value = options.longs === String ? String(message.uint64Value) : message.uint64Value;
                    else
                        object.uint64Value = options.longs === String ? $util.Long.prototype.toString.call(message.uint64Value) : options.longs === Number ? new $util.LongBits(message.uint64Value.low >>> 0, message.uint64Value.high >>> 0).toNumber(true) : message.uint64Value;
                    if (options.oneofs)
                        object.value = "uint64Value";
                }
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue")) {
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                    if (options.oneofs)
                        object.value = "doubleValue";
                }
                if (message.floatValue != null && message.hasOwnProperty("floatValue")) {
                    object.floatValue = options.json && !isFinite(message.floatValue) ? String(message.floatValue) : message.floatValue;
                    if (options.oneofs)
                        object.value = "floatValue";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    object.boolValue = message.boolValue;
                    if (options.oneofs)
                        object.value = "boolValue";
                }
                if (message.bytesValue != null && message.hasOwnProperty("bytesValue")) {
                    object.bytesValue = options.bytes === String ? $util.base64.encode(message.bytesValue, 0, message.bytesValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.bytesValue) : message.bytesValue;
                    if (options.oneofs)
                        object.value = "bytesValue";
                }
                return object;
            };

            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof m10.sdk.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Value;
        })();

        sdk.QueryRequest = (function() {

            /**
             * Properties of a QueryRequest.
             * @memberof m10.sdk
             * @interface IQueryRequest
             * @property {string|null} [collection] QueryRequest collection
             * @property {m10.sdk.IExp|null} [expression] QueryRequest expression
             * @property {Uint8Array|null} [publicKey] QueryRequest publicKey
             */

            /**
             * Constructs a new QueryRequest.
             * @memberof m10.sdk
             * @classdesc Represents a QueryRequest.
             * @implements IQueryRequest
             * @constructor
             * @param {m10.sdk.IQueryRequest=} [properties] Properties to set
             */
            function QueryRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * QueryRequest collection.
             * @member {string} collection
             * @memberof m10.sdk.QueryRequest
             * @instance
             */
            QueryRequest.prototype.collection = "";

            /**
             * QueryRequest expression.
             * @member {m10.sdk.IExp|null|undefined} expression
             * @memberof m10.sdk.QueryRequest
             * @instance
             */
            QueryRequest.prototype.expression = null;

            /**
             * QueryRequest publicKey.
             * @member {Uint8Array|null|undefined} publicKey
             * @memberof m10.sdk.QueryRequest
             * @instance
             */
            QueryRequest.prototype.publicKey = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * QueryRequest _publicKey.
             * @member {"publicKey"|undefined} _publicKey
             * @memberof m10.sdk.QueryRequest
             * @instance
             */
            Object.defineProperty(QueryRequest.prototype, "_publicKey", {
                get: $util.oneOfGetter($oneOfFields = ["publicKey"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new QueryRequest instance using the specified properties.
             * @function create
             * @memberof m10.sdk.QueryRequest
             * @static
             * @param {m10.sdk.IQueryRequest=} [properties] Properties to set
             * @returns {m10.sdk.QueryRequest} QueryRequest instance
             */
            QueryRequest.create = function create(properties) {
                return new QueryRequest(properties);
            };

            /**
             * Encodes the specified QueryRequest message. Does not implicitly {@link m10.sdk.QueryRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.QueryRequest
             * @static
             * @param {m10.sdk.IQueryRequest} message QueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collection);
                if (message.expression != null && Object.hasOwnProperty.call(message, "expression"))
                    $root.m10.sdk.Exp.encode(message.expression, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.publicKey != null && Object.hasOwnProperty.call(message, "publicKey"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.publicKey);
                return writer;
            };

            /**
             * Encodes the specified QueryRequest message, length delimited. Does not implicitly {@link m10.sdk.QueryRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.QueryRequest
             * @static
             * @param {m10.sdk.IQueryRequest} message QueryRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            QueryRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a QueryRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.QueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.QueryRequest} QueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.QueryRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection = reader.string();
                        break;
                    case 2:
                        message.expression = $root.m10.sdk.Exp.decode(reader, reader.uint32());
                        break;
                    case 3:
                        message.publicKey = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a QueryRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.QueryRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.QueryRequest} QueryRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            QueryRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a QueryRequest message.
             * @function verify
             * @memberof m10.sdk.QueryRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            QueryRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.expression != null && message.hasOwnProperty("expression")) {
                    var error = $root.m10.sdk.Exp.verify(message.expression);
                    if (error)
                        return "expression." + error;
                }
                if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
                    properties._publicKey = 1;
                    if (!(message.publicKey && typeof message.publicKey.length === "number" || $util.isString(message.publicKey)))
                        return "publicKey: buffer expected";
                }
                return null;
            };

            /**
             * Creates a QueryRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.QueryRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.QueryRequest} QueryRequest
             */
            QueryRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.QueryRequest)
                    return object;
                var message = new $root.m10.sdk.QueryRequest();
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.expression != null) {
                    if (typeof object.expression !== "object")
                        throw TypeError(".m10.sdk.QueryRequest.expression: object expected");
                    message.expression = $root.m10.sdk.Exp.fromObject(object.expression);
                }
                if (object.publicKey != null)
                    if (typeof object.publicKey === "string")
                        $util.base64.decode(object.publicKey, message.publicKey = $util.newBuffer($util.base64.length(object.publicKey)), 0);
                    else if (object.publicKey.length)
                        message.publicKey = object.publicKey;
                return message;
            };

            /**
             * Creates a plain object from a QueryRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.QueryRequest
             * @static
             * @param {m10.sdk.QueryRequest} message QueryRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            QueryRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection = "";
                    object.expression = null;
                }
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.expression != null && message.hasOwnProperty("expression"))
                    object.expression = $root.m10.sdk.Exp.toObject(message.expression, options);
                if (message.publicKey != null && message.hasOwnProperty("publicKey")) {
                    object.publicKey = options.bytes === String ? $util.base64.encode(message.publicKey, 0, message.publicKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.publicKey) : message.publicKey;
                    if (options.oneofs)
                        object._publicKey = "publicKey";
                }
                return object;
            };

            /**
             * Converts this QueryRequest to JSON.
             * @function toJSON
             * @memberof m10.sdk.QueryRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            QueryRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return QueryRequest;
        })();

        sdk.metadata = (function() {

            /**
             * Namespace metadata.
             * @memberof m10.sdk
             * @namespace
             */
            var metadata = {};

            metadata.Attachment = (function() {

                /**
                 * Properties of an Attachment.
                 * @memberof m10.sdk.metadata
                 * @interface IAttachment
                 * @property {string|null} [objectId] Attachment objectId
                 * @property {m10.sdk.metadata.Attachment.AttachmentType|null} [type] Attachment type
                 */

                /**
                 * Constructs a new Attachment.
                 * @memberof m10.sdk.metadata
                 * @classdesc Represents an Attachment.
                 * @implements IAttachment
                 * @constructor
                 * @param {m10.sdk.metadata.IAttachment=} [properties] Properties to set
                 */
                function Attachment(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Attachment objectId.
                 * @member {string} objectId
                 * @memberof m10.sdk.metadata.Attachment
                 * @instance
                 */
                Attachment.prototype.objectId = "";

                /**
                 * Attachment type.
                 * @member {m10.sdk.metadata.Attachment.AttachmentType} type
                 * @memberof m10.sdk.metadata.Attachment
                 * @instance
                 */
                Attachment.prototype.type = 0;

                /**
                 * Creates a new Attachment instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.metadata.Attachment
                 * @static
                 * @param {m10.sdk.metadata.IAttachment=} [properties] Properties to set
                 * @returns {m10.sdk.metadata.Attachment} Attachment instance
                 */
                Attachment.create = function create(properties) {
                    return new Attachment(properties);
                };

                /**
                 * Encodes the specified Attachment message. Does not implicitly {@link m10.sdk.metadata.Attachment.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.metadata.Attachment
                 * @static
                 * @param {m10.sdk.metadata.IAttachment} message Attachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Attachment.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.objectId != null && Object.hasOwnProperty.call(message, "objectId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.objectId);
                    if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.type);
                    return writer;
                };

                /**
                 * Encodes the specified Attachment message, length delimited. Does not implicitly {@link m10.sdk.metadata.Attachment.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.metadata.Attachment
                 * @static
                 * @param {m10.sdk.metadata.IAttachment} message Attachment message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Attachment.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Attachment message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.metadata.Attachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.metadata.Attachment} Attachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Attachment.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.metadata.Attachment();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.objectId = reader.string();
                            break;
                        case 2:
                            message.type = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Attachment message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.metadata.Attachment
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.metadata.Attachment} Attachment
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Attachment.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Attachment message.
                 * @function verify
                 * @memberof m10.sdk.metadata.Attachment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Attachment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.objectId != null && message.hasOwnProperty("objectId"))
                        if (!$util.isString(message.objectId))
                            return "objectId: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates an Attachment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.metadata.Attachment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.metadata.Attachment} Attachment
                 */
                Attachment.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.metadata.Attachment)
                        return object;
                    var message = new $root.m10.sdk.metadata.Attachment();
                    if (object.objectId != null)
                        message.objectId = String(object.objectId);
                    switch (object.type) {
                    case "OBJECT":
                    case 0:
                        message.type = 0;
                        break;
                    case "IMAGE":
                    case 1:
                        message.type = 1;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Attachment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.metadata.Attachment
                 * @static
                 * @param {m10.sdk.metadata.Attachment} message Attachment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Attachment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.objectId = "";
                        object.type = options.enums === String ? "OBJECT" : 0;
                    }
                    if (message.objectId != null && message.hasOwnProperty("objectId"))
                        object.objectId = message.objectId;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.m10.sdk.metadata.Attachment.AttachmentType[message.type] : message.type;
                    return object;
                };

                /**
                 * Converts this Attachment to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.metadata.Attachment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Attachment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * AttachmentType enum.
                 * @name m10.sdk.metadata.Attachment.AttachmentType
                 * @enum {number}
                 * @property {number} OBJECT=0 OBJECT value
                 * @property {number} IMAGE=1 IMAGE value
                 */
                Attachment.AttachmentType = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "OBJECT"] = 0;
                    values[valuesById[1] = "IMAGE"] = 1;
                    return values;
                })();

                return Attachment;
            })();

            metadata.Memo = (function() {

                /**
                 * Properties of a Memo.
                 * @memberof m10.sdk.metadata
                 * @interface IMemo
                 * @property {string|null} [plaintext] Memo plaintext
                 */

                /**
                 * Constructs a new Memo.
                 * @memberof m10.sdk.metadata
                 * @classdesc Represents a Memo.
                 * @implements IMemo
                 * @constructor
                 * @param {m10.sdk.metadata.IMemo=} [properties] Properties to set
                 */
                function Memo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Memo plaintext.
                 * @member {string} plaintext
                 * @memberof m10.sdk.metadata.Memo
                 * @instance
                 */
                Memo.prototype.plaintext = "";

                /**
                 * Creates a new Memo instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.metadata.Memo
                 * @static
                 * @param {m10.sdk.metadata.IMemo=} [properties] Properties to set
                 * @returns {m10.sdk.metadata.Memo} Memo instance
                 */
                Memo.create = function create(properties) {
                    return new Memo(properties);
                };

                /**
                 * Encodes the specified Memo message. Does not implicitly {@link m10.sdk.metadata.Memo.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.metadata.Memo
                 * @static
                 * @param {m10.sdk.metadata.IMemo} message Memo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Memo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.plaintext != null && Object.hasOwnProperty.call(message, "plaintext"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.plaintext);
                    return writer;
                };

                /**
                 * Encodes the specified Memo message, length delimited. Does not implicitly {@link m10.sdk.metadata.Memo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.metadata.Memo
                 * @static
                 * @param {m10.sdk.metadata.IMemo} message Memo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Memo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Memo message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.metadata.Memo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.metadata.Memo} Memo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Memo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.metadata.Memo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.plaintext = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Memo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.metadata.Memo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.metadata.Memo} Memo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Memo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Memo message.
                 * @function verify
                 * @memberof m10.sdk.metadata.Memo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Memo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.plaintext != null && message.hasOwnProperty("plaintext"))
                        if (!$util.isString(message.plaintext))
                            return "plaintext: string expected";
                    return null;
                };

                /**
                 * Creates a Memo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.metadata.Memo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.metadata.Memo} Memo
                 */
                Memo.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.metadata.Memo)
                        return object;
                    var message = new $root.m10.sdk.metadata.Memo();
                    if (object.plaintext != null)
                        message.plaintext = String(object.plaintext);
                    return message;
                };

                /**
                 * Creates a plain object from a Memo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.metadata.Memo
                 * @static
                 * @param {m10.sdk.metadata.Memo} message Memo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Memo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.plaintext = "";
                    if (message.plaintext != null && message.hasOwnProperty("plaintext"))
                        object.plaintext = message.plaintext;
                    return object;
                };

                /**
                 * Converts this Memo to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.metadata.Memo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Memo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Memo;
            })();

            metadata.Fee = (function() {

                /**
                 * Properties of a Fee.
                 * @memberof m10.sdk.metadata
                 * @interface IFee
                 */

                /**
                 * Constructs a new Fee.
                 * @memberof m10.sdk.metadata
                 * @classdesc Represents a Fee.
                 * @implements IFee
                 * @constructor
                 * @param {m10.sdk.metadata.IFee=} [properties] Properties to set
                 */
                function Fee(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Creates a new Fee instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.metadata.Fee
                 * @static
                 * @param {m10.sdk.metadata.IFee=} [properties] Properties to set
                 * @returns {m10.sdk.metadata.Fee} Fee instance
                 */
                Fee.create = function create(properties) {
                    return new Fee(properties);
                };

                /**
                 * Encodes the specified Fee message. Does not implicitly {@link m10.sdk.metadata.Fee.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.metadata.Fee
                 * @static
                 * @param {m10.sdk.metadata.IFee} message Fee message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Fee.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    return writer;
                };

                /**
                 * Encodes the specified Fee message, length delimited. Does not implicitly {@link m10.sdk.metadata.Fee.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.metadata.Fee
                 * @static
                 * @param {m10.sdk.metadata.IFee} message Fee message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Fee.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Fee message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.metadata.Fee
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.metadata.Fee} Fee
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Fee.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.metadata.Fee();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Fee message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.metadata.Fee
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.metadata.Fee} Fee
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Fee.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Fee message.
                 * @function verify
                 * @memberof m10.sdk.metadata.Fee
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Fee.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a Fee message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.metadata.Fee
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.metadata.Fee} Fee
                 */
                Fee.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.metadata.Fee)
                        return object;
                    return new $root.m10.sdk.metadata.Fee();
                };

                /**
                 * Creates a plain object from a Fee message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.metadata.Fee
                 * @static
                 * @param {m10.sdk.metadata.Fee} message Fee
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Fee.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this Fee to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.metadata.Fee
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Fee.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Fee;
            })();

            metadata.Withdraw = (function() {

                /**
                 * Properties of a Withdraw.
                 * @memberof m10.sdk.metadata
                 * @interface IWithdraw
                 * @property {string|null} [bankAccountId] Withdraw bankAccountId
                 */

                /**
                 * Constructs a new Withdraw.
                 * @memberof m10.sdk.metadata
                 * @classdesc Represents a Withdraw.
                 * @implements IWithdraw
                 * @constructor
                 * @param {m10.sdk.metadata.IWithdraw=} [properties] Properties to set
                 */
                function Withdraw(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Withdraw bankAccountId.
                 * @member {string} bankAccountId
                 * @memberof m10.sdk.metadata.Withdraw
                 * @instance
                 */
                Withdraw.prototype.bankAccountId = "";

                /**
                 * Creates a new Withdraw instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.metadata.Withdraw
                 * @static
                 * @param {m10.sdk.metadata.IWithdraw=} [properties] Properties to set
                 * @returns {m10.sdk.metadata.Withdraw} Withdraw instance
                 */
                Withdraw.create = function create(properties) {
                    return new Withdraw(properties);
                };

                /**
                 * Encodes the specified Withdraw message. Does not implicitly {@link m10.sdk.metadata.Withdraw.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.metadata.Withdraw
                 * @static
                 * @param {m10.sdk.metadata.IWithdraw} message Withdraw message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Withdraw.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bankAccountId != null && Object.hasOwnProperty.call(message, "bankAccountId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.bankAccountId);
                    return writer;
                };

                /**
                 * Encodes the specified Withdraw message, length delimited. Does not implicitly {@link m10.sdk.metadata.Withdraw.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.metadata.Withdraw
                 * @static
                 * @param {m10.sdk.metadata.IWithdraw} message Withdraw message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Withdraw.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Withdraw message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.metadata.Withdraw
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.metadata.Withdraw} Withdraw
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Withdraw.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.metadata.Withdraw();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.bankAccountId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Withdraw message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.metadata.Withdraw
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.metadata.Withdraw} Withdraw
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Withdraw.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Withdraw message.
                 * @function verify
                 * @memberof m10.sdk.metadata.Withdraw
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Withdraw.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bankAccountId != null && message.hasOwnProperty("bankAccountId"))
                        if (!$util.isString(message.bankAccountId))
                            return "bankAccountId: string expected";
                    return null;
                };

                /**
                 * Creates a Withdraw message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.metadata.Withdraw
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.metadata.Withdraw} Withdraw
                 */
                Withdraw.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.metadata.Withdraw)
                        return object;
                    var message = new $root.m10.sdk.metadata.Withdraw();
                    if (object.bankAccountId != null)
                        message.bankAccountId = String(object.bankAccountId);
                    return message;
                };

                /**
                 * Creates a plain object from a Withdraw message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.metadata.Withdraw
                 * @static
                 * @param {m10.sdk.metadata.Withdraw} message Withdraw
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Withdraw.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.bankAccountId = "";
                    if (message.bankAccountId != null && message.hasOwnProperty("bankAccountId"))
                        object.bankAccountId = message.bankAccountId;
                    return object;
                };

                /**
                 * Converts this Withdraw to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.metadata.Withdraw
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Withdraw.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Withdraw;
            })();

            metadata.Deposit = (function() {

                /**
                 * Properties of a Deposit.
                 * @memberof m10.sdk.metadata
                 * @interface IDeposit
                 * @property {string|null} [bankAccountId] Deposit bankAccountId
                 */

                /**
                 * Constructs a new Deposit.
                 * @memberof m10.sdk.metadata
                 * @classdesc Represents a Deposit.
                 * @implements IDeposit
                 * @constructor
                 * @param {m10.sdk.metadata.IDeposit=} [properties] Properties to set
                 */
                function Deposit(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Deposit bankAccountId.
                 * @member {string} bankAccountId
                 * @memberof m10.sdk.metadata.Deposit
                 * @instance
                 */
                Deposit.prototype.bankAccountId = "";

                /**
                 * Creates a new Deposit instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.metadata.Deposit
                 * @static
                 * @param {m10.sdk.metadata.IDeposit=} [properties] Properties to set
                 * @returns {m10.sdk.metadata.Deposit} Deposit instance
                 */
                Deposit.create = function create(properties) {
                    return new Deposit(properties);
                };

                /**
                 * Encodes the specified Deposit message. Does not implicitly {@link m10.sdk.metadata.Deposit.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.metadata.Deposit
                 * @static
                 * @param {m10.sdk.metadata.IDeposit} message Deposit message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Deposit.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.bankAccountId != null && Object.hasOwnProperty.call(message, "bankAccountId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.bankAccountId);
                    return writer;
                };

                /**
                 * Encodes the specified Deposit message, length delimited. Does not implicitly {@link m10.sdk.metadata.Deposit.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.metadata.Deposit
                 * @static
                 * @param {m10.sdk.metadata.IDeposit} message Deposit message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Deposit.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Deposit message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.metadata.Deposit
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.metadata.Deposit} Deposit
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Deposit.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.metadata.Deposit();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.bankAccountId = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Deposit message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.metadata.Deposit
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.metadata.Deposit} Deposit
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Deposit.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Deposit message.
                 * @function verify
                 * @memberof m10.sdk.metadata.Deposit
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Deposit.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.bankAccountId != null && message.hasOwnProperty("bankAccountId"))
                        if (!$util.isString(message.bankAccountId))
                            return "bankAccountId: string expected";
                    return null;
                };

                /**
                 * Creates a Deposit message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.metadata.Deposit
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.metadata.Deposit} Deposit
                 */
                Deposit.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.metadata.Deposit)
                        return object;
                    var message = new $root.m10.sdk.metadata.Deposit();
                    if (object.bankAccountId != null)
                        message.bankAccountId = String(object.bankAccountId);
                    return message;
                };

                /**
                 * Creates a plain object from a Deposit message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.metadata.Deposit
                 * @static
                 * @param {m10.sdk.metadata.Deposit} message Deposit
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Deposit.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        object.bankAccountId = "";
                    if (message.bankAccountId != null && message.hasOwnProperty("bankAccountId"))
                        object.bankAccountId = message.bankAccountId;
                    return object;
                };

                /**
                 * Converts this Deposit to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.metadata.Deposit
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Deposit.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Deposit;
            })();

            metadata.Contract = (function() {

                /**
                 * Properties of a Contract.
                 * @memberof m10.sdk.metadata
                 * @interface IContract
                 * @property {Uint8Array|null} [transactions] Contract transactions
                 * @property {Array.<m10.sdk.metadata.IEndorsement>|null} [endorsements] Contract endorsements
                 */

                /**
                 * Constructs a new Contract.
                 * @memberof m10.sdk.metadata
                 * @classdesc Represents a Contract.
                 * @implements IContract
                 * @constructor
                 * @param {m10.sdk.metadata.IContract=} [properties] Properties to set
                 */
                function Contract(properties) {
                    this.endorsements = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Contract transactions.
                 * @member {Uint8Array} transactions
                 * @memberof m10.sdk.metadata.Contract
                 * @instance
                 */
                Contract.prototype.transactions = $util.newBuffer([]);

                /**
                 * Contract endorsements.
                 * @member {Array.<m10.sdk.metadata.IEndorsement>} endorsements
                 * @memberof m10.sdk.metadata.Contract
                 * @instance
                 */
                Contract.prototype.endorsements = $util.emptyArray;

                /**
                 * Creates a new Contract instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.metadata.Contract
                 * @static
                 * @param {m10.sdk.metadata.IContract=} [properties] Properties to set
                 * @returns {m10.sdk.metadata.Contract} Contract instance
                 */
                Contract.create = function create(properties) {
                    return new Contract(properties);
                };

                /**
                 * Encodes the specified Contract message. Does not implicitly {@link m10.sdk.metadata.Contract.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.metadata.Contract
                 * @static
                 * @param {m10.sdk.metadata.IContract} message Contract message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Contract.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transactions != null && Object.hasOwnProperty.call(message, "transactions"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.transactions);
                    if (message.endorsements != null && message.endorsements.length)
                        for (var i = 0; i < message.endorsements.length; ++i)
                            $root.m10.sdk.metadata.Endorsement.encode(message.endorsements[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Contract message, length delimited. Does not implicitly {@link m10.sdk.metadata.Contract.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.metadata.Contract
                 * @static
                 * @param {m10.sdk.metadata.IContract} message Contract message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Contract.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Contract message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.metadata.Contract
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.metadata.Contract} Contract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Contract.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.metadata.Contract();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.transactions = reader.bytes();
                            break;
                        case 2:
                            if (!(message.endorsements && message.endorsements.length))
                                message.endorsements = [];
                            message.endorsements.push($root.m10.sdk.metadata.Endorsement.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Contract message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.metadata.Contract
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.metadata.Contract} Contract
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Contract.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Contract message.
                 * @function verify
                 * @memberof m10.sdk.metadata.Contract
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Contract.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.transactions != null && message.hasOwnProperty("transactions"))
                        if (!(message.transactions && typeof message.transactions.length === "number" || $util.isString(message.transactions)))
                            return "transactions: buffer expected";
                    if (message.endorsements != null && message.hasOwnProperty("endorsements")) {
                        if (!Array.isArray(message.endorsements))
                            return "endorsements: array expected";
                        for (var i = 0; i < message.endorsements.length; ++i) {
                            var error = $root.m10.sdk.metadata.Endorsement.verify(message.endorsements[i]);
                            if (error)
                                return "endorsements." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Contract message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.metadata.Contract
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.metadata.Contract} Contract
                 */
                Contract.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.metadata.Contract)
                        return object;
                    var message = new $root.m10.sdk.metadata.Contract();
                    if (object.transactions != null)
                        if (typeof object.transactions === "string")
                            $util.base64.decode(object.transactions, message.transactions = $util.newBuffer($util.base64.length(object.transactions)), 0);
                        else if (object.transactions.length)
                            message.transactions = object.transactions;
                    if (object.endorsements) {
                        if (!Array.isArray(object.endorsements))
                            throw TypeError(".m10.sdk.metadata.Contract.endorsements: array expected");
                        message.endorsements = [];
                        for (var i = 0; i < object.endorsements.length; ++i) {
                            if (typeof object.endorsements[i] !== "object")
                                throw TypeError(".m10.sdk.metadata.Contract.endorsements: object expected");
                            message.endorsements[i] = $root.m10.sdk.metadata.Endorsement.fromObject(object.endorsements[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Contract message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.metadata.Contract
                 * @static
                 * @param {m10.sdk.metadata.Contract} message Contract
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Contract.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.endorsements = [];
                    if (options.defaults)
                        if (options.bytes === String)
                            object.transactions = "";
                        else {
                            object.transactions = [];
                            if (options.bytes !== Array)
                                object.transactions = $util.newBuffer(object.transactions);
                        }
                    if (message.transactions != null && message.hasOwnProperty("transactions"))
                        object.transactions = options.bytes === String ? $util.base64.encode(message.transactions, 0, message.transactions.length) : options.bytes === Array ? Array.prototype.slice.call(message.transactions) : message.transactions;
                    if (message.endorsements && message.endorsements.length) {
                        object.endorsements = [];
                        for (var j = 0; j < message.endorsements.length; ++j)
                            object.endorsements[j] = $root.m10.sdk.metadata.Endorsement.toObject(message.endorsements[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Contract to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.metadata.Contract
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Contract.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Contract;
            })();

            metadata.Endorsement = (function() {

                /**
                 * Properties of an Endorsement.
                 * @memberof m10.sdk.metadata
                 * @interface IEndorsement
                 * @property {string|null} [ledgerId] Endorsement ledgerId
                 * @property {m10.sdk.ISignature|null} [signature] Endorsement signature
                 */

                /**
                 * Constructs a new Endorsement.
                 * @memberof m10.sdk.metadata
                 * @classdesc Represents an Endorsement.
                 * @implements IEndorsement
                 * @constructor
                 * @param {m10.sdk.metadata.IEndorsement=} [properties] Properties to set
                 */
                function Endorsement(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Endorsement ledgerId.
                 * @member {string} ledgerId
                 * @memberof m10.sdk.metadata.Endorsement
                 * @instance
                 */
                Endorsement.prototype.ledgerId = "";

                /**
                 * Endorsement signature.
                 * @member {m10.sdk.ISignature|null|undefined} signature
                 * @memberof m10.sdk.metadata.Endorsement
                 * @instance
                 */
                Endorsement.prototype.signature = null;

                /**
                 * Creates a new Endorsement instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.metadata.Endorsement
                 * @static
                 * @param {m10.sdk.metadata.IEndorsement=} [properties] Properties to set
                 * @returns {m10.sdk.metadata.Endorsement} Endorsement instance
                 */
                Endorsement.create = function create(properties) {
                    return new Endorsement(properties);
                };

                /**
                 * Encodes the specified Endorsement message. Does not implicitly {@link m10.sdk.metadata.Endorsement.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.metadata.Endorsement
                 * @static
                 * @param {m10.sdk.metadata.IEndorsement} message Endorsement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Endorsement.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ledgerId != null && Object.hasOwnProperty.call(message, "ledgerId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.ledgerId);
                    if (message.signature != null && Object.hasOwnProperty.call(message, "signature"))
                        $root.m10.sdk.Signature.encode(message.signature, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Endorsement message, length delimited. Does not implicitly {@link m10.sdk.metadata.Endorsement.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.metadata.Endorsement
                 * @static
                 * @param {m10.sdk.metadata.IEndorsement} message Endorsement message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Endorsement.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Endorsement message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.metadata.Endorsement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.metadata.Endorsement} Endorsement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Endorsement.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.metadata.Endorsement();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ledgerId = reader.string();
                            break;
                        case 2:
                            message.signature = $root.m10.sdk.Signature.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Endorsement message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.metadata.Endorsement
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.metadata.Endorsement} Endorsement
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Endorsement.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Endorsement message.
                 * @function verify
                 * @memberof m10.sdk.metadata.Endorsement
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Endorsement.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ledgerId != null && message.hasOwnProperty("ledgerId"))
                        if (!$util.isString(message.ledgerId))
                            return "ledgerId: string expected";
                    if (message.signature != null && message.hasOwnProperty("signature")) {
                        var error = $root.m10.sdk.Signature.verify(message.signature);
                        if (error)
                            return "signature." + error;
                    }
                    return null;
                };

                /**
                 * Creates an Endorsement message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.metadata.Endorsement
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.metadata.Endorsement} Endorsement
                 */
                Endorsement.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.metadata.Endorsement)
                        return object;
                    var message = new $root.m10.sdk.metadata.Endorsement();
                    if (object.ledgerId != null)
                        message.ledgerId = String(object.ledgerId);
                    if (object.signature != null) {
                        if (typeof object.signature !== "object")
                            throw TypeError(".m10.sdk.metadata.Endorsement.signature: object expected");
                        message.signature = $root.m10.sdk.Signature.fromObject(object.signature);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Endorsement message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.metadata.Endorsement
                 * @static
                 * @param {m10.sdk.metadata.Endorsement} message Endorsement
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Endorsement.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.ledgerId = "";
                        object.signature = null;
                    }
                    if (message.ledgerId != null && message.hasOwnProperty("ledgerId"))
                        object.ledgerId = message.ledgerId;
                    if (message.signature != null && message.hasOwnProperty("signature"))
                        object.signature = $root.m10.sdk.Signature.toObject(message.signature, options);
                    return object;
                };

                /**
                 * Converts this Endorsement to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.metadata.Endorsement
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Endorsement.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Endorsement;
            })();

            metadata.PaymentRequest = (function() {

                /**
                 * Properties of a PaymentRequest.
                 * @memberof m10.sdk.metadata
                 * @interface IPaymentRequest
                 * @property {m10.sdk.transaction.ICreateTransfer|null} [transfer] PaymentRequest transfer
                 * @property {m10.sdk.metadata.PaymentRequest.PaymentRequestStatus|null} [status] PaymentRequest status
                 */

                /**
                 * Constructs a new PaymentRequest.
                 * @memberof m10.sdk.metadata
                 * @classdesc Represents a PaymentRequest.
                 * @implements IPaymentRequest
                 * @constructor
                 * @param {m10.sdk.metadata.IPaymentRequest=} [properties] Properties to set
                 */
                function PaymentRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PaymentRequest transfer.
                 * @member {m10.sdk.transaction.ICreateTransfer|null|undefined} transfer
                 * @memberof m10.sdk.metadata.PaymentRequest
                 * @instance
                 */
                PaymentRequest.prototype.transfer = null;

                /**
                 * PaymentRequest status.
                 * @member {m10.sdk.metadata.PaymentRequest.PaymentRequestStatus} status
                 * @memberof m10.sdk.metadata.PaymentRequest
                 * @instance
                 */
                PaymentRequest.prototype.status = 0;

                /**
                 * Creates a new PaymentRequest instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.metadata.PaymentRequest
                 * @static
                 * @param {m10.sdk.metadata.IPaymentRequest=} [properties] Properties to set
                 * @returns {m10.sdk.metadata.PaymentRequest} PaymentRequest instance
                 */
                PaymentRequest.create = function create(properties) {
                    return new PaymentRequest(properties);
                };

                /**
                 * Encodes the specified PaymentRequest message. Does not implicitly {@link m10.sdk.metadata.PaymentRequest.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.metadata.PaymentRequest
                 * @static
                 * @param {m10.sdk.metadata.IPaymentRequest} message PaymentRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PaymentRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                        $root.m10.sdk.transaction.CreateTransfer.encode(message.transfer, writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.status != null && Object.hasOwnProperty.call(message, "status"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.status);
                    return writer;
                };

                /**
                 * Encodes the specified PaymentRequest message, length delimited. Does not implicitly {@link m10.sdk.metadata.PaymentRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.metadata.PaymentRequest
                 * @static
                 * @param {m10.sdk.metadata.IPaymentRequest} message PaymentRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                PaymentRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a PaymentRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.metadata.PaymentRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.metadata.PaymentRequest} PaymentRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PaymentRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.metadata.PaymentRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.transfer = $root.m10.sdk.transaction.CreateTransfer.decode(reader, reader.uint32());
                            break;
                        case 2:
                            message.status = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a PaymentRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.metadata.PaymentRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.metadata.PaymentRequest} PaymentRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                PaymentRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a PaymentRequest message.
                 * @function verify
                 * @memberof m10.sdk.metadata.PaymentRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PaymentRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.transfer != null && message.hasOwnProperty("transfer")) {
                        var error = $root.m10.sdk.transaction.CreateTransfer.verify(message.transfer);
                        if (error)
                            return "transfer." + error;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a PaymentRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.metadata.PaymentRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.metadata.PaymentRequest} PaymentRequest
                 */
                PaymentRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.metadata.PaymentRequest)
                        return object;
                    var message = new $root.m10.sdk.metadata.PaymentRequest();
                    if (object.transfer != null) {
                        if (typeof object.transfer !== "object")
                            throw TypeError(".m10.sdk.metadata.PaymentRequest.transfer: object expected");
                        message.transfer = $root.m10.sdk.transaction.CreateTransfer.fromObject(object.transfer);
                    }
                    switch (object.status) {
                    case "PENDING":
                    case 0:
                        message.status = 0;
                        break;
                    case "DECLINED":
                    case 1:
                        message.status = 1;
                        break;
                    case "CANCELED":
                    case 2:
                        message.status = 2;
                        break;
                    case "IN_PROGRESS":
                    case 3:
                        message.status = 3;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PaymentRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.metadata.PaymentRequest
                 * @static
                 * @param {m10.sdk.metadata.PaymentRequest} message PaymentRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PaymentRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.transfer = null;
                        object.status = options.enums === String ? "PENDING" : 0;
                    }
                    if (message.transfer != null && message.hasOwnProperty("transfer"))
                        object.transfer = $root.m10.sdk.transaction.CreateTransfer.toObject(message.transfer, options);
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.m10.sdk.metadata.PaymentRequest.PaymentRequestStatus[message.status] : message.status;
                    return object;
                };

                /**
                 * Converts this PaymentRequest to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.metadata.PaymentRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PaymentRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * PaymentRequestStatus enum.
                 * @name m10.sdk.metadata.PaymentRequest.PaymentRequestStatus
                 * @enum {number}
                 * @property {number} PENDING=0 PENDING value
                 * @property {number} DECLINED=1 DECLINED value
                 * @property {number} CANCELED=2 CANCELED value
                 * @property {number} IN_PROGRESS=3 IN_PROGRESS value
                 */
                PaymentRequest.PaymentRequestStatus = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "PENDING"] = 0;
                    values[valuesById[1] = "DECLINED"] = 1;
                    values[valuesById[2] = "CANCELED"] = 2;
                    values[valuesById[3] = "IN_PROGRESS"] = 3;
                    return values;
                })();

                return PaymentRequest;
            })();

            return metadata;
        })();

        sdk.model = (function() {

            /**
             * Namespace model.
             * @memberof m10.sdk
             * @namespace
             */
            var model = {};

            model.Account = (function() {

                /**
                 * Properties of an Account.
                 * @memberof m10.sdk.model
                 * @interface IAccount
                 * @property {Uint8Array|null} [owner] Account owner
                 * @property {string|null} [profileImageUrl] Account profileImageUrl
                 * @property {string|null} [name] Account name
                 * @property {string|null} [publicName] Account publicName
                 * @property {Uint8Array|null} [id] Account id
                 */

                /**
                 * Constructs a new Account.
                 * @memberof m10.sdk.model
                 * @classdesc Represents an Account.
                 * @implements IAccount
                 * @constructor
                 * @param {m10.sdk.model.IAccount=} [properties] Properties to set
                 */
                function Account(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Account owner.
                 * @member {Uint8Array} owner
                 * @memberof m10.sdk.model.Account
                 * @instance
                 */
                Account.prototype.owner = $util.newBuffer([]);

                /**
                 * Account profileImageUrl.
                 * @member {string} profileImageUrl
                 * @memberof m10.sdk.model.Account
                 * @instance
                 */
                Account.prototype.profileImageUrl = "";

                /**
                 * Account name.
                 * @member {string} name
                 * @memberof m10.sdk.model.Account
                 * @instance
                 */
                Account.prototype.name = "";

                /**
                 * Account publicName.
                 * @member {string} publicName
                 * @memberof m10.sdk.model.Account
                 * @instance
                 */
                Account.prototype.publicName = "";

                /**
                 * Account id.
                 * @member {Uint8Array} id
                 * @memberof m10.sdk.model.Account
                 * @instance
                 */
                Account.prototype.id = $util.newBuffer([]);

                /**
                 * Creates a new Account instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.model.Account
                 * @static
                 * @param {m10.sdk.model.IAccount=} [properties] Properties to set
                 * @returns {m10.sdk.model.Account} Account instance
                 */
                Account.create = function create(properties) {
                    return new Account(properties);
                };

                /**
                 * Encodes the specified Account message. Does not implicitly {@link m10.sdk.model.Account.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.model.Account
                 * @static
                 * @param {m10.sdk.model.IAccount} message Account message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Account.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner);
                    if (message.profileImageUrl != null && Object.hasOwnProperty.call(message, "profileImageUrl"))
                        writer.uint32(/* id 9, wireType 2 =*/74).string(message.profileImageUrl);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.name);
                    if (message.publicName != null && Object.hasOwnProperty.call(message, "publicName"))
                        writer.uint32(/* id 11, wireType 2 =*/90).string(message.publicName);
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 12, wireType 2 =*/98).bytes(message.id);
                    return writer;
                };

                /**
                 * Encodes the specified Account message, length delimited. Does not implicitly {@link m10.sdk.model.Account.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.model.Account
                 * @static
                 * @param {m10.sdk.model.IAccount} message Account message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Account.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Account message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.model.Account
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.model.Account} Account
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Account.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.model.Account();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.owner = reader.bytes();
                            break;
                        case 9:
                            message.profileImageUrl = reader.string();
                            break;
                        case 10:
                            message.name = reader.string();
                            break;
                        case 11:
                            message.publicName = reader.string();
                            break;
                        case 12:
                            message.id = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Account message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.model.Account
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.model.Account} Account
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Account.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Account message.
                 * @function verify
                 * @memberof m10.sdk.model.Account
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Account.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                            return "owner: buffer expected";
                    if (message.profileImageUrl != null && message.hasOwnProperty("profileImageUrl"))
                        if (!$util.isString(message.profileImageUrl))
                            return "profileImageUrl: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.publicName != null && message.hasOwnProperty("publicName"))
                        if (!$util.isString(message.publicName))
                            return "publicName: string expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                            return "id: buffer expected";
                    return null;
                };

                /**
                 * Creates an Account message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.model.Account
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.model.Account} Account
                 */
                Account.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.model.Account)
                        return object;
                    var message = new $root.m10.sdk.model.Account();
                    if (object.owner != null)
                        if (typeof object.owner === "string")
                            $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                        else if (object.owner.length)
                            message.owner = object.owner;
                    if (object.profileImageUrl != null)
                        message.profileImageUrl = String(object.profileImageUrl);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.publicName != null)
                        message.publicName = String(object.publicName);
                    if (object.id != null)
                        if (typeof object.id === "string")
                            $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                        else if (object.id.length)
                            message.id = object.id;
                    return message;
                };

                /**
                 * Creates a plain object from an Account message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.model.Account
                 * @static
                 * @param {m10.sdk.model.Account} message Account
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Account.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.owner = "";
                        else {
                            object.owner = [];
                            if (options.bytes !== Array)
                                object.owner = $util.newBuffer(object.owner);
                        }
                        object.profileImageUrl = "";
                        object.name = "";
                        object.publicName = "";
                        if (options.bytes === String)
                            object.id = "";
                        else {
                            object.id = [];
                            if (options.bytes !== Array)
                                object.id = $util.newBuffer(object.id);
                        }
                    }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
                    if (message.profileImageUrl != null && message.hasOwnProperty("profileImageUrl"))
                        object.profileImageUrl = message.profileImageUrl;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.publicName != null && message.hasOwnProperty("publicName"))
                        object.publicName = message.publicName;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                    return object;
                };

                /**
                 * Converts this Account to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.model.Account
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Account.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Account;
            })();

            model.AccountRef = (function() {

                /**
                 * Properties of an AccountRef.
                 * @memberof m10.sdk.model
                 * @interface IAccountRef
                 * @property {string|null} [ledgerId] AccountRef ledgerId
                 * @property {Uint8Array|null} [accountId] AccountRef accountId
                 */

                /**
                 * Constructs a new AccountRef.
                 * @memberof m10.sdk.model
                 * @classdesc Represents an AccountRef.
                 * @implements IAccountRef
                 * @constructor
                 * @param {m10.sdk.model.IAccountRef=} [properties] Properties to set
                 */
                function AccountRef(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AccountRef ledgerId.
                 * @member {string} ledgerId
                 * @memberof m10.sdk.model.AccountRef
                 * @instance
                 */
                AccountRef.prototype.ledgerId = "";

                /**
                 * AccountRef accountId.
                 * @member {Uint8Array} accountId
                 * @memberof m10.sdk.model.AccountRef
                 * @instance
                 */
                AccountRef.prototype.accountId = $util.newBuffer([]);

                /**
                 * Creates a new AccountRef instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.model.AccountRef
                 * @static
                 * @param {m10.sdk.model.IAccountRef=} [properties] Properties to set
                 * @returns {m10.sdk.model.AccountRef} AccountRef instance
                 */
                AccountRef.create = function create(properties) {
                    return new AccountRef(properties);
                };

                /**
                 * Encodes the specified AccountRef message. Does not implicitly {@link m10.sdk.model.AccountRef.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.model.AccountRef
                 * @static
                 * @param {m10.sdk.model.IAccountRef} message AccountRef message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountRef.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ledgerId != null && Object.hasOwnProperty.call(message, "ledgerId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.ledgerId);
                    if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accountId);
                    return writer;
                };

                /**
                 * Encodes the specified AccountRef message, length delimited. Does not implicitly {@link m10.sdk.model.AccountRef.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.model.AccountRef
                 * @static
                 * @param {m10.sdk.model.IAccountRef} message AccountRef message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountRef.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AccountRef message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.model.AccountRef
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.model.AccountRef} AccountRef
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountRef.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.model.AccountRef();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ledgerId = reader.string();
                            break;
                        case 2:
                            message.accountId = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AccountRef message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.model.AccountRef
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.model.AccountRef} AccountRef
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountRef.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AccountRef message.
                 * @function verify
                 * @memberof m10.sdk.model.AccountRef
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AccountRef.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ledgerId != null && message.hasOwnProperty("ledgerId"))
                        if (!$util.isString(message.ledgerId))
                            return "ledgerId: string expected";
                    if (message.accountId != null && message.hasOwnProperty("accountId"))
                        if (!(message.accountId && typeof message.accountId.length === "number" || $util.isString(message.accountId)))
                            return "accountId: buffer expected";
                    return null;
                };

                /**
                 * Creates an AccountRef message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.model.AccountRef
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.model.AccountRef} AccountRef
                 */
                AccountRef.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.model.AccountRef)
                        return object;
                    var message = new $root.m10.sdk.model.AccountRef();
                    if (object.ledgerId != null)
                        message.ledgerId = String(object.ledgerId);
                    if (object.accountId != null)
                        if (typeof object.accountId === "string")
                            $util.base64.decode(object.accountId, message.accountId = $util.newBuffer($util.base64.length(object.accountId)), 0);
                        else if (object.accountId.length)
                            message.accountId = object.accountId;
                    return message;
                };

                /**
                 * Creates a plain object from an AccountRef message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.model.AccountRef
                 * @static
                 * @param {m10.sdk.model.AccountRef} message AccountRef
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AccountRef.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.ledgerId = "";
                        if (options.bytes === String)
                            object.accountId = "";
                        else {
                            object.accountId = [];
                            if (options.bytes !== Array)
                                object.accountId = $util.newBuffer(object.accountId);
                        }
                    }
                    if (message.ledgerId != null && message.hasOwnProperty("ledgerId"))
                        object.ledgerId = message.ledgerId;
                    if (message.accountId != null && message.hasOwnProperty("accountId"))
                        object.accountId = options.bytes === String ? $util.base64.encode(message.accountId, 0, message.accountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountId) : message.accountId;
                    return object;
                };

                /**
                 * Converts this AccountRef to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.model.AccountRef
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AccountRef.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AccountRef;
            })();

            model.AccountSet = (function() {

                /**
                 * Properties of an AccountSet.
                 * @memberof m10.sdk.model
                 * @interface IAccountSet
                 * @property {Uint8Array|null} [owner] AccountSet owner
                 * @property {Array.<m10.sdk.model.IAccountRef>|null} [accounts] AccountSet accounts
                 * @property {Uint8Array|null} [id] AccountSet id
                 */

                /**
                 * Constructs a new AccountSet.
                 * @memberof m10.sdk.model
                 * @classdesc Represents an AccountSet.
                 * @implements IAccountSet
                 * @constructor
                 * @param {m10.sdk.model.IAccountSet=} [properties] Properties to set
                 */
                function AccountSet(properties) {
                    this.accounts = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AccountSet owner.
                 * @member {Uint8Array} owner
                 * @memberof m10.sdk.model.AccountSet
                 * @instance
                 */
                AccountSet.prototype.owner = $util.newBuffer([]);

                /**
                 * AccountSet accounts.
                 * @member {Array.<m10.sdk.model.IAccountRef>} accounts
                 * @memberof m10.sdk.model.AccountSet
                 * @instance
                 */
                AccountSet.prototype.accounts = $util.emptyArray;

                /**
                 * AccountSet id.
                 * @member {Uint8Array} id
                 * @memberof m10.sdk.model.AccountSet
                 * @instance
                 */
                AccountSet.prototype.id = $util.newBuffer([]);

                /**
                 * Creates a new AccountSet instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.model.AccountSet
                 * @static
                 * @param {m10.sdk.model.IAccountSet=} [properties] Properties to set
                 * @returns {m10.sdk.model.AccountSet} AccountSet instance
                 */
                AccountSet.create = function create(properties) {
                    return new AccountSet(properties);
                };

                /**
                 * Encodes the specified AccountSet message. Does not implicitly {@link m10.sdk.model.AccountSet.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.model.AccountSet
                 * @static
                 * @param {m10.sdk.model.IAccountSet} message AccountSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountSet.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.owner);
                    if (message.accounts != null && message.accounts.length)
                        for (var i = 0; i < message.accounts.length; ++i)
                            $root.m10.sdk.model.AccountRef.encode(message.accounts[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.id);
                    return writer;
                };

                /**
                 * Encodes the specified AccountSet message, length delimited. Does not implicitly {@link m10.sdk.model.AccountSet.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.model.AccountSet
                 * @static
                 * @param {m10.sdk.model.IAccountSet} message AccountSet message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountSet.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AccountSet message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.model.AccountSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.model.AccountSet} AccountSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountSet.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.model.AccountSet();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.owner = reader.bytes();
                            break;
                        case 2:
                            if (!(message.accounts && message.accounts.length))
                                message.accounts = [];
                            message.accounts.push($root.m10.sdk.model.AccountRef.decode(reader, reader.uint32()));
                            break;
                        case 7:
                            message.id = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AccountSet message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.model.AccountSet
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.model.AccountSet} AccountSet
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountSet.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AccountSet message.
                 * @function verify
                 * @memberof m10.sdk.model.AccountSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AccountSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                            return "owner: buffer expected";
                    if (message.accounts != null && message.hasOwnProperty("accounts")) {
                        if (!Array.isArray(message.accounts))
                            return "accounts: array expected";
                        for (var i = 0; i < message.accounts.length; ++i) {
                            var error = $root.m10.sdk.model.AccountRef.verify(message.accounts[i]);
                            if (error)
                                return "accounts." + error;
                        }
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                            return "id: buffer expected";
                    return null;
                };

                /**
                 * Creates an AccountSet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.model.AccountSet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.model.AccountSet} AccountSet
                 */
                AccountSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.model.AccountSet)
                        return object;
                    var message = new $root.m10.sdk.model.AccountSet();
                    if (object.owner != null)
                        if (typeof object.owner === "string")
                            $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                        else if (object.owner.length)
                            message.owner = object.owner;
                    if (object.accounts) {
                        if (!Array.isArray(object.accounts))
                            throw TypeError(".m10.sdk.model.AccountSet.accounts: array expected");
                        message.accounts = [];
                        for (var i = 0; i < object.accounts.length; ++i) {
                            if (typeof object.accounts[i] !== "object")
                                throw TypeError(".m10.sdk.model.AccountSet.accounts: object expected");
                            message.accounts[i] = $root.m10.sdk.model.AccountRef.fromObject(object.accounts[i]);
                        }
                    }
                    if (object.id != null)
                        if (typeof object.id === "string")
                            $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                        else if (object.id.length)
                            message.id = object.id;
                    return message;
                };

                /**
                 * Creates a plain object from an AccountSet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.model.AccountSet
                 * @static
                 * @param {m10.sdk.model.AccountSet} message AccountSet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AccountSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.accounts = [];
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.owner = "";
                        else {
                            object.owner = [];
                            if (options.bytes !== Array)
                                object.owner = $util.newBuffer(object.owner);
                        }
                        if (options.bytes === String)
                            object.id = "";
                        else {
                            object.id = [];
                            if (options.bytes !== Array)
                                object.id = $util.newBuffer(object.id);
                        }
                    }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
                    if (message.accounts && message.accounts.length) {
                        object.accounts = [];
                        for (var j = 0; j < message.accounts.length; ++j)
                            object.accounts[j] = $root.m10.sdk.model.AccountRef.toObject(message.accounts[j], options);
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                    return object;
                };

                /**
                 * Converts this AccountSet to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.model.AccountSet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AccountSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AccountSet;
            })();

            model.AccountInfo = (function() {

                /**
                 * Properties of an AccountInfo.
                 * @memberof m10.sdk.model
                 * @interface IAccountInfo
                 * @property {Uint8Array|null} [accountId] AccountInfo accountId
                 * @property {Uint8Array|null} [parentAccountId] AccountInfo parentAccountId
                 * @property {string|null} [publicName] AccountInfo publicName
                 * @property {string|null} [profileImageUrl] AccountInfo profileImageUrl
                 * @property {string|null} [code] AccountInfo code
                 * @property {number|null} [decimalPlaces] AccountInfo decimalPlaces
                 */

                /**
                 * Constructs a new AccountInfo.
                 * @memberof m10.sdk.model
                 * @classdesc Represents an AccountInfo.
                 * @implements IAccountInfo
                 * @constructor
                 * @param {m10.sdk.model.IAccountInfo=} [properties] Properties to set
                 */
                function AccountInfo(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AccountInfo accountId.
                 * @member {Uint8Array} accountId
                 * @memberof m10.sdk.model.AccountInfo
                 * @instance
                 */
                AccountInfo.prototype.accountId = $util.newBuffer([]);

                /**
                 * AccountInfo parentAccountId.
                 * @member {Uint8Array} parentAccountId
                 * @memberof m10.sdk.model.AccountInfo
                 * @instance
                 */
                AccountInfo.prototype.parentAccountId = $util.newBuffer([]);

                /**
                 * AccountInfo publicName.
                 * @member {string} publicName
                 * @memberof m10.sdk.model.AccountInfo
                 * @instance
                 */
                AccountInfo.prototype.publicName = "";

                /**
                 * AccountInfo profileImageUrl.
                 * @member {string} profileImageUrl
                 * @memberof m10.sdk.model.AccountInfo
                 * @instance
                 */
                AccountInfo.prototype.profileImageUrl = "";

                /**
                 * AccountInfo code.
                 * @member {string} code
                 * @memberof m10.sdk.model.AccountInfo
                 * @instance
                 */
                AccountInfo.prototype.code = "";

                /**
                 * AccountInfo decimalPlaces.
                 * @member {number} decimalPlaces
                 * @memberof m10.sdk.model.AccountInfo
                 * @instance
                 */
                AccountInfo.prototype.decimalPlaces = 0;

                /**
                 * Creates a new AccountInfo instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.model.AccountInfo
                 * @static
                 * @param {m10.sdk.model.IAccountInfo=} [properties] Properties to set
                 * @returns {m10.sdk.model.AccountInfo} AccountInfo instance
                 */
                AccountInfo.create = function create(properties) {
                    return new AccountInfo(properties);
                };

                /**
                 * Encodes the specified AccountInfo message. Does not implicitly {@link m10.sdk.model.AccountInfo.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.model.AccountInfo
                 * @static
                 * @param {m10.sdk.model.IAccountInfo} message AccountInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountInfo.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountId);
                    if (message.parentAccountId != null && Object.hasOwnProperty.call(message, "parentAccountId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.parentAccountId);
                    if (message.publicName != null && Object.hasOwnProperty.call(message, "publicName"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.publicName);
                    if (message.profileImageUrl != null && Object.hasOwnProperty.call(message, "profileImageUrl"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.profileImageUrl);
                    if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                        writer.uint32(/* id 5, wireType 2 =*/42).string(message.code);
                    if (message.decimalPlaces != null && Object.hasOwnProperty.call(message, "decimalPlaces"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint32(message.decimalPlaces);
                    return writer;
                };

                /**
                 * Encodes the specified AccountInfo message, length delimited. Does not implicitly {@link m10.sdk.model.AccountInfo.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.model.AccountInfo
                 * @static
                 * @param {m10.sdk.model.IAccountInfo} message AccountInfo message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                AccountInfo.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an AccountInfo message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.model.AccountInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.model.AccountInfo} AccountInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountInfo.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.model.AccountInfo();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.accountId = reader.bytes();
                            break;
                        case 2:
                            message.parentAccountId = reader.bytes();
                            break;
                        case 3:
                            message.publicName = reader.string();
                            break;
                        case 4:
                            message.profileImageUrl = reader.string();
                            break;
                        case 5:
                            message.code = reader.string();
                            break;
                        case 6:
                            message.decimalPlaces = reader.uint32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an AccountInfo message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.model.AccountInfo
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.model.AccountInfo} AccountInfo
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                AccountInfo.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an AccountInfo message.
                 * @function verify
                 * @memberof m10.sdk.model.AccountInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AccountInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.accountId != null && message.hasOwnProperty("accountId"))
                        if (!(message.accountId && typeof message.accountId.length === "number" || $util.isString(message.accountId)))
                            return "accountId: buffer expected";
                    if (message.parentAccountId != null && message.hasOwnProperty("parentAccountId"))
                        if (!(message.parentAccountId && typeof message.parentAccountId.length === "number" || $util.isString(message.parentAccountId)))
                            return "parentAccountId: buffer expected";
                    if (message.publicName != null && message.hasOwnProperty("publicName"))
                        if (!$util.isString(message.publicName))
                            return "publicName: string expected";
                    if (message.profileImageUrl != null && message.hasOwnProperty("profileImageUrl"))
                        if (!$util.isString(message.profileImageUrl))
                            return "profileImageUrl: string expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isString(message.code))
                            return "code: string expected";
                    if (message.decimalPlaces != null && message.hasOwnProperty("decimalPlaces"))
                        if (!$util.isInteger(message.decimalPlaces))
                            return "decimalPlaces: integer expected";
                    return null;
                };

                /**
                 * Creates an AccountInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.model.AccountInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.model.AccountInfo} AccountInfo
                 */
                AccountInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.model.AccountInfo)
                        return object;
                    var message = new $root.m10.sdk.model.AccountInfo();
                    if (object.accountId != null)
                        if (typeof object.accountId === "string")
                            $util.base64.decode(object.accountId, message.accountId = $util.newBuffer($util.base64.length(object.accountId)), 0);
                        else if (object.accountId.length)
                            message.accountId = object.accountId;
                    if (object.parentAccountId != null)
                        if (typeof object.parentAccountId === "string")
                            $util.base64.decode(object.parentAccountId, message.parentAccountId = $util.newBuffer($util.base64.length(object.parentAccountId)), 0);
                        else if (object.parentAccountId.length)
                            message.parentAccountId = object.parentAccountId;
                    if (object.publicName != null)
                        message.publicName = String(object.publicName);
                    if (object.profileImageUrl != null)
                        message.profileImageUrl = String(object.profileImageUrl);
                    if (object.code != null)
                        message.code = String(object.code);
                    if (object.decimalPlaces != null)
                        message.decimalPlaces = object.decimalPlaces >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from an AccountInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.model.AccountInfo
                 * @static
                 * @param {m10.sdk.model.AccountInfo} message AccountInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AccountInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.accountId = "";
                        else {
                            object.accountId = [];
                            if (options.bytes !== Array)
                                object.accountId = $util.newBuffer(object.accountId);
                        }
                        if (options.bytes === String)
                            object.parentAccountId = "";
                        else {
                            object.parentAccountId = [];
                            if (options.bytes !== Array)
                                object.parentAccountId = $util.newBuffer(object.parentAccountId);
                        }
                        object.publicName = "";
                        object.profileImageUrl = "";
                        object.code = "";
                        object.decimalPlaces = 0;
                    }
                    if (message.accountId != null && message.hasOwnProperty("accountId"))
                        object.accountId = options.bytes === String ? $util.base64.encode(message.accountId, 0, message.accountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountId) : message.accountId;
                    if (message.parentAccountId != null && message.hasOwnProperty("parentAccountId"))
                        object.parentAccountId = options.bytes === String ? $util.base64.encode(message.parentAccountId, 0, message.parentAccountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentAccountId) : message.parentAccountId;
                    if (message.publicName != null && message.hasOwnProperty("publicName"))
                        object.publicName = message.publicName;
                    if (message.profileImageUrl != null && message.hasOwnProperty("profileImageUrl"))
                        object.profileImageUrl = message.profileImageUrl;
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = message.code;
                    if (message.decimalPlaces != null && message.hasOwnProperty("decimalPlaces"))
                        object.decimalPlaces = message.decimalPlaces;
                    return object;
                };

                /**
                 * Converts this AccountInfo to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.model.AccountInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AccountInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AccountInfo;
            })();

            return model;
        })();

        sdk.RoleBinding = (function() {

            /**
             * Properties of a RoleBinding.
             * @memberof m10.sdk
             * @interface IRoleBinding
             * @property {Uint8Array|null} [id] RoleBinding id
             * @property {string|null} [name] RoleBinding name
             * @property {Uint8Array|null} [role] RoleBinding role
             * @property {Array.<Uint8Array>|null} [subjects] RoleBinding subjects
             * @property {Array.<m10.sdk.IExpression>|null} [expressions] RoleBinding expressions
             * @property {boolean|null} [isUniversal] RoleBinding isUniversal
             * @property {Uint8Array|null} [owner] RoleBinding owner
             */

            /**
             * Constructs a new RoleBinding.
             * @memberof m10.sdk
             * @classdesc Represents a RoleBinding.
             * @implements IRoleBinding
             * @constructor
             * @param {m10.sdk.IRoleBinding=} [properties] Properties to set
             */
            function RoleBinding(properties) {
                this.subjects = [];
                this.expressions = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * RoleBinding id.
             * @member {Uint8Array} id
             * @memberof m10.sdk.RoleBinding
             * @instance
             */
            RoleBinding.prototype.id = $util.newBuffer([]);

            /**
             * RoleBinding name.
             * @member {string} name
             * @memberof m10.sdk.RoleBinding
             * @instance
             */
            RoleBinding.prototype.name = "";

            /**
             * RoleBinding role.
             * @member {Uint8Array} role
             * @memberof m10.sdk.RoleBinding
             * @instance
             */
            RoleBinding.prototype.role = $util.newBuffer([]);

            /**
             * RoleBinding subjects.
             * @member {Array.<Uint8Array>} subjects
             * @memberof m10.sdk.RoleBinding
             * @instance
             */
            RoleBinding.prototype.subjects = $util.emptyArray;

            /**
             * RoleBinding expressions.
             * @member {Array.<m10.sdk.IExpression>} expressions
             * @memberof m10.sdk.RoleBinding
             * @instance
             */
            RoleBinding.prototype.expressions = $util.emptyArray;

            /**
             * RoleBinding isUniversal.
             * @member {boolean} isUniversal
             * @memberof m10.sdk.RoleBinding
             * @instance
             */
            RoleBinding.prototype.isUniversal = false;

            /**
             * RoleBinding owner.
             * @member {Uint8Array} owner
             * @memberof m10.sdk.RoleBinding
             * @instance
             */
            RoleBinding.prototype.owner = $util.newBuffer([]);

            /**
             * Creates a new RoleBinding instance using the specified properties.
             * @function create
             * @memberof m10.sdk.RoleBinding
             * @static
             * @param {m10.sdk.IRoleBinding=} [properties] Properties to set
             * @returns {m10.sdk.RoleBinding} RoleBinding instance
             */
            RoleBinding.create = function create(properties) {
                return new RoleBinding(properties);
            };

            /**
             * Encodes the specified RoleBinding message. Does not implicitly {@link m10.sdk.RoleBinding.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.RoleBinding
             * @static
             * @param {m10.sdk.IRoleBinding} message RoleBinding message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleBinding.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                if (message.role != null && Object.hasOwnProperty.call(message, "role"))
                    writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.role);
                if (message.subjects != null && message.subjects.length)
                    for (var i = 0; i < message.subjects.length; ++i)
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.subjects[i]);
                if (message.expressions != null && message.expressions.length)
                    for (var i = 0; i < message.expressions.length; ++i)
                        $root.m10.sdk.Expression.encode(message.expressions[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.isUniversal != null && Object.hasOwnProperty.call(message, "isUniversal"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.isUniversal);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.owner);
                return writer;
            };

            /**
             * Encodes the specified RoleBinding message, length delimited. Does not implicitly {@link m10.sdk.RoleBinding.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.RoleBinding
             * @static
             * @param {m10.sdk.IRoleBinding} message RoleBinding message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            RoleBinding.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a RoleBinding message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.RoleBinding
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.RoleBinding} RoleBinding
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleBinding.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.RoleBinding();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.bytes();
                        break;
                    case 2:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.role = reader.bytes();
                        break;
                    case 4:
                        if (!(message.subjects && message.subjects.length))
                            message.subjects = [];
                        message.subjects.push(reader.bytes());
                        break;
                    case 5:
                        if (!(message.expressions && message.expressions.length))
                            message.expressions = [];
                        message.expressions.push($root.m10.sdk.Expression.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        message.isUniversal = reader.bool();
                        break;
                    case 7:
                        message.owner = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a RoleBinding message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.RoleBinding
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.RoleBinding} RoleBinding
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            RoleBinding.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a RoleBinding message.
             * @function verify
             * @memberof m10.sdk.RoleBinding
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            RoleBinding.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                        return "id: buffer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.role != null && message.hasOwnProperty("role"))
                    if (!(message.role && typeof message.role.length === "number" || $util.isString(message.role)))
                        return "role: buffer expected";
                if (message.subjects != null && message.hasOwnProperty("subjects")) {
                    if (!Array.isArray(message.subjects))
                        return "subjects: array expected";
                    for (var i = 0; i < message.subjects.length; ++i)
                        if (!(message.subjects[i] && typeof message.subjects[i].length === "number" || $util.isString(message.subjects[i])))
                            return "subjects: buffer[] expected";
                }
                if (message.expressions != null && message.hasOwnProperty("expressions")) {
                    if (!Array.isArray(message.expressions))
                        return "expressions: array expected";
                    for (var i = 0; i < message.expressions.length; ++i) {
                        var error = $root.m10.sdk.Expression.verify(message.expressions[i]);
                        if (error)
                            return "expressions." + error;
                    }
                }
                if (message.isUniversal != null && message.hasOwnProperty("isUniversal"))
                    if (typeof message.isUniversal !== "boolean")
                        return "isUniversal: boolean expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                        return "owner: buffer expected";
                return null;
            };

            /**
             * Creates a RoleBinding message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.RoleBinding
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.RoleBinding} RoleBinding
             */
            RoleBinding.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.RoleBinding)
                    return object;
                var message = new $root.m10.sdk.RoleBinding();
                if (object.id != null)
                    if (typeof object.id === "string")
                        $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                    else if (object.id.length)
                        message.id = object.id;
                if (object.name != null)
                    message.name = String(object.name);
                if (object.role != null)
                    if (typeof object.role === "string")
                        $util.base64.decode(object.role, message.role = $util.newBuffer($util.base64.length(object.role)), 0);
                    else if (object.role.length)
                        message.role = object.role;
                if (object.subjects) {
                    if (!Array.isArray(object.subjects))
                        throw TypeError(".m10.sdk.RoleBinding.subjects: array expected");
                    message.subjects = [];
                    for (var i = 0; i < object.subjects.length; ++i)
                        if (typeof object.subjects[i] === "string")
                            $util.base64.decode(object.subjects[i], message.subjects[i] = $util.newBuffer($util.base64.length(object.subjects[i])), 0);
                        else if (object.subjects[i].length)
                            message.subjects[i] = object.subjects[i];
                }
                if (object.expressions) {
                    if (!Array.isArray(object.expressions))
                        throw TypeError(".m10.sdk.RoleBinding.expressions: array expected");
                    message.expressions = [];
                    for (var i = 0; i < object.expressions.length; ++i) {
                        if (typeof object.expressions[i] !== "object")
                            throw TypeError(".m10.sdk.RoleBinding.expressions: object expected");
                        message.expressions[i] = $root.m10.sdk.Expression.fromObject(object.expressions[i]);
                    }
                }
                if (object.isUniversal != null)
                    message.isUniversal = Boolean(object.isUniversal);
                if (object.owner != null)
                    if (typeof object.owner === "string")
                        $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                    else if (object.owner.length)
                        message.owner = object.owner;
                return message;
            };

            /**
             * Creates a plain object from a RoleBinding message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.RoleBinding
             * @static
             * @param {m10.sdk.RoleBinding} message RoleBinding
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            RoleBinding.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.subjects = [];
                    object.expressions = [];
                }
                if (options.defaults) {
                    if (options.bytes === String)
                        object.id = "";
                    else {
                        object.id = [];
                        if (options.bytes !== Array)
                            object.id = $util.newBuffer(object.id);
                    }
                    object.name = "";
                    if (options.bytes === String)
                        object.role = "";
                    else {
                        object.role = [];
                        if (options.bytes !== Array)
                            object.role = $util.newBuffer(object.role);
                    }
                    object.isUniversal = false;
                    if (options.bytes === String)
                        object.owner = "";
                    else {
                        object.owner = [];
                        if (options.bytes !== Array)
                            object.owner = $util.newBuffer(object.owner);
                    }
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.role != null && message.hasOwnProperty("role"))
                    object.role = options.bytes === String ? $util.base64.encode(message.role, 0, message.role.length) : options.bytes === Array ? Array.prototype.slice.call(message.role) : message.role;
                if (message.subjects && message.subjects.length) {
                    object.subjects = [];
                    for (var j = 0; j < message.subjects.length; ++j)
                        object.subjects[j] = options.bytes === String ? $util.base64.encode(message.subjects[j], 0, message.subjects[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.subjects[j]) : message.subjects[j];
                }
                if (message.expressions && message.expressions.length) {
                    object.expressions = [];
                    for (var j = 0; j < message.expressions.length; ++j)
                        object.expressions[j] = $root.m10.sdk.Expression.toObject(message.expressions[j], options);
                }
                if (message.isUniversal != null && message.hasOwnProperty("isUniversal"))
                    object.isUniversal = message.isUniversal;
                if (message.owner != null && message.hasOwnProperty("owner"))
                    object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
                return object;
            };

            /**
             * Converts this RoleBinding to JSON.
             * @function toJSON
             * @memberof m10.sdk.RoleBinding
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            RoleBinding.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return RoleBinding;
        })();

        sdk.Expression = (function() {

            /**
             * Properties of an Expression.
             * @memberof m10.sdk
             * @interface IExpression
             * @property {string|null} [collection] Expression collection
             * @property {string|null} [expression] Expression expression
             */

            /**
             * Constructs a new Expression.
             * @memberof m10.sdk
             * @classdesc Represents an Expression.
             * @implements IExpression
             * @constructor
             * @param {m10.sdk.IExpression=} [properties] Properties to set
             */
            function Expression(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Expression collection.
             * @member {string} collection
             * @memberof m10.sdk.Expression
             * @instance
             */
            Expression.prototype.collection = "";

            /**
             * Expression expression.
             * @member {string} expression
             * @memberof m10.sdk.Expression
             * @instance
             */
            Expression.prototype.expression = "";

            /**
             * Creates a new Expression instance using the specified properties.
             * @function create
             * @memberof m10.sdk.Expression
             * @static
             * @param {m10.sdk.IExpression=} [properties] Properties to set
             * @returns {m10.sdk.Expression} Expression instance
             */
            Expression.create = function create(properties) {
                return new Expression(properties);
            };

            /**
             * Encodes the specified Expression message. Does not implicitly {@link m10.sdk.Expression.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.Expression
             * @static
             * @param {m10.sdk.IExpression} message Expression message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Expression.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.collection);
                if (message.expression != null && Object.hasOwnProperty.call(message, "expression"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.expression);
                return writer;
            };

            /**
             * Encodes the specified Expression message, length delimited. Does not implicitly {@link m10.sdk.Expression.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.Expression
             * @static
             * @param {m10.sdk.IExpression} message Expression message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Expression.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Expression message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.Expression
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.Expression} Expression
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Expression.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.Expression();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.collection = reader.string();
                        break;
                    case 2:
                        message.expression = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Expression message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.Expression
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.Expression} Expression
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Expression.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Expression message.
             * @function verify
             * @memberof m10.sdk.Expression
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Expression.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.expression != null && message.hasOwnProperty("expression"))
                    if (!$util.isString(message.expression))
                        return "expression: string expected";
                return null;
            };

            /**
             * Creates an Expression message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.Expression
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.Expression} Expression
             */
            Expression.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.Expression)
                    return object;
                var message = new $root.m10.sdk.Expression();
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.expression != null)
                    message.expression = String(object.expression);
                return message;
            };

            /**
             * Creates a plain object from an Expression message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.Expression
             * @static
             * @param {m10.sdk.Expression} message Expression
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Expression.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.collection = "";
                    object.expression = "";
                }
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.expression != null && message.hasOwnProperty("expression"))
                    object.expression = message.expression;
                return object;
            };

            /**
             * Converts this Expression to JSON.
             * @function toJSON
             * @memberof m10.sdk.Expression
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Expression.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Expression;
        })();

        sdk.Role = (function() {

            /**
             * Properties of a Role.
             * @memberof m10.sdk
             * @interface IRole
             * @property {Uint8Array|null} [id] Role id
             * @property {Uint8Array|null} [owner] Role owner
             * @property {string|null} [name] Role name
             * @property {Array.<m10.sdk.IRule>|null} [rules] Role rules
             */

            /**
             * Constructs a new Role.
             * @memberof m10.sdk
             * @classdesc Represents a Role.
             * @implements IRole
             * @constructor
             * @param {m10.sdk.IRole=} [properties] Properties to set
             */
            function Role(properties) {
                this.rules = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Role id.
             * @member {Uint8Array} id
             * @memberof m10.sdk.Role
             * @instance
             */
            Role.prototype.id = $util.newBuffer([]);

            /**
             * Role owner.
             * @member {Uint8Array} owner
             * @memberof m10.sdk.Role
             * @instance
             */
            Role.prototype.owner = $util.newBuffer([]);

            /**
             * Role name.
             * @member {string} name
             * @memberof m10.sdk.Role
             * @instance
             */
            Role.prototype.name = "";

            /**
             * Role rules.
             * @member {Array.<m10.sdk.IRule>} rules
             * @memberof m10.sdk.Role
             * @instance
             */
            Role.prototype.rules = $util.emptyArray;

            /**
             * Creates a new Role instance using the specified properties.
             * @function create
             * @memberof m10.sdk.Role
             * @static
             * @param {m10.sdk.IRole=} [properties] Properties to set
             * @returns {m10.sdk.Role} Role instance
             */
            Role.create = function create(properties) {
                return new Role(properties);
            };

            /**
             * Encodes the specified Role message. Does not implicitly {@link m10.sdk.Role.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.Role
             * @static
             * @param {m10.sdk.IRole} message Role message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Role.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                    writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                if (message.owner != null && Object.hasOwnProperty.call(message, "owner"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.owner);
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.name);
                if (message.rules != null && message.rules.length)
                    for (var i = 0; i < message.rules.length; ++i)
                        $root.m10.sdk.Rule.encode(message.rules[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified Role message, length delimited. Does not implicitly {@link m10.sdk.Role.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.Role
             * @static
             * @param {m10.sdk.IRole} message Role message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Role.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Role message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.Role
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.Role} Role
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Role.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.Role();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.id = reader.bytes();
                        break;
                    case 2:
                        message.owner = reader.bytes();
                        break;
                    case 3:
                        message.name = reader.string();
                        break;
                    case 4:
                        if (!(message.rules && message.rules.length))
                            message.rules = [];
                        message.rules.push($root.m10.sdk.Rule.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Role message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.Role
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.Role} Role
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Role.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Role message.
             * @function verify
             * @memberof m10.sdk.Role
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Role.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.id != null && message.hasOwnProperty("id"))
                    if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                        return "id: buffer expected";
                if (message.owner != null && message.hasOwnProperty("owner"))
                    if (!(message.owner && typeof message.owner.length === "number" || $util.isString(message.owner)))
                        return "owner: buffer expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.rules != null && message.hasOwnProperty("rules")) {
                    if (!Array.isArray(message.rules))
                        return "rules: array expected";
                    for (var i = 0; i < message.rules.length; ++i) {
                        var error = $root.m10.sdk.Rule.verify(message.rules[i]);
                        if (error)
                            return "rules." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Role message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.Role
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.Role} Role
             */
            Role.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.Role)
                    return object;
                var message = new $root.m10.sdk.Role();
                if (object.id != null)
                    if (typeof object.id === "string")
                        $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                    else if (object.id.length)
                        message.id = object.id;
                if (object.owner != null)
                    if (typeof object.owner === "string")
                        $util.base64.decode(object.owner, message.owner = $util.newBuffer($util.base64.length(object.owner)), 0);
                    else if (object.owner.length)
                        message.owner = object.owner;
                if (object.name != null)
                    message.name = String(object.name);
                if (object.rules) {
                    if (!Array.isArray(object.rules))
                        throw TypeError(".m10.sdk.Role.rules: array expected");
                    message.rules = [];
                    for (var i = 0; i < object.rules.length; ++i) {
                        if (typeof object.rules[i] !== "object")
                            throw TypeError(".m10.sdk.Role.rules: object expected");
                        message.rules[i] = $root.m10.sdk.Rule.fromObject(object.rules[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Role message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.Role
             * @static
             * @param {m10.sdk.Role} message Role
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Role.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.rules = [];
                if (options.defaults) {
                    if (options.bytes === String)
                        object.id = "";
                    else {
                        object.id = [];
                        if (options.bytes !== Array)
                            object.id = $util.newBuffer(object.id);
                    }
                    if (options.bytes === String)
                        object.owner = "";
                    else {
                        object.owner = [];
                        if (options.bytes !== Array)
                            object.owner = $util.newBuffer(object.owner);
                    }
                    object.name = "";
                }
                if (message.id != null && message.hasOwnProperty("id"))
                    object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                if (message.owner != null && message.hasOwnProperty("owner"))
                    object.owner = options.bytes === String ? $util.base64.encode(message.owner, 0, message.owner.length) : options.bytes === Array ? Array.prototype.slice.call(message.owner) : message.owner;
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.rules && message.rules.length) {
                    object.rules = [];
                    for (var j = 0; j < message.rules.length; ++j)
                        object.rules[j] = $root.m10.sdk.Rule.toObject(message.rules[j], options);
                }
                return object;
            };

            /**
             * Converts this Role to JSON.
             * @function toJSON
             * @memberof m10.sdk.Role
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Role.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Role;
        })();

        sdk.Rule = (function() {

            /**
             * Properties of a Rule.
             * @memberof m10.sdk
             * @interface IRule
             * @property {string|null} [collection] Rule collection
             * @property {Array.<m10.sdk.IValue>|null} [instanceKeys] Rule instanceKeys
             * @property {Array.<m10.sdk.Rule.Verb>|null} [verbs] Rule verbs
             */

            /**
             * Constructs a new Rule.
             * @memberof m10.sdk
             * @classdesc Represents a Rule.
             * @implements IRule
             * @constructor
             * @param {m10.sdk.IRule=} [properties] Properties to set
             */
            function Rule(properties) {
                this.instanceKeys = [];
                this.verbs = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Rule collection.
             * @member {string} collection
             * @memberof m10.sdk.Rule
             * @instance
             */
            Rule.prototype.collection = "";

            /**
             * Rule instanceKeys.
             * @member {Array.<m10.sdk.IValue>} instanceKeys
             * @memberof m10.sdk.Rule
             * @instance
             */
            Rule.prototype.instanceKeys = $util.emptyArray;

            /**
             * Rule verbs.
             * @member {Array.<m10.sdk.Rule.Verb>} verbs
             * @memberof m10.sdk.Rule
             * @instance
             */
            Rule.prototype.verbs = $util.emptyArray;

            /**
             * Creates a new Rule instance using the specified properties.
             * @function create
             * @memberof m10.sdk.Rule
             * @static
             * @param {m10.sdk.IRule=} [properties] Properties to set
             * @returns {m10.sdk.Rule} Rule instance
             */
            Rule.create = function create(properties) {
                return new Rule(properties);
            };

            /**
             * Encodes the specified Rule message. Does not implicitly {@link m10.sdk.Rule.verify|verify} messages.
             * @function encode
             * @memberof m10.sdk.Rule
             * @static
             * @param {m10.sdk.IRule} message Rule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Rule.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.collection != null && Object.hasOwnProperty.call(message, "collection"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.collection);
                if (message.instanceKeys != null && message.instanceKeys.length)
                    for (var i = 0; i < message.instanceKeys.length; ++i)
                        $root.m10.sdk.Value.encode(message.instanceKeys[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.verbs != null && message.verbs.length) {
                    writer.uint32(/* id 4, wireType 2 =*/34).fork();
                    for (var i = 0; i < message.verbs.length; ++i)
                        writer.int32(message.verbs[i]);
                    writer.ldelim();
                }
                return writer;
            };

            /**
             * Encodes the specified Rule message, length delimited. Does not implicitly {@link m10.sdk.Rule.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.sdk.Rule
             * @static
             * @param {m10.sdk.IRule} message Rule message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Rule.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Rule message from the specified reader or buffer.
             * @function decode
             * @memberof m10.sdk.Rule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.sdk.Rule} Rule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Rule.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.Rule();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.collection = reader.string();
                        break;
                    case 3:
                        if (!(message.instanceKeys && message.instanceKeys.length))
                            message.instanceKeys = [];
                        message.instanceKeys.push($root.m10.sdk.Value.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.verbs && message.verbs.length))
                            message.verbs = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.verbs.push(reader.int32());
                        } else
                            message.verbs.push(reader.int32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Rule message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.sdk.Rule
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.sdk.Rule} Rule
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Rule.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Rule message.
             * @function verify
             * @memberof m10.sdk.Rule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Rule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    if (!$util.isString(message.collection))
                        return "collection: string expected";
                if (message.instanceKeys != null && message.hasOwnProperty("instanceKeys")) {
                    if (!Array.isArray(message.instanceKeys))
                        return "instanceKeys: array expected";
                    for (var i = 0; i < message.instanceKeys.length; ++i) {
                        var error = $root.m10.sdk.Value.verify(message.instanceKeys[i]);
                        if (error)
                            return "instanceKeys." + error;
                    }
                }
                if (message.verbs != null && message.hasOwnProperty("verbs")) {
                    if (!Array.isArray(message.verbs))
                        return "verbs: array expected";
                    for (var i = 0; i < message.verbs.length; ++i)
                        switch (message.verbs[i]) {
                        default:
                            return "verbs: enum value[] expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                            break;
                        }
                }
                return null;
            };

            /**
             * Creates a Rule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.sdk.Rule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.sdk.Rule} Rule
             */
            Rule.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.sdk.Rule)
                    return object;
                var message = new $root.m10.sdk.Rule();
                if (object.collection != null)
                    message.collection = String(object.collection);
                if (object.instanceKeys) {
                    if (!Array.isArray(object.instanceKeys))
                        throw TypeError(".m10.sdk.Rule.instanceKeys: array expected");
                    message.instanceKeys = [];
                    for (var i = 0; i < object.instanceKeys.length; ++i) {
                        if (typeof object.instanceKeys[i] !== "object")
                            throw TypeError(".m10.sdk.Rule.instanceKeys: object expected");
                        message.instanceKeys[i] = $root.m10.sdk.Value.fromObject(object.instanceKeys[i]);
                    }
                }
                if (object.verbs) {
                    if (!Array.isArray(object.verbs))
                        throw TypeError(".m10.sdk.Rule.verbs: array expected");
                    message.verbs = [];
                    for (var i = 0; i < object.verbs.length; ++i)
                        switch (object.verbs[i]) {
                        default:
                        case "READ":
                        case 0:
                            message.verbs[i] = 0;
                            break;
                        case "CREATE":
                        case 1:
                            message.verbs[i] = 1;
                            break;
                        case "UPDATE":
                        case 2:
                            message.verbs[i] = 2;
                            break;
                        case "DELETE":
                        case 3:
                            message.verbs[i] = 3;
                            break;
                        case "TRANSACT":
                        case 4:
                            message.verbs[i] = 4;
                            break;
                        case "INITIATE":
                        case 5:
                            message.verbs[i] = 5;
                            break;
                        case "COMMIT":
                        case 6:
                            message.verbs[i] = 6;
                            break;
                        }
                }
                return message;
            };

            /**
             * Creates a plain object from a Rule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.sdk.Rule
             * @static
             * @param {m10.sdk.Rule} message Rule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Rule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.instanceKeys = [];
                    object.verbs = [];
                }
                if (options.defaults)
                    object.collection = "";
                if (message.collection != null && message.hasOwnProperty("collection"))
                    object.collection = message.collection;
                if (message.instanceKeys && message.instanceKeys.length) {
                    object.instanceKeys = [];
                    for (var j = 0; j < message.instanceKeys.length; ++j)
                        object.instanceKeys[j] = $root.m10.sdk.Value.toObject(message.instanceKeys[j], options);
                }
                if (message.verbs && message.verbs.length) {
                    object.verbs = [];
                    for (var j = 0; j < message.verbs.length; ++j)
                        object.verbs[j] = options.enums === String ? $root.m10.sdk.Rule.Verb[message.verbs[j]] : message.verbs[j];
                }
                return object;
            };

            /**
             * Converts this Rule to JSON.
             * @function toJSON
             * @memberof m10.sdk.Rule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Rule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Verb enum.
             * @name m10.sdk.Rule.Verb
             * @enum {number}
             * @property {number} READ=0 READ value
             * @property {number} CREATE=1 CREATE value
             * @property {number} UPDATE=2 UPDATE value
             * @property {number} DELETE=3 DELETE value
             * @property {number} TRANSACT=4 TRANSACT value
             * @property {number} INITIATE=5 INITIATE value
             * @property {number} COMMIT=6 COMMIT value
             */
            Rule.Verb = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "READ"] = 0;
                values[valuesById[1] = "CREATE"] = 1;
                values[valuesById[2] = "UPDATE"] = 2;
                values[valuesById[3] = "DELETE"] = 3;
                values[valuesById[4] = "TRANSACT"] = 4;
                values[valuesById[5] = "INITIATE"] = 5;
                values[valuesById[6] = "COMMIT"] = 6;
                return values;
            })();

            return Rule;
        })();

        sdk.transaction = (function() {

            /**
             * Namespace transaction.
             * @memberof m10.sdk
             * @namespace
             */
            var transaction = {};

            transaction.TransactionRequestPayload = (function() {

                /**
                 * Properties of a TransactionRequestPayload.
                 * @memberof m10.sdk.transaction
                 * @interface ITransactionRequestPayload
                 * @property {number|Long|null} [nonce] TransactionRequestPayload nonce
                 * @property {number|Long|null} [timestamp] TransactionRequestPayload timestamp
                 * @property {Uint8Array|null} [contextId] TransactionRequestPayload contextId
                 * @property {m10.sdk.transaction.ITransactionData|null} [data] TransactionRequestPayload data
                 */

                /**
                 * Constructs a new TransactionRequestPayload.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a TransactionRequestPayload.
                 * @implements ITransactionRequestPayload
                 * @constructor
                 * @param {m10.sdk.transaction.ITransactionRequestPayload=} [properties] Properties to set
                 */
                function TransactionRequestPayload(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransactionRequestPayload nonce.
                 * @member {number|Long} nonce
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @instance
                 */
                TransactionRequestPayload.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * TransactionRequestPayload timestamp.
                 * @member {number|Long} timestamp
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @instance
                 */
                TransactionRequestPayload.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * TransactionRequestPayload contextId.
                 * @member {Uint8Array} contextId
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @instance
                 */
                TransactionRequestPayload.prototype.contextId = $util.newBuffer([]);

                /**
                 * TransactionRequestPayload data.
                 * @member {m10.sdk.transaction.ITransactionData|null|undefined} data
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @instance
                 */
                TransactionRequestPayload.prototype.data = null;

                /**
                 * Creates a new TransactionRequestPayload instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @static
                 * @param {m10.sdk.transaction.ITransactionRequestPayload=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.TransactionRequestPayload} TransactionRequestPayload instance
                 */
                TransactionRequestPayload.create = function create(properties) {
                    return new TransactionRequestPayload(properties);
                };

                /**
                 * Encodes the specified TransactionRequestPayload message. Does not implicitly {@link m10.sdk.transaction.TransactionRequestPayload.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @static
                 * @param {m10.sdk.transaction.ITransactionRequestPayload} message TransactionRequestPayload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionRequestPayload.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.nonce);
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.timestamp);
                    if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.contextId);
                    if (message.data != null && Object.hasOwnProperty.call(message, "data"))
                        $root.m10.sdk.transaction.TransactionData.encode(message.data, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TransactionRequestPayload message, length delimited. Does not implicitly {@link m10.sdk.transaction.TransactionRequestPayload.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @static
                 * @param {m10.sdk.transaction.ITransactionRequestPayload} message TransactionRequestPayload message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionRequestPayload.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransactionRequestPayload message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.TransactionRequestPayload} TransactionRequestPayload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionRequestPayload.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.TransactionRequestPayload();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.nonce = reader.uint64();
                            break;
                        case 2:
                            message.timestamp = reader.uint64();
                            break;
                        case 5:
                            message.contextId = reader.bytes();
                            break;
                        case 6:
                            message.data = $root.m10.sdk.transaction.TransactionData.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransactionRequestPayload message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.TransactionRequestPayload} TransactionRequestPayload
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionRequestPayload.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransactionRequestPayload message.
                 * @function verify
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransactionRequestPayload.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.nonce != null && message.hasOwnProperty("nonce"))
                        if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                            return "nonce: integer|Long expected";
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                            return "timestamp: integer|Long expected";
                    if (message.contextId != null && message.hasOwnProperty("contextId"))
                        if (!(message.contextId && typeof message.contextId.length === "number" || $util.isString(message.contextId)))
                            return "contextId: buffer expected";
                    if (message.data != null && message.hasOwnProperty("data")) {
                        var error = $root.m10.sdk.transaction.TransactionData.verify(message.data);
                        if (error)
                            return "data." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TransactionRequestPayload message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.TransactionRequestPayload} TransactionRequestPayload
                 */
                TransactionRequestPayload.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.TransactionRequestPayload)
                        return object;
                    var message = new $root.m10.sdk.transaction.TransactionRequestPayload();
                    if (object.nonce != null)
                        if ($util.Long)
                            (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                        else if (typeof object.nonce === "string")
                            message.nonce = parseInt(object.nonce, 10);
                        else if (typeof object.nonce === "number")
                            message.nonce = object.nonce;
                        else if (typeof object.nonce === "object")
                            message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                    if (object.timestamp != null)
                        if ($util.Long)
                            (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = true;
                        else if (typeof object.timestamp === "string")
                            message.timestamp = parseInt(object.timestamp, 10);
                        else if (typeof object.timestamp === "number")
                            message.timestamp = object.timestamp;
                        else if (typeof object.timestamp === "object")
                            message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber(true);
                    if (object.contextId != null)
                        if (typeof object.contextId === "string")
                            $util.base64.decode(object.contextId, message.contextId = $util.newBuffer($util.base64.length(object.contextId)), 0);
                        else if (object.contextId.length)
                            message.contextId = object.contextId;
                    if (object.data != null) {
                        if (typeof object.data !== "object")
                            throw TypeError(".m10.sdk.transaction.TransactionRequestPayload.data: object expected");
                        message.data = $root.m10.sdk.transaction.TransactionData.fromObject(object.data);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TransactionRequestPayload message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @static
                 * @param {m10.sdk.transaction.TransactionRequestPayload} message TransactionRequestPayload
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransactionRequestPayload.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.nonce = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timestamp = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.contextId = "";
                        else {
                            object.contextId = [];
                            if (options.bytes !== Array)
                                object.contextId = $util.newBuffer(object.contextId);
                        }
                        object.data = null;
                    }
                    if (message.nonce != null && message.hasOwnProperty("nonce"))
                        if (typeof message.nonce === "number")
                            object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                        else
                            object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if (typeof message.timestamp === "number")
                            object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                        else
                            object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber(true) : message.timestamp;
                    if (message.contextId != null && message.hasOwnProperty("contextId"))
                        object.contextId = options.bytes === String ? $util.base64.encode(message.contextId, 0, message.contextId.length) : options.bytes === Array ? Array.prototype.slice.call(message.contextId) : message.contextId;
                    if (message.data != null && message.hasOwnProperty("data"))
                        object.data = $root.m10.sdk.transaction.TransactionData.toObject(message.data, options);
                    return object;
                };

                /**
                 * Converts this TransactionRequestPayload to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.TransactionRequestPayload
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransactionRequestPayload.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TransactionRequestPayload;
            })();

            transaction.TransactionData = (function() {

                /**
                 * Properties of a TransactionData.
                 * @memberof m10.sdk.transaction
                 * @interface ITransactionData
                 * @property {m10.sdk.transaction.ICreateTransfer|null} [transfer] TransactionData transfer
                 * @property {m10.sdk.transaction.ICreateLedgerAccount|null} [createLedgerAccount] TransactionData createLedgerAccount
                 * @property {m10.sdk.transaction.ISetFreezeState|null} [setFreezeState] TransactionData setFreezeState
                 * @property {m10.sdk.IDocumentOperations|null} [documentOperations] TransactionData documentOperations
                 * @property {m10.sdk.transaction.IInvokeAction|null} [invokeAction] TransactionData invokeAction
                 * @property {m10.sdk.transaction.ICreateTransfer|null} [initiateTransfer] TransactionData initiateTransfer
                 * @property {m10.sdk.transaction.ICommitTransfer|null} [commitTransfer] TransactionData commitTransfer
                 * @property {m10.sdk.transaction.ISetInstrument|null} [setInstrument] TransactionData setInstrument
                 */

                /**
                 * Constructs a new TransactionData.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a TransactionData.
                 * @implements ITransactionData
                 * @constructor
                 * @param {m10.sdk.transaction.ITransactionData=} [properties] Properties to set
                 */
                function TransactionData(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransactionData transfer.
                 * @member {m10.sdk.transaction.ICreateTransfer|null|undefined} transfer
                 * @memberof m10.sdk.transaction.TransactionData
                 * @instance
                 */
                TransactionData.prototype.transfer = null;

                /**
                 * TransactionData createLedgerAccount.
                 * @member {m10.sdk.transaction.ICreateLedgerAccount|null|undefined} createLedgerAccount
                 * @memberof m10.sdk.transaction.TransactionData
                 * @instance
                 */
                TransactionData.prototype.createLedgerAccount = null;

                /**
                 * TransactionData setFreezeState.
                 * @member {m10.sdk.transaction.ISetFreezeState|null|undefined} setFreezeState
                 * @memberof m10.sdk.transaction.TransactionData
                 * @instance
                 */
                TransactionData.prototype.setFreezeState = null;

                /**
                 * TransactionData documentOperations.
                 * @member {m10.sdk.IDocumentOperations|null|undefined} documentOperations
                 * @memberof m10.sdk.transaction.TransactionData
                 * @instance
                 */
                TransactionData.prototype.documentOperations = null;

                /**
                 * TransactionData invokeAction.
                 * @member {m10.sdk.transaction.IInvokeAction|null|undefined} invokeAction
                 * @memberof m10.sdk.transaction.TransactionData
                 * @instance
                 */
                TransactionData.prototype.invokeAction = null;

                /**
                 * TransactionData initiateTransfer.
                 * @member {m10.sdk.transaction.ICreateTransfer|null|undefined} initiateTransfer
                 * @memberof m10.sdk.transaction.TransactionData
                 * @instance
                 */
                TransactionData.prototype.initiateTransfer = null;

                /**
                 * TransactionData commitTransfer.
                 * @member {m10.sdk.transaction.ICommitTransfer|null|undefined} commitTransfer
                 * @memberof m10.sdk.transaction.TransactionData
                 * @instance
                 */
                TransactionData.prototype.commitTransfer = null;

                /**
                 * TransactionData setInstrument.
                 * @member {m10.sdk.transaction.ISetInstrument|null|undefined} setInstrument
                 * @memberof m10.sdk.transaction.TransactionData
                 * @instance
                 */
                TransactionData.prototype.setInstrument = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * TransactionData data.
                 * @member {"transfer"|"createLedgerAccount"|"setFreezeState"|"documentOperations"|"invokeAction"|"initiateTransfer"|"commitTransfer"|"setInstrument"|undefined} data
                 * @memberof m10.sdk.transaction.TransactionData
                 * @instance
                 */
                Object.defineProperty(TransactionData.prototype, "data", {
                    get: $util.oneOfGetter($oneOfFields = ["transfer", "createLedgerAccount", "setFreezeState", "documentOperations", "invokeAction", "initiateTransfer", "commitTransfer", "setInstrument"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new TransactionData instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.TransactionData
                 * @static
                 * @param {m10.sdk.transaction.ITransactionData=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.TransactionData} TransactionData instance
                 */
                TransactionData.create = function create(properties) {
                    return new TransactionData(properties);
                };

                /**
                 * Encodes the specified TransactionData message. Does not implicitly {@link m10.sdk.transaction.TransactionData.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.TransactionData
                 * @static
                 * @param {m10.sdk.transaction.ITransactionData} message TransactionData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionData.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                        $root.m10.sdk.transaction.CreateTransfer.encode(message.transfer, writer.uint32(/* id 10, wireType 2 =*/82).fork()).ldelim();
                    if (message.createLedgerAccount != null && Object.hasOwnProperty.call(message, "createLedgerAccount"))
                        $root.m10.sdk.transaction.CreateLedgerAccount.encode(message.createLedgerAccount, writer.uint32(/* id 11, wireType 2 =*/90).fork()).ldelim();
                    if (message.setFreezeState != null && Object.hasOwnProperty.call(message, "setFreezeState"))
                        $root.m10.sdk.transaction.SetFreezeState.encode(message.setFreezeState, writer.uint32(/* id 12, wireType 2 =*/98).fork()).ldelim();
                    if (message.documentOperations != null && Object.hasOwnProperty.call(message, "documentOperations"))
                        $root.m10.sdk.DocumentOperations.encode(message.documentOperations, writer.uint32(/* id 16, wireType 2 =*/130).fork()).ldelim();
                    if (message.invokeAction != null && Object.hasOwnProperty.call(message, "invokeAction"))
                        $root.m10.sdk.transaction.InvokeAction.encode(message.invokeAction, writer.uint32(/* id 20, wireType 2 =*/162).fork()).ldelim();
                    if (message.initiateTransfer != null && Object.hasOwnProperty.call(message, "initiateTransfer"))
                        $root.m10.sdk.transaction.CreateTransfer.encode(message.initiateTransfer, writer.uint32(/* id 21, wireType 2 =*/170).fork()).ldelim();
                    if (message.commitTransfer != null && Object.hasOwnProperty.call(message, "commitTransfer"))
                        $root.m10.sdk.transaction.CommitTransfer.encode(message.commitTransfer, writer.uint32(/* id 22, wireType 2 =*/178).fork()).ldelim();
                    if (message.setInstrument != null && Object.hasOwnProperty.call(message, "setInstrument"))
                        $root.m10.sdk.transaction.SetInstrument.encode(message.setInstrument, writer.uint32(/* id 23, wireType 2 =*/186).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TransactionData message, length delimited. Does not implicitly {@link m10.sdk.transaction.TransactionData.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.TransactionData
                 * @static
                 * @param {m10.sdk.transaction.ITransactionData} message TransactionData message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionData.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransactionData message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.TransactionData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.TransactionData} TransactionData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionData.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.TransactionData();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 10:
                            message.transfer = $root.m10.sdk.transaction.CreateTransfer.decode(reader, reader.uint32());
                            break;
                        case 11:
                            message.createLedgerAccount = $root.m10.sdk.transaction.CreateLedgerAccount.decode(reader, reader.uint32());
                            break;
                        case 12:
                            message.setFreezeState = $root.m10.sdk.transaction.SetFreezeState.decode(reader, reader.uint32());
                            break;
                        case 16:
                            message.documentOperations = $root.m10.sdk.DocumentOperations.decode(reader, reader.uint32());
                            break;
                        case 20:
                            message.invokeAction = $root.m10.sdk.transaction.InvokeAction.decode(reader, reader.uint32());
                            break;
                        case 21:
                            message.initiateTransfer = $root.m10.sdk.transaction.CreateTransfer.decode(reader, reader.uint32());
                            break;
                        case 22:
                            message.commitTransfer = $root.m10.sdk.transaction.CommitTransfer.decode(reader, reader.uint32());
                            break;
                        case 23:
                            message.setInstrument = $root.m10.sdk.transaction.SetInstrument.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransactionData message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.TransactionData
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.TransactionData} TransactionData
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionData.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransactionData message.
                 * @function verify
                 * @memberof m10.sdk.transaction.TransactionData
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransactionData.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.transfer != null && message.hasOwnProperty("transfer")) {
                        properties.data = 1;
                        {
                            var error = $root.m10.sdk.transaction.CreateTransfer.verify(message.transfer);
                            if (error)
                                return "transfer." + error;
                        }
                    }
                    if (message.createLedgerAccount != null && message.hasOwnProperty("createLedgerAccount")) {
                        if (properties.data === 1)
                            return "data: multiple values";
                        properties.data = 1;
                        {
                            var error = $root.m10.sdk.transaction.CreateLedgerAccount.verify(message.createLedgerAccount);
                            if (error)
                                return "createLedgerAccount." + error;
                        }
                    }
                    if (message.setFreezeState != null && message.hasOwnProperty("setFreezeState")) {
                        if (properties.data === 1)
                            return "data: multiple values";
                        properties.data = 1;
                        {
                            var error = $root.m10.sdk.transaction.SetFreezeState.verify(message.setFreezeState);
                            if (error)
                                return "setFreezeState." + error;
                        }
                    }
                    if (message.documentOperations != null && message.hasOwnProperty("documentOperations")) {
                        if (properties.data === 1)
                            return "data: multiple values";
                        properties.data = 1;
                        {
                            var error = $root.m10.sdk.DocumentOperations.verify(message.documentOperations);
                            if (error)
                                return "documentOperations." + error;
                        }
                    }
                    if (message.invokeAction != null && message.hasOwnProperty("invokeAction")) {
                        if (properties.data === 1)
                            return "data: multiple values";
                        properties.data = 1;
                        {
                            var error = $root.m10.sdk.transaction.InvokeAction.verify(message.invokeAction);
                            if (error)
                                return "invokeAction." + error;
                        }
                    }
                    if (message.initiateTransfer != null && message.hasOwnProperty("initiateTransfer")) {
                        if (properties.data === 1)
                            return "data: multiple values";
                        properties.data = 1;
                        {
                            var error = $root.m10.sdk.transaction.CreateTransfer.verify(message.initiateTransfer);
                            if (error)
                                return "initiateTransfer." + error;
                        }
                    }
                    if (message.commitTransfer != null && message.hasOwnProperty("commitTransfer")) {
                        if (properties.data === 1)
                            return "data: multiple values";
                        properties.data = 1;
                        {
                            var error = $root.m10.sdk.transaction.CommitTransfer.verify(message.commitTransfer);
                            if (error)
                                return "commitTransfer." + error;
                        }
                    }
                    if (message.setInstrument != null && message.hasOwnProperty("setInstrument")) {
                        if (properties.data === 1)
                            return "data: multiple values";
                        properties.data = 1;
                        {
                            var error = $root.m10.sdk.transaction.SetInstrument.verify(message.setInstrument);
                            if (error)
                                return "setInstrument." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TransactionData message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.TransactionData
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.TransactionData} TransactionData
                 */
                TransactionData.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.TransactionData)
                        return object;
                    var message = new $root.m10.sdk.transaction.TransactionData();
                    if (object.transfer != null) {
                        if (typeof object.transfer !== "object")
                            throw TypeError(".m10.sdk.transaction.TransactionData.transfer: object expected");
                        message.transfer = $root.m10.sdk.transaction.CreateTransfer.fromObject(object.transfer);
                    }
                    if (object.createLedgerAccount != null) {
                        if (typeof object.createLedgerAccount !== "object")
                            throw TypeError(".m10.sdk.transaction.TransactionData.createLedgerAccount: object expected");
                        message.createLedgerAccount = $root.m10.sdk.transaction.CreateLedgerAccount.fromObject(object.createLedgerAccount);
                    }
                    if (object.setFreezeState != null) {
                        if (typeof object.setFreezeState !== "object")
                            throw TypeError(".m10.sdk.transaction.TransactionData.setFreezeState: object expected");
                        message.setFreezeState = $root.m10.sdk.transaction.SetFreezeState.fromObject(object.setFreezeState);
                    }
                    if (object.documentOperations != null) {
                        if (typeof object.documentOperations !== "object")
                            throw TypeError(".m10.sdk.transaction.TransactionData.documentOperations: object expected");
                        message.documentOperations = $root.m10.sdk.DocumentOperations.fromObject(object.documentOperations);
                    }
                    if (object.invokeAction != null) {
                        if (typeof object.invokeAction !== "object")
                            throw TypeError(".m10.sdk.transaction.TransactionData.invokeAction: object expected");
                        message.invokeAction = $root.m10.sdk.transaction.InvokeAction.fromObject(object.invokeAction);
                    }
                    if (object.initiateTransfer != null) {
                        if (typeof object.initiateTransfer !== "object")
                            throw TypeError(".m10.sdk.transaction.TransactionData.initiateTransfer: object expected");
                        message.initiateTransfer = $root.m10.sdk.transaction.CreateTransfer.fromObject(object.initiateTransfer);
                    }
                    if (object.commitTransfer != null) {
                        if (typeof object.commitTransfer !== "object")
                            throw TypeError(".m10.sdk.transaction.TransactionData.commitTransfer: object expected");
                        message.commitTransfer = $root.m10.sdk.transaction.CommitTransfer.fromObject(object.commitTransfer);
                    }
                    if (object.setInstrument != null) {
                        if (typeof object.setInstrument !== "object")
                            throw TypeError(".m10.sdk.transaction.TransactionData.setInstrument: object expected");
                        message.setInstrument = $root.m10.sdk.transaction.SetInstrument.fromObject(object.setInstrument);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TransactionData message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.TransactionData
                 * @static
                 * @param {m10.sdk.transaction.TransactionData} message TransactionData
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransactionData.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.transfer != null && message.hasOwnProperty("transfer")) {
                        object.transfer = $root.m10.sdk.transaction.CreateTransfer.toObject(message.transfer, options);
                        if (options.oneofs)
                            object.data = "transfer";
                    }
                    if (message.createLedgerAccount != null && message.hasOwnProperty("createLedgerAccount")) {
                        object.createLedgerAccount = $root.m10.sdk.transaction.CreateLedgerAccount.toObject(message.createLedgerAccount, options);
                        if (options.oneofs)
                            object.data = "createLedgerAccount";
                    }
                    if (message.setFreezeState != null && message.hasOwnProperty("setFreezeState")) {
                        object.setFreezeState = $root.m10.sdk.transaction.SetFreezeState.toObject(message.setFreezeState, options);
                        if (options.oneofs)
                            object.data = "setFreezeState";
                    }
                    if (message.documentOperations != null && message.hasOwnProperty("documentOperations")) {
                        object.documentOperations = $root.m10.sdk.DocumentOperations.toObject(message.documentOperations, options);
                        if (options.oneofs)
                            object.data = "documentOperations";
                    }
                    if (message.invokeAction != null && message.hasOwnProperty("invokeAction")) {
                        object.invokeAction = $root.m10.sdk.transaction.InvokeAction.toObject(message.invokeAction, options);
                        if (options.oneofs)
                            object.data = "invokeAction";
                    }
                    if (message.initiateTransfer != null && message.hasOwnProperty("initiateTransfer")) {
                        object.initiateTransfer = $root.m10.sdk.transaction.CreateTransfer.toObject(message.initiateTransfer, options);
                        if (options.oneofs)
                            object.data = "initiateTransfer";
                    }
                    if (message.commitTransfer != null && message.hasOwnProperty("commitTransfer")) {
                        object.commitTransfer = $root.m10.sdk.transaction.CommitTransfer.toObject(message.commitTransfer, options);
                        if (options.oneofs)
                            object.data = "commitTransfer";
                    }
                    if (message.setInstrument != null && message.hasOwnProperty("setInstrument")) {
                        object.setInstrument = $root.m10.sdk.transaction.SetInstrument.toObject(message.setInstrument, options);
                        if (options.oneofs)
                            object.data = "setInstrument";
                    }
                    return object;
                };

                /**
                 * Converts this TransactionData to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.TransactionData
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransactionData.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TransactionData;
            })();

            transaction.TransactionResponse = (function() {

                /**
                 * Properties of a TransactionResponse.
                 * @memberof m10.sdk.transaction
                 * @interface ITransactionResponse
                 * @property {number|Long|null} [txId] TransactionResponse txId
                 * @property {m10.sdk.transaction.ITransactionError|null} [error] TransactionResponse error
                 * @property {number|Long|null} [timestamp] TransactionResponse timestamp
                 * @property {Uint8Array|null} [accountCreated] TransactionResponse accountCreated
                 * @property {m10.sdk.transaction.ICreateTransfer|null} [transferCommitted] TransactionResponse transferCommitted
                 */

                /**
                 * Constructs a new TransactionResponse.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a TransactionResponse.
                 * @implements ITransactionResponse
                 * @constructor
                 * @param {m10.sdk.transaction.ITransactionResponse=} [properties] Properties to set
                 */
                function TransactionResponse(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransactionResponse txId.
                 * @member {number|Long} txId
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @instance
                 */
                TransactionResponse.prototype.txId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * TransactionResponse error.
                 * @member {m10.sdk.transaction.ITransactionError|null|undefined} error
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @instance
                 */
                TransactionResponse.prototype.error = null;

                /**
                 * TransactionResponse timestamp.
                 * @member {number|Long} timestamp
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @instance
                 */
                TransactionResponse.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TransactionResponse accountCreated.
                 * @member {Uint8Array} accountCreated
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @instance
                 */
                TransactionResponse.prototype.accountCreated = $util.newBuffer([]);

                /**
                 * TransactionResponse transferCommitted.
                 * @member {m10.sdk.transaction.ICreateTransfer|null|undefined} transferCommitted
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @instance
                 */
                TransactionResponse.prototype.transferCommitted = null;

                /**
                 * Creates a new TransactionResponse instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @static
                 * @param {m10.sdk.transaction.ITransactionResponse=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.TransactionResponse} TransactionResponse instance
                 */
                TransactionResponse.create = function create(properties) {
                    return new TransactionResponse(properties);
                };

                /**
                 * Encodes the specified TransactionResponse message. Does not implicitly {@link m10.sdk.transaction.TransactionResponse.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @static
                 * @param {m10.sdk.transaction.ITransactionResponse} message TransactionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionResponse.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.txId);
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.m10.sdk.transaction.TransactionError.encode(message.error, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                    if (message.accountCreated != null && Object.hasOwnProperty.call(message, "accountCreated"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.accountCreated);
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        writer.uint32(/* id 4, wireType 1 =*/33).fixed64(message.timestamp);
                    if (message.transferCommitted != null && Object.hasOwnProperty.call(message, "transferCommitted"))
                        $root.m10.sdk.transaction.CreateTransfer.encode(message.transferCommitted, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TransactionResponse message, length delimited. Does not implicitly {@link m10.sdk.transaction.TransactionResponse.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @static
                 * @param {m10.sdk.transaction.ITransactionResponse} message TransactionResponse message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionResponse.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransactionResponse message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.TransactionResponse} TransactionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionResponse.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.TransactionResponse();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.txId = reader.uint64();
                            break;
                        case 2:
                            message.error = $root.m10.sdk.transaction.TransactionError.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.timestamp = reader.fixed64();
                            break;
                        case 3:
                            message.accountCreated = reader.bytes();
                            break;
                        case 5:
                            message.transferCommitted = $root.m10.sdk.transaction.CreateTransfer.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransactionResponse message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.TransactionResponse} TransactionResponse
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionResponse.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransactionResponse message.
                 * @function verify
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransactionResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.txId != null && message.hasOwnProperty("txId"))
                        if (!$util.isInteger(message.txId) && !(message.txId && $util.isInteger(message.txId.low) && $util.isInteger(message.txId.high)))
                            return "txId: integer|Long expected";
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.m10.sdk.transaction.TransactionError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                            return "timestamp: integer|Long expected";
                    if (message.accountCreated != null && message.hasOwnProperty("accountCreated"))
                        if (!(message.accountCreated && typeof message.accountCreated.length === "number" || $util.isString(message.accountCreated)))
                            return "accountCreated: buffer expected";
                    if (message.transferCommitted != null && message.hasOwnProperty("transferCommitted")) {
                        var error = $root.m10.sdk.transaction.CreateTransfer.verify(message.transferCommitted);
                        if (error)
                            return "transferCommitted." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TransactionResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.TransactionResponse} TransactionResponse
                 */
                TransactionResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.TransactionResponse)
                        return object;
                    var message = new $root.m10.sdk.transaction.TransactionResponse();
                    if (object.txId != null)
                        if ($util.Long)
                            (message.txId = $util.Long.fromValue(object.txId)).unsigned = true;
                        else if (typeof object.txId === "string")
                            message.txId = parseInt(object.txId, 10);
                        else if (typeof object.txId === "number")
                            message.txId = object.txId;
                        else if (typeof object.txId === "object")
                            message.txId = new $util.LongBits(object.txId.low >>> 0, object.txId.high >>> 0).toNumber(true);
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".m10.sdk.transaction.TransactionResponse.error: object expected");
                        message.error = $root.m10.sdk.transaction.TransactionError.fromObject(object.error);
                    }
                    if (object.timestamp != null)
                        if ($util.Long)
                            (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                        else if (typeof object.timestamp === "string")
                            message.timestamp = parseInt(object.timestamp, 10);
                        else if (typeof object.timestamp === "number")
                            message.timestamp = object.timestamp;
                        else if (typeof object.timestamp === "object")
                            message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                    if (object.accountCreated != null)
                        if (typeof object.accountCreated === "string")
                            $util.base64.decode(object.accountCreated, message.accountCreated = $util.newBuffer($util.base64.length(object.accountCreated)), 0);
                        else if (object.accountCreated.length)
                            message.accountCreated = object.accountCreated;
                    if (object.transferCommitted != null) {
                        if (typeof object.transferCommitted !== "object")
                            throw TypeError(".m10.sdk.transaction.TransactionResponse.transferCommitted: object expected");
                        message.transferCommitted = $root.m10.sdk.transaction.CreateTransfer.fromObject(object.transferCommitted);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TransactionResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @static
                 * @param {m10.sdk.transaction.TransactionResponse} message TransactionResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransactionResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.txId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.txId = options.longs === String ? "0" : 0;
                        object.error = null;
                        if (options.bytes === String)
                            object.accountCreated = "";
                        else {
                            object.accountCreated = [];
                            if (options.bytes !== Array)
                                object.accountCreated = $util.newBuffer(object.accountCreated);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timestamp = options.longs === String ? "0" : 0;
                        object.transferCommitted = null;
                    }
                    if (message.txId != null && message.hasOwnProperty("txId"))
                        if (typeof message.txId === "number")
                            object.txId = options.longs === String ? String(message.txId) : message.txId;
                        else
                            object.txId = options.longs === String ? $util.Long.prototype.toString.call(message.txId) : options.longs === Number ? new $util.LongBits(message.txId.low >>> 0, message.txId.high >>> 0).toNumber(true) : message.txId;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.m10.sdk.transaction.TransactionError.toObject(message.error, options);
                    if (message.accountCreated != null && message.hasOwnProperty("accountCreated"))
                        object.accountCreated = options.bytes === String ? $util.base64.encode(message.accountCreated, 0, message.accountCreated.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountCreated) : message.accountCreated;
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if (typeof message.timestamp === "number")
                            object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                        else
                            object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                    if (message.transferCommitted != null && message.hasOwnProperty("transferCommitted"))
                        object.transferCommitted = $root.m10.sdk.transaction.CreateTransfer.toObject(message.transferCommitted, options);
                    return object;
                };

                /**
                 * Converts this TransactionResponse to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.TransactionResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransactionResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TransactionResponse;
            })();

            transaction.TransactionError = (function() {

                /**
                 * Properties of a TransactionError.
                 * @memberof m10.sdk.transaction
                 * @interface ITransactionError
                 * @property {m10.sdk.transaction.TransactionError.Code|null} [code] TransactionError code
                 * @property {string|null} [message] TransactionError message
                 */

                /**
                 * Constructs a new TransactionError.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a TransactionError.
                 * @implements ITransactionError
                 * @constructor
                 * @param {m10.sdk.transaction.ITransactionError=} [properties] Properties to set
                 */
                function TransactionError(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransactionError code.
                 * @member {m10.sdk.transaction.TransactionError.Code} code
                 * @memberof m10.sdk.transaction.TransactionError
                 * @instance
                 */
                TransactionError.prototype.code = 0;

                /**
                 * TransactionError message.
                 * @member {string} message
                 * @memberof m10.sdk.transaction.TransactionError
                 * @instance
                 */
                TransactionError.prototype.message = "";

                /**
                 * Creates a new TransactionError instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.TransactionError
                 * @static
                 * @param {m10.sdk.transaction.ITransactionError=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.TransactionError} TransactionError instance
                 */
                TransactionError.create = function create(properties) {
                    return new TransactionError(properties);
                };

                /**
                 * Encodes the specified TransactionError message. Does not implicitly {@link m10.sdk.transaction.TransactionError.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.TransactionError
                 * @static
                 * @param {m10.sdk.transaction.ITransactionError} message TransactionError message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionError.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.code);
                    if (message.message != null && Object.hasOwnProperty.call(message, "message"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.message);
                    return writer;
                };

                /**
                 * Encodes the specified TransactionError message, length delimited. Does not implicitly {@link m10.sdk.transaction.TransactionError.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.TransactionError
                 * @static
                 * @param {m10.sdk.transaction.ITransactionError} message TransactionError message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransactionError.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransactionError message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.TransactionError
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.TransactionError} TransactionError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionError.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.TransactionError();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.code = reader.int32();
                            break;
                        case 2:
                            message.message = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransactionError message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.TransactionError
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.TransactionError} TransactionError
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransactionError.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransactionError message.
                 * @function verify
                 * @memberof m10.sdk.transaction.TransactionError
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransactionError.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        switch (message.code) {
                        default:
                            return "code: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 10:
                        case 11:
                        case 12:
                        case 20:
                        case 21:
                        case 22:
                        case 23:
                        case 24:
                        case 25:
                        case 26:
                        case 27:
                        case 30:
                            break;
                        }
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    return null;
                };

                /**
                 * Creates a TransactionError message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.TransactionError
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.TransactionError} TransactionError
                 */
                TransactionError.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.TransactionError)
                        return object;
                    var message = new $root.m10.sdk.transaction.TransactionError();
                    switch (object.code) {
                    case "UNKNOWN":
                    case 0:
                        message.code = 0;
                        break;
                    case "UNIMPLEMENTED":
                    case 1:
                        message.code = 1;
                        break;
                    case "NOT_FOUND":
                    case 2:
                        message.code = 2;
                        break;
                    case "ALREADY_EXISTS":
                    case 3:
                        message.code = 3;
                        break;
                    case "UNAUTHORIZED":
                    case 4:
                        message.code = 4;
                        break;
                    case "BAD_REQUEST":
                    case 5:
                        message.code = 5;
                        break;
                    case "INVALID_REQUEST_TYPE":
                    case 6:
                        message.code = 6;
                        break;
                    case "INVALID_ACCOUNT_ID":
                    case 7:
                        message.code = 7;
                        break;
                    case "INVALID_TRANSFER":
                    case 8:
                        message.code = 8;
                        break;
                    case "MESSAGE_TOO_LARGE":
                    case 10:
                        message.code = 10;
                        break;
                    case "INVALID_SIGNATURE":
                    case 11:
                        message.code = 11;
                        break;
                    case "VERIFICATION_FAILED":
                    case 12:
                        message.code = 12;
                        break;
                    case "REPLAY_PROTECTION":
                    case 20:
                        message.code = 20;
                        break;
                    case "INVALID_EXPRESSION":
                    case 21:
                        message.code = 21;
                        break;
                    case "INCORRECT_TYPE":
                    case 22:
                        message.code = 22;
                        break;
                    case "ACCOUNT_FROZEN":
                    case 23:
                        message.code = 23;
                        break;
                    case "UNMODIFIED_STATE":
                    case 24:
                        message.code = 24;
                        break;
                    case "INSUFFICIENT_BALANCE":
                    case 25:
                        message.code = 25;
                        break;
                    case "BALANCE_OVERFLOW":
                    case 26:
                        message.code = 26;
                        break;
                    case "ACCOUNT_DEPTH_EXCEEDED":
                    case 27:
                        message.code = 27;
                        break;
                    case "INVALID_TARGET":
                    case 30:
                        message.code = 30;
                        break;
                    }
                    if (object.message != null)
                        message.message = String(object.message);
                    return message;
                };

                /**
                 * Creates a plain object from a TransactionError message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.TransactionError
                 * @static
                 * @param {m10.sdk.transaction.TransactionError} message TransactionError
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransactionError.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.code = options.enums === String ? "UNKNOWN" : 0;
                        object.message = "";
                    }
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = options.enums === String ? $root.m10.sdk.transaction.TransactionError.Code[message.code] : message.code;
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    return object;
                };

                /**
                 * Converts this TransactionError to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.TransactionError
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransactionError.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Code enum.
                 * @name m10.sdk.transaction.TransactionError.Code
                 * @enum {number}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} UNIMPLEMENTED=1 UNIMPLEMENTED value
                 * @property {number} NOT_FOUND=2 NOT_FOUND value
                 * @property {number} ALREADY_EXISTS=3 ALREADY_EXISTS value
                 * @property {number} UNAUTHORIZED=4 UNAUTHORIZED value
                 * @property {number} BAD_REQUEST=5 BAD_REQUEST value
                 * @property {number} INVALID_REQUEST_TYPE=6 INVALID_REQUEST_TYPE value
                 * @property {number} INVALID_ACCOUNT_ID=7 INVALID_ACCOUNT_ID value
                 * @property {number} INVALID_TRANSFER=8 INVALID_TRANSFER value
                 * @property {number} MESSAGE_TOO_LARGE=10 MESSAGE_TOO_LARGE value
                 * @property {number} INVALID_SIGNATURE=11 INVALID_SIGNATURE value
                 * @property {number} VERIFICATION_FAILED=12 VERIFICATION_FAILED value
                 * @property {number} REPLAY_PROTECTION=20 REPLAY_PROTECTION value
                 * @property {number} INVALID_EXPRESSION=21 INVALID_EXPRESSION value
                 * @property {number} INCORRECT_TYPE=22 INCORRECT_TYPE value
                 * @property {number} ACCOUNT_FROZEN=23 ACCOUNT_FROZEN value
                 * @property {number} UNMODIFIED_STATE=24 UNMODIFIED_STATE value
                 * @property {number} INSUFFICIENT_BALANCE=25 INSUFFICIENT_BALANCE value
                 * @property {number} BALANCE_OVERFLOW=26 BALANCE_OVERFLOW value
                 * @property {number} ACCOUNT_DEPTH_EXCEEDED=27 ACCOUNT_DEPTH_EXCEEDED value
                 * @property {number} INVALID_TARGET=30 INVALID_TARGET value
                 */
                TransactionError.Code = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "UNIMPLEMENTED"] = 1;
                    values[valuesById[2] = "NOT_FOUND"] = 2;
                    values[valuesById[3] = "ALREADY_EXISTS"] = 3;
                    values[valuesById[4] = "UNAUTHORIZED"] = 4;
                    values[valuesById[5] = "BAD_REQUEST"] = 5;
                    values[valuesById[6] = "INVALID_REQUEST_TYPE"] = 6;
                    values[valuesById[7] = "INVALID_ACCOUNT_ID"] = 7;
                    values[valuesById[8] = "INVALID_TRANSFER"] = 8;
                    values[valuesById[10] = "MESSAGE_TOO_LARGE"] = 10;
                    values[valuesById[11] = "INVALID_SIGNATURE"] = 11;
                    values[valuesById[12] = "VERIFICATION_FAILED"] = 12;
                    values[valuesById[20] = "REPLAY_PROTECTION"] = 20;
                    values[valuesById[21] = "INVALID_EXPRESSION"] = 21;
                    values[valuesById[22] = "INCORRECT_TYPE"] = 22;
                    values[valuesById[23] = "ACCOUNT_FROZEN"] = 23;
                    values[valuesById[24] = "UNMODIFIED_STATE"] = 24;
                    values[valuesById[25] = "INSUFFICIENT_BALANCE"] = 25;
                    values[valuesById[26] = "BALANCE_OVERFLOW"] = 26;
                    values[valuesById[27] = "ACCOUNT_DEPTH_EXCEEDED"] = 27;
                    values[valuesById[30] = "INVALID_TARGET"] = 30;
                    return values;
                })();

                return TransactionError;
            })();

            transaction.CreateLedgerTransfer = (function() {

                /**
                 * Properties of a CreateLedgerTransfer.
                 * @memberof m10.sdk.transaction
                 * @interface ICreateLedgerTransfer
                 * @property {string|null} [ledgerId] CreateLedgerTransfer ledgerId
                 * @property {number|Long|null} [nonce] CreateLedgerTransfer nonce
                 * @property {m10.sdk.transaction.ICreateTransfer|null} [transfer] CreateLedgerTransfer transfer
                 */

                /**
                 * Constructs a new CreateLedgerTransfer.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a CreateLedgerTransfer.
                 * @implements ICreateLedgerTransfer
                 * @constructor
                 * @param {m10.sdk.transaction.ICreateLedgerTransfer=} [properties] Properties to set
                 */
                function CreateLedgerTransfer(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateLedgerTransfer ledgerId.
                 * @member {string} ledgerId
                 * @memberof m10.sdk.transaction.CreateLedgerTransfer
                 * @instance
                 */
                CreateLedgerTransfer.prototype.ledgerId = "";

                /**
                 * CreateLedgerTransfer nonce.
                 * @member {number|Long} nonce
                 * @memberof m10.sdk.transaction.CreateLedgerTransfer
                 * @instance
                 */
                CreateLedgerTransfer.prototype.nonce = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * CreateLedgerTransfer transfer.
                 * @member {m10.sdk.transaction.ICreateTransfer|null|undefined} transfer
                 * @memberof m10.sdk.transaction.CreateLedgerTransfer
                 * @instance
                 */
                CreateLedgerTransfer.prototype.transfer = null;

                /**
                 * Creates a new CreateLedgerTransfer instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.CreateLedgerTransfer
                 * @static
                 * @param {m10.sdk.transaction.ICreateLedgerTransfer=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.CreateLedgerTransfer} CreateLedgerTransfer instance
                 */
                CreateLedgerTransfer.create = function create(properties) {
                    return new CreateLedgerTransfer(properties);
                };

                /**
                 * Encodes the specified CreateLedgerTransfer message. Does not implicitly {@link m10.sdk.transaction.CreateLedgerTransfer.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.CreateLedgerTransfer
                 * @static
                 * @param {m10.sdk.transaction.ICreateLedgerTransfer} message CreateLedgerTransfer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateLedgerTransfer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.ledgerId != null && Object.hasOwnProperty.call(message, "ledgerId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.ledgerId);
                    if (message.nonce != null && Object.hasOwnProperty.call(message, "nonce"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nonce);
                    if (message.transfer != null && Object.hasOwnProperty.call(message, "transfer"))
                        $root.m10.sdk.transaction.CreateTransfer.encode(message.transfer, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CreateLedgerTransfer message, length delimited. Does not implicitly {@link m10.sdk.transaction.CreateLedgerTransfer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.CreateLedgerTransfer
                 * @static
                 * @param {m10.sdk.transaction.ICreateLedgerTransfer} message CreateLedgerTransfer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateLedgerTransfer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CreateLedgerTransfer message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.CreateLedgerTransfer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.CreateLedgerTransfer} CreateLedgerTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateLedgerTransfer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.CreateLedgerTransfer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.ledgerId = reader.string();
                            break;
                        case 2:
                            message.nonce = reader.uint64();
                            break;
                        case 3:
                            message.transfer = $root.m10.sdk.transaction.CreateTransfer.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CreateLedgerTransfer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.CreateLedgerTransfer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.CreateLedgerTransfer} CreateLedgerTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateLedgerTransfer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CreateLedgerTransfer message.
                 * @function verify
                 * @memberof m10.sdk.transaction.CreateLedgerTransfer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateLedgerTransfer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.ledgerId != null && message.hasOwnProperty("ledgerId"))
                        if (!$util.isString(message.ledgerId))
                            return "ledgerId: string expected";
                    if (message.nonce != null && message.hasOwnProperty("nonce"))
                        if (!$util.isInteger(message.nonce) && !(message.nonce && $util.isInteger(message.nonce.low) && $util.isInteger(message.nonce.high)))
                            return "nonce: integer|Long expected";
                    if (message.transfer != null && message.hasOwnProperty("transfer")) {
                        var error = $root.m10.sdk.transaction.CreateTransfer.verify(message.transfer);
                        if (error)
                            return "transfer." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CreateLedgerTransfer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.CreateLedgerTransfer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.CreateLedgerTransfer} CreateLedgerTransfer
                 */
                CreateLedgerTransfer.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.CreateLedgerTransfer)
                        return object;
                    var message = new $root.m10.sdk.transaction.CreateLedgerTransfer();
                    if (object.ledgerId != null)
                        message.ledgerId = String(object.ledgerId);
                    if (object.nonce != null)
                        if ($util.Long)
                            (message.nonce = $util.Long.fromValue(object.nonce)).unsigned = true;
                        else if (typeof object.nonce === "string")
                            message.nonce = parseInt(object.nonce, 10);
                        else if (typeof object.nonce === "number")
                            message.nonce = object.nonce;
                        else if (typeof object.nonce === "object")
                            message.nonce = new $util.LongBits(object.nonce.low >>> 0, object.nonce.high >>> 0).toNumber(true);
                    if (object.transfer != null) {
                        if (typeof object.transfer !== "object")
                            throw TypeError(".m10.sdk.transaction.CreateLedgerTransfer.transfer: object expected");
                        message.transfer = $root.m10.sdk.transaction.CreateTransfer.fromObject(object.transfer);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateLedgerTransfer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.CreateLedgerTransfer
                 * @static
                 * @param {m10.sdk.transaction.CreateLedgerTransfer} message CreateLedgerTransfer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateLedgerTransfer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.ledgerId = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.nonce = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.nonce = options.longs === String ? "0" : 0;
                        object.transfer = null;
                    }
                    if (message.ledgerId != null && message.hasOwnProperty("ledgerId"))
                        object.ledgerId = message.ledgerId;
                    if (message.nonce != null && message.hasOwnProperty("nonce"))
                        if (typeof message.nonce === "number")
                            object.nonce = options.longs === String ? String(message.nonce) : message.nonce;
                        else
                            object.nonce = options.longs === String ? $util.Long.prototype.toString.call(message.nonce) : options.longs === Number ? new $util.LongBits(message.nonce.low >>> 0, message.nonce.high >>> 0).toNumber(true) : message.nonce;
                    if (message.transfer != null && message.hasOwnProperty("transfer"))
                        object.transfer = $root.m10.sdk.transaction.CreateTransfer.toObject(message.transfer, options);
                    return object;
                };

                /**
                 * Converts this CreateLedgerTransfer to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.CreateLedgerTransfer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateLedgerTransfer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateLedgerTransfer;
            })();

            transaction.CreateLedgerTransfers = (function() {

                /**
                 * Properties of a CreateLedgerTransfers.
                 * @memberof m10.sdk.transaction
                 * @interface ICreateLedgerTransfers
                 * @property {Array.<m10.sdk.transaction.ICreateLedgerTransfer>|null} [transfers] CreateLedgerTransfers transfers
                 * @property {number|Long|null} [validUntil] CreateLedgerTransfers validUntil
                 */

                /**
                 * Constructs a new CreateLedgerTransfers.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a CreateLedgerTransfers.
                 * @implements ICreateLedgerTransfers
                 * @constructor
                 * @param {m10.sdk.transaction.ICreateLedgerTransfers=} [properties] Properties to set
                 */
                function CreateLedgerTransfers(properties) {
                    this.transfers = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateLedgerTransfers transfers.
                 * @member {Array.<m10.sdk.transaction.ICreateLedgerTransfer>} transfers
                 * @memberof m10.sdk.transaction.CreateLedgerTransfers
                 * @instance
                 */
                CreateLedgerTransfers.prototype.transfers = $util.emptyArray;

                /**
                 * CreateLedgerTransfers validUntil.
                 * @member {number|Long} validUntil
                 * @memberof m10.sdk.transaction.CreateLedgerTransfers
                 * @instance
                 */
                CreateLedgerTransfers.prototype.validUntil = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new CreateLedgerTransfers instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.CreateLedgerTransfers
                 * @static
                 * @param {m10.sdk.transaction.ICreateLedgerTransfers=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.CreateLedgerTransfers} CreateLedgerTransfers instance
                 */
                CreateLedgerTransfers.create = function create(properties) {
                    return new CreateLedgerTransfers(properties);
                };

                /**
                 * Encodes the specified CreateLedgerTransfers message. Does not implicitly {@link m10.sdk.transaction.CreateLedgerTransfers.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.CreateLedgerTransfers
                 * @static
                 * @param {m10.sdk.transaction.ICreateLedgerTransfers} message CreateLedgerTransfers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateLedgerTransfers.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transfers != null && message.transfers.length)
                        for (var i = 0; i < message.transfers.length; ++i)
                            $root.m10.sdk.transaction.CreateLedgerTransfer.encode(message.transfers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    if (message.validUntil != null && Object.hasOwnProperty.call(message, "validUntil"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.validUntil);
                    return writer;
                };

                /**
                 * Encodes the specified CreateLedgerTransfers message, length delimited. Does not implicitly {@link m10.sdk.transaction.CreateLedgerTransfers.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.CreateLedgerTransfers
                 * @static
                 * @param {m10.sdk.transaction.ICreateLedgerTransfers} message CreateLedgerTransfers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateLedgerTransfers.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CreateLedgerTransfers message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.CreateLedgerTransfers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.CreateLedgerTransfers} CreateLedgerTransfers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateLedgerTransfers.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.CreateLedgerTransfers();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.transfers && message.transfers.length))
                                message.transfers = [];
                            message.transfers.push($root.m10.sdk.transaction.CreateLedgerTransfer.decode(reader, reader.uint32()));
                            break;
                        case 2:
                            message.validUntil = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CreateLedgerTransfers message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.CreateLedgerTransfers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.CreateLedgerTransfers} CreateLedgerTransfers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateLedgerTransfers.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CreateLedgerTransfers message.
                 * @function verify
                 * @memberof m10.sdk.transaction.CreateLedgerTransfers
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateLedgerTransfers.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.transfers != null && message.hasOwnProperty("transfers")) {
                        if (!Array.isArray(message.transfers))
                            return "transfers: array expected";
                        for (var i = 0; i < message.transfers.length; ++i) {
                            var error = $root.m10.sdk.transaction.CreateLedgerTransfer.verify(message.transfers[i]);
                            if (error)
                                return "transfers." + error;
                        }
                    }
                    if (message.validUntil != null && message.hasOwnProperty("validUntil"))
                        if (!$util.isInteger(message.validUntil) && !(message.validUntil && $util.isInteger(message.validUntil.low) && $util.isInteger(message.validUntil.high)))
                            return "validUntil: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a CreateLedgerTransfers message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.CreateLedgerTransfers
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.CreateLedgerTransfers} CreateLedgerTransfers
                 */
                CreateLedgerTransfers.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.CreateLedgerTransfers)
                        return object;
                    var message = new $root.m10.sdk.transaction.CreateLedgerTransfers();
                    if (object.transfers) {
                        if (!Array.isArray(object.transfers))
                            throw TypeError(".m10.sdk.transaction.CreateLedgerTransfers.transfers: array expected");
                        message.transfers = [];
                        for (var i = 0; i < object.transfers.length; ++i) {
                            if (typeof object.transfers[i] !== "object")
                                throw TypeError(".m10.sdk.transaction.CreateLedgerTransfers.transfers: object expected");
                            message.transfers[i] = $root.m10.sdk.transaction.CreateLedgerTransfer.fromObject(object.transfers[i]);
                        }
                    }
                    if (object.validUntil != null)
                        if ($util.Long)
                            (message.validUntil = $util.Long.fromValue(object.validUntil)).unsigned = true;
                        else if (typeof object.validUntil === "string")
                            message.validUntil = parseInt(object.validUntil, 10);
                        else if (typeof object.validUntil === "number")
                            message.validUntil = object.validUntil;
                        else if (typeof object.validUntil === "object")
                            message.validUntil = new $util.LongBits(object.validUntil.low >>> 0, object.validUntil.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a CreateLedgerTransfers message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.CreateLedgerTransfers
                 * @static
                 * @param {m10.sdk.transaction.CreateLedgerTransfers} message CreateLedgerTransfers
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateLedgerTransfers.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.transfers = [];
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.validUntil = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.validUntil = options.longs === String ? "0" : 0;
                    if (message.transfers && message.transfers.length) {
                        object.transfers = [];
                        for (var j = 0; j < message.transfers.length; ++j)
                            object.transfers[j] = $root.m10.sdk.transaction.CreateLedgerTransfer.toObject(message.transfers[j], options);
                    }
                    if (message.validUntil != null && message.hasOwnProperty("validUntil"))
                        if (typeof message.validUntil === "number")
                            object.validUntil = options.longs === String ? String(message.validUntil) : message.validUntil;
                        else
                            object.validUntil = options.longs === String ? $util.Long.prototype.toString.call(message.validUntil) : options.longs === Number ? new $util.LongBits(message.validUntil.low >>> 0, message.validUntil.high >>> 0).toNumber(true) : message.validUntil;
                    return object;
                };

                /**
                 * Converts this CreateLedgerTransfers to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.CreateLedgerTransfers
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateLedgerTransfers.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateLedgerTransfers;
            })();

            transaction.GetTransferRequest = (function() {

                /**
                 * Properties of a GetTransferRequest.
                 * @memberof m10.sdk.transaction
                 * @interface IGetTransferRequest
                 * @property {number|Long|null} [txId] GetTransferRequest txId
                 */

                /**
                 * Constructs a new GetTransferRequest.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a GetTransferRequest.
                 * @implements IGetTransferRequest
                 * @constructor
                 * @param {m10.sdk.transaction.IGetTransferRequest=} [properties] Properties to set
                 */
                function GetTransferRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetTransferRequest txId.
                 * @member {number|Long} txId
                 * @memberof m10.sdk.transaction.GetTransferRequest
                 * @instance
                 */
                GetTransferRequest.prototype.txId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new GetTransferRequest instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.GetTransferRequest
                 * @static
                 * @param {m10.sdk.transaction.IGetTransferRequest=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.GetTransferRequest} GetTransferRequest instance
                 */
                GetTransferRequest.create = function create(properties) {
                    return new GetTransferRequest(properties);
                };

                /**
                 * Encodes the specified GetTransferRequest message. Does not implicitly {@link m10.sdk.transaction.GetTransferRequest.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.GetTransferRequest
                 * @static
                 * @param {m10.sdk.transaction.IGetTransferRequest} message GetTransferRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetTransferRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.txId);
                    return writer;
                };

                /**
                 * Encodes the specified GetTransferRequest message, length delimited. Does not implicitly {@link m10.sdk.transaction.GetTransferRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.GetTransferRequest
                 * @static
                 * @param {m10.sdk.transaction.IGetTransferRequest} message GetTransferRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetTransferRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetTransferRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.GetTransferRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.GetTransferRequest} GetTransferRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetTransferRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.GetTransferRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.txId = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GetTransferRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.GetTransferRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.GetTransferRequest} GetTransferRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetTransferRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetTransferRequest message.
                 * @function verify
                 * @memberof m10.sdk.transaction.GetTransferRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetTransferRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.txId != null && message.hasOwnProperty("txId"))
                        if (!$util.isInteger(message.txId) && !(message.txId && $util.isInteger(message.txId.low) && $util.isInteger(message.txId.high)))
                            return "txId: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a GetTransferRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.GetTransferRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.GetTransferRequest} GetTransferRequest
                 */
                GetTransferRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.GetTransferRequest)
                        return object;
                    var message = new $root.m10.sdk.transaction.GetTransferRequest();
                    if (object.txId != null)
                        if ($util.Long)
                            (message.txId = $util.Long.fromValue(object.txId)).unsigned = true;
                        else if (typeof object.txId === "string")
                            message.txId = parseInt(object.txId, 10);
                        else if (typeof object.txId === "number")
                            message.txId = object.txId;
                        else if (typeof object.txId === "object")
                            message.txId = new $util.LongBits(object.txId.low >>> 0, object.txId.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a GetTransferRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.GetTransferRequest
                 * @static
                 * @param {m10.sdk.transaction.GetTransferRequest} message GetTransferRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetTransferRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.txId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.txId = options.longs === String ? "0" : 0;
                    if (message.txId != null && message.hasOwnProperty("txId"))
                        if (typeof message.txId === "number")
                            object.txId = options.longs === String ? String(message.txId) : message.txId;
                        else
                            object.txId = options.longs === String ? $util.Long.prototype.toString.call(message.txId) : options.longs === Number ? new $util.LongBits(message.txId.low >>> 0, message.txId.high >>> 0).toNumber(true) : message.txId;
                    return object;
                };

                /**
                 * Converts this GetTransferRequest to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.GetTransferRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetTransferRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetTransferRequest;
            })();

            transaction.ListTransferRequest = (function() {

                /**
                 * Properties of a ListTransferRequest.
                 * @memberof m10.sdk.transaction
                 * @interface IListTransferRequest
                 * @property {Uint8Array|null} [accountId] ListTransferRequest accountId
                 * @property {Uint8Array|null} [contextId] ListTransferRequest contextId
                 * @property {number|Long|null} [limit] ListTransferRequest limit
                 * @property {boolean|null} [includeChildAccounts] ListTransferRequest includeChildAccounts
                 * @property {number|Long|null} [minTxId] ListTransferRequest minTxId
                 * @property {number|Long|null} [maxTxId] ListTransferRequest maxTxId
                 */

                /**
                 * Constructs a new ListTransferRequest.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a ListTransferRequest.
                 * @implements IListTransferRequest
                 * @constructor
                 * @param {m10.sdk.transaction.IListTransferRequest=} [properties] Properties to set
                 */
                function ListTransferRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListTransferRequest accountId.
                 * @member {Uint8Array|null|undefined} accountId
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @instance
                 */
                ListTransferRequest.prototype.accountId = null;

                /**
                 * ListTransferRequest contextId.
                 * @member {Uint8Array|null|undefined} contextId
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @instance
                 */
                ListTransferRequest.prototype.contextId = null;

                /**
                 * ListTransferRequest limit.
                 * @member {number|Long} limit
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @instance
                 */
                ListTransferRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ListTransferRequest includeChildAccounts.
                 * @member {boolean} includeChildAccounts
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @instance
                 */
                ListTransferRequest.prototype.includeChildAccounts = false;

                /**
                 * ListTransferRequest minTxId.
                 * @member {number|Long} minTxId
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @instance
                 */
                ListTransferRequest.prototype.minTxId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ListTransferRequest maxTxId.
                 * @member {number|Long} maxTxId
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @instance
                 */
                ListTransferRequest.prototype.maxTxId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * ListTransferRequest filter.
                 * @member {"accountId"|"contextId"|undefined} filter
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @instance
                 */
                Object.defineProperty(ListTransferRequest.prototype, "filter", {
                    get: $util.oneOfGetter($oneOfFields = ["accountId", "contextId"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new ListTransferRequest instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @static
                 * @param {m10.sdk.transaction.IListTransferRequest=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.ListTransferRequest} ListTransferRequest instance
                 */
                ListTransferRequest.create = function create(properties) {
                    return new ListTransferRequest(properties);
                };

                /**
                 * Encodes the specified ListTransferRequest message. Does not implicitly {@link m10.sdk.transaction.ListTransferRequest.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @static
                 * @param {m10.sdk.transaction.IListTransferRequest} message ListTransferRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListTransferRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountId);
                    if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contextId);
                    if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.limit);
                    if (message.includeChildAccounts != null && Object.hasOwnProperty.call(message, "includeChildAccounts"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.includeChildAccounts);
                    if (message.minTxId != null && Object.hasOwnProperty.call(message, "minTxId"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.minTxId);
                    if (message.maxTxId != null && Object.hasOwnProperty.call(message, "maxTxId"))
                        writer.uint32(/* id 7, wireType 0 =*/56).uint64(message.maxTxId);
                    return writer;
                };

                /**
                 * Encodes the specified ListTransferRequest message, length delimited. Does not implicitly {@link m10.sdk.transaction.ListTransferRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @static
                 * @param {m10.sdk.transaction.IListTransferRequest} message ListTransferRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListTransferRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ListTransferRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.ListTransferRequest} ListTransferRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListTransferRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.ListTransferRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.accountId = reader.bytes();
                            break;
                        case 2:
                            message.contextId = reader.bytes();
                            break;
                        case 4:
                            message.limit = reader.uint64();
                            break;
                        case 5:
                            message.includeChildAccounts = reader.bool();
                            break;
                        case 6:
                            message.minTxId = reader.uint64();
                            break;
                        case 7:
                            message.maxTxId = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ListTransferRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.ListTransferRequest} ListTransferRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListTransferRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ListTransferRequest message.
                 * @function verify
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListTransferRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.accountId != null && message.hasOwnProperty("accountId")) {
                        properties.filter = 1;
                        if (!(message.accountId && typeof message.accountId.length === "number" || $util.isString(message.accountId)))
                            return "accountId: buffer expected";
                    }
                    if (message.contextId != null && message.hasOwnProperty("contextId")) {
                        if (properties.filter === 1)
                            return "filter: multiple values";
                        properties.filter = 1;
                        if (!(message.contextId && typeof message.contextId.length === "number" || $util.isString(message.contextId)))
                            return "contextId: buffer expected";
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                            return "limit: integer|Long expected";
                    if (message.includeChildAccounts != null && message.hasOwnProperty("includeChildAccounts"))
                        if (typeof message.includeChildAccounts !== "boolean")
                            return "includeChildAccounts: boolean expected";
                    if (message.minTxId != null && message.hasOwnProperty("minTxId"))
                        if (!$util.isInteger(message.minTxId) && !(message.minTxId && $util.isInteger(message.minTxId.low) && $util.isInteger(message.minTxId.high)))
                            return "minTxId: integer|Long expected";
                    if (message.maxTxId != null && message.hasOwnProperty("maxTxId"))
                        if (!$util.isInteger(message.maxTxId) && !(message.maxTxId && $util.isInteger(message.maxTxId.low) && $util.isInteger(message.maxTxId.high)))
                            return "maxTxId: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ListTransferRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.ListTransferRequest} ListTransferRequest
                 */
                ListTransferRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.ListTransferRequest)
                        return object;
                    var message = new $root.m10.sdk.transaction.ListTransferRequest();
                    if (object.accountId != null)
                        if (typeof object.accountId === "string")
                            $util.base64.decode(object.accountId, message.accountId = $util.newBuffer($util.base64.length(object.accountId)), 0);
                        else if (object.accountId.length)
                            message.accountId = object.accountId;
                    if (object.contextId != null)
                        if (typeof object.contextId === "string")
                            $util.base64.decode(object.contextId, message.contextId = $util.newBuffer($util.base64.length(object.contextId)), 0);
                        else if (object.contextId.length)
                            message.contextId = object.contextId;
                    if (object.limit != null)
                        if ($util.Long)
                            (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                        else if (typeof object.limit === "string")
                            message.limit = parseInt(object.limit, 10);
                        else if (typeof object.limit === "number")
                            message.limit = object.limit;
                        else if (typeof object.limit === "object")
                            message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                    if (object.includeChildAccounts != null)
                        message.includeChildAccounts = Boolean(object.includeChildAccounts);
                    if (object.minTxId != null)
                        if ($util.Long)
                            (message.minTxId = $util.Long.fromValue(object.minTxId)).unsigned = true;
                        else if (typeof object.minTxId === "string")
                            message.minTxId = parseInt(object.minTxId, 10);
                        else if (typeof object.minTxId === "number")
                            message.minTxId = object.minTxId;
                        else if (typeof object.minTxId === "object")
                            message.minTxId = new $util.LongBits(object.minTxId.low >>> 0, object.minTxId.high >>> 0).toNumber(true);
                    if (object.maxTxId != null)
                        if ($util.Long)
                            (message.maxTxId = $util.Long.fromValue(object.maxTxId)).unsigned = true;
                        else if (typeof object.maxTxId === "string")
                            message.maxTxId = parseInt(object.maxTxId, 10);
                        else if (typeof object.maxTxId === "number")
                            message.maxTxId = object.maxTxId;
                        else if (typeof object.maxTxId === "object")
                            message.maxTxId = new $util.LongBits(object.maxTxId.low >>> 0, object.maxTxId.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a ListTransferRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @static
                 * @param {m10.sdk.transaction.ListTransferRequest} message ListTransferRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListTransferRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.limit = options.longs === String ? "0" : 0;
                        object.includeChildAccounts = false;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.minTxId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.minTxId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.maxTxId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.maxTxId = options.longs === String ? "0" : 0;
                    }
                    if (message.accountId != null && message.hasOwnProperty("accountId")) {
                        object.accountId = options.bytes === String ? $util.base64.encode(message.accountId, 0, message.accountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountId) : message.accountId;
                        if (options.oneofs)
                            object.filter = "accountId";
                    }
                    if (message.contextId != null && message.hasOwnProperty("contextId")) {
                        object.contextId = options.bytes === String ? $util.base64.encode(message.contextId, 0, message.contextId.length) : options.bytes === Array ? Array.prototype.slice.call(message.contextId) : message.contextId;
                        if (options.oneofs)
                            object.filter = "contextId";
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (typeof message.limit === "number")
                            object.limit = options.longs === String ? String(message.limit) : message.limit;
                        else
                            object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                    if (message.includeChildAccounts != null && message.hasOwnProperty("includeChildAccounts"))
                        object.includeChildAccounts = message.includeChildAccounts;
                    if (message.minTxId != null && message.hasOwnProperty("minTxId"))
                        if (typeof message.minTxId === "number")
                            object.minTxId = options.longs === String ? String(message.minTxId) : message.minTxId;
                        else
                            object.minTxId = options.longs === String ? $util.Long.prototype.toString.call(message.minTxId) : options.longs === Number ? new $util.LongBits(message.minTxId.low >>> 0, message.minTxId.high >>> 0).toNumber(true) : message.minTxId;
                    if (message.maxTxId != null && message.hasOwnProperty("maxTxId"))
                        if (typeof message.maxTxId === "number")
                            object.maxTxId = options.longs === String ? String(message.maxTxId) : message.maxTxId;
                        else
                            object.maxTxId = options.longs === String ? $util.Long.prototype.toString.call(message.maxTxId) : options.longs === Number ? new $util.LongBits(message.maxTxId.low >>> 0, message.maxTxId.high >>> 0).toNumber(true) : message.maxTxId;
                    return object;
                };

                /**
                 * Converts this ListTransferRequest to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.ListTransferRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListTransferRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListTransferRequest;
            })();

            transaction.CreateTransfer = (function() {

                /**
                 * Properties of a CreateTransfer.
                 * @memberof m10.sdk.transaction
                 * @interface ICreateTransfer
                 * @property {Array.<m10.sdk.transaction.ITransferStep>|null} [transferSteps] CreateTransfer transferSteps
                 */

                /**
                 * Constructs a new CreateTransfer.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a CreateTransfer.
                 * @implements ICreateTransfer
                 * @constructor
                 * @param {m10.sdk.transaction.ICreateTransfer=} [properties] Properties to set
                 */
                function CreateTransfer(properties) {
                    this.transferSteps = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateTransfer transferSteps.
                 * @member {Array.<m10.sdk.transaction.ITransferStep>} transferSteps
                 * @memberof m10.sdk.transaction.CreateTransfer
                 * @instance
                 */
                CreateTransfer.prototype.transferSteps = $util.emptyArray;

                /**
                 * Creates a new CreateTransfer instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.CreateTransfer
                 * @static
                 * @param {m10.sdk.transaction.ICreateTransfer=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.CreateTransfer} CreateTransfer instance
                 */
                CreateTransfer.create = function create(properties) {
                    return new CreateTransfer(properties);
                };

                /**
                 * Encodes the specified CreateTransfer message. Does not implicitly {@link m10.sdk.transaction.CreateTransfer.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.CreateTransfer
                 * @static
                 * @param {m10.sdk.transaction.ICreateTransfer} message CreateTransfer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateTransfer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transferSteps != null && message.transferSteps.length)
                        for (var i = 0; i < message.transferSteps.length; ++i)
                            $root.m10.sdk.transaction.TransferStep.encode(message.transferSteps[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CreateTransfer message, length delimited. Does not implicitly {@link m10.sdk.transaction.CreateTransfer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.CreateTransfer
                 * @static
                 * @param {m10.sdk.transaction.ICreateTransfer} message CreateTransfer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateTransfer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CreateTransfer message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.CreateTransfer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.CreateTransfer} CreateTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateTransfer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.CreateTransfer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.transferSteps && message.transferSteps.length))
                                message.transferSteps = [];
                            message.transferSteps.push($root.m10.sdk.transaction.TransferStep.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CreateTransfer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.CreateTransfer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.CreateTransfer} CreateTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateTransfer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CreateTransfer message.
                 * @function verify
                 * @memberof m10.sdk.transaction.CreateTransfer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateTransfer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.transferSteps != null && message.hasOwnProperty("transferSteps")) {
                        if (!Array.isArray(message.transferSteps))
                            return "transferSteps: array expected";
                        for (var i = 0; i < message.transferSteps.length; ++i) {
                            var error = $root.m10.sdk.transaction.TransferStep.verify(message.transferSteps[i]);
                            if (error)
                                return "transferSteps." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CreateTransfer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.CreateTransfer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.CreateTransfer} CreateTransfer
                 */
                CreateTransfer.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.CreateTransfer)
                        return object;
                    var message = new $root.m10.sdk.transaction.CreateTransfer();
                    if (object.transferSteps) {
                        if (!Array.isArray(object.transferSteps))
                            throw TypeError(".m10.sdk.transaction.CreateTransfer.transferSteps: array expected");
                        message.transferSteps = [];
                        for (var i = 0; i < object.transferSteps.length; ++i) {
                            if (typeof object.transferSteps[i] !== "object")
                                throw TypeError(".m10.sdk.transaction.CreateTransfer.transferSteps: object expected");
                            message.transferSteps[i] = $root.m10.sdk.transaction.TransferStep.fromObject(object.transferSteps[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateTransfer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.CreateTransfer
                 * @static
                 * @param {m10.sdk.transaction.CreateTransfer} message CreateTransfer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateTransfer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.transferSteps = [];
                    if (message.transferSteps && message.transferSteps.length) {
                        object.transferSteps = [];
                        for (var j = 0; j < message.transferSteps.length; ++j)
                            object.transferSteps[j] = $root.m10.sdk.transaction.TransferStep.toObject(message.transferSteps[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this CreateTransfer to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.CreateTransfer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateTransfer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateTransfer;
            })();

            transaction.TransferStep = (function() {

                /**
                 * Properties of a TransferStep.
                 * @memberof m10.sdk.transaction
                 * @interface ITransferStep
                 * @property {Uint8Array|null} [fromAccountId] TransferStep fromAccountId
                 * @property {Uint8Array|null} [toAccountId] TransferStep toAccountId
                 * @property {number|Long|null} [amount] TransferStep amount
                 * @property {Array.<google.protobuf.IAny>|null} [metadata] TransferStep metadata
                 */

                /**
                 * Constructs a new TransferStep.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a TransferStep.
                 * @implements ITransferStep
                 * @constructor
                 * @param {m10.sdk.transaction.ITransferStep=} [properties] Properties to set
                 */
                function TransferStep(properties) {
                    this.metadata = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TransferStep fromAccountId.
                 * @member {Uint8Array} fromAccountId
                 * @memberof m10.sdk.transaction.TransferStep
                 * @instance
                 */
                TransferStep.prototype.fromAccountId = $util.newBuffer([]);

                /**
                 * TransferStep toAccountId.
                 * @member {Uint8Array} toAccountId
                 * @memberof m10.sdk.transaction.TransferStep
                 * @instance
                 */
                TransferStep.prototype.toAccountId = $util.newBuffer([]);

                /**
                 * TransferStep amount.
                 * @member {number|Long} amount
                 * @memberof m10.sdk.transaction.TransferStep
                 * @instance
                 */
                TransferStep.prototype.amount = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * TransferStep metadata.
                 * @member {Array.<google.protobuf.IAny>} metadata
                 * @memberof m10.sdk.transaction.TransferStep
                 * @instance
                 */
                TransferStep.prototype.metadata = $util.emptyArray;

                /**
                 * Creates a new TransferStep instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.TransferStep
                 * @static
                 * @param {m10.sdk.transaction.ITransferStep=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.TransferStep} TransferStep instance
                 */
                TransferStep.create = function create(properties) {
                    return new TransferStep(properties);
                };

                /**
                 * Encodes the specified TransferStep message. Does not implicitly {@link m10.sdk.transaction.TransferStep.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.TransferStep
                 * @static
                 * @param {m10.sdk.transaction.ITransferStep} message TransferStep message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransferStep.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.fromAccountId != null && Object.hasOwnProperty.call(message, "fromAccountId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.fromAccountId);
                    if (message.toAccountId != null && Object.hasOwnProperty.call(message, "toAccountId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.toAccountId);
                    if (message.amount != null && Object.hasOwnProperty.call(message, "amount"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.amount);
                    if (message.metadata != null && message.metadata.length)
                        for (var i = 0; i < message.metadata.length; ++i)
                            $root.google.protobuf.Any.encode(message.metadata[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified TransferStep message, length delimited. Does not implicitly {@link m10.sdk.transaction.TransferStep.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.TransferStep
                 * @static
                 * @param {m10.sdk.transaction.ITransferStep} message TransferStep message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                TransferStep.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a TransferStep message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.TransferStep
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.TransferStep} TransferStep
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransferStep.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.TransferStep();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.fromAccountId = reader.bytes();
                            break;
                        case 2:
                            message.toAccountId = reader.bytes();
                            break;
                        case 4:
                            message.amount = reader.uint64();
                            break;
                        case 7:
                            if (!(message.metadata && message.metadata.length))
                                message.metadata = [];
                            message.metadata.push($root.google.protobuf.Any.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a TransferStep message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.TransferStep
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.TransferStep} TransferStep
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                TransferStep.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a TransferStep message.
                 * @function verify
                 * @memberof m10.sdk.transaction.TransferStep
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TransferStep.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.fromAccountId != null && message.hasOwnProperty("fromAccountId"))
                        if (!(message.fromAccountId && typeof message.fromAccountId.length === "number" || $util.isString(message.fromAccountId)))
                            return "fromAccountId: buffer expected";
                    if (message.toAccountId != null && message.hasOwnProperty("toAccountId"))
                        if (!(message.toAccountId && typeof message.toAccountId.length === "number" || $util.isString(message.toAccountId)))
                            return "toAccountId: buffer expected";
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        if (!$util.isInteger(message.amount) && !(message.amount && $util.isInteger(message.amount.low) && $util.isInteger(message.amount.high)))
                            return "amount: integer|Long expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        if (!Array.isArray(message.metadata))
                            return "metadata: array expected";
                        for (var i = 0; i < message.metadata.length; ++i) {
                            var error = $root.google.protobuf.Any.verify(message.metadata[i]);
                            if (error)
                                return "metadata." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a TransferStep message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.TransferStep
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.TransferStep} TransferStep
                 */
                TransferStep.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.TransferStep)
                        return object;
                    var message = new $root.m10.sdk.transaction.TransferStep();
                    if (object.fromAccountId != null)
                        if (typeof object.fromAccountId === "string")
                            $util.base64.decode(object.fromAccountId, message.fromAccountId = $util.newBuffer($util.base64.length(object.fromAccountId)), 0);
                        else if (object.fromAccountId.length)
                            message.fromAccountId = object.fromAccountId;
                    if (object.toAccountId != null)
                        if (typeof object.toAccountId === "string")
                            $util.base64.decode(object.toAccountId, message.toAccountId = $util.newBuffer($util.base64.length(object.toAccountId)), 0);
                        else if (object.toAccountId.length)
                            message.toAccountId = object.toAccountId;
                    if (object.amount != null)
                        if ($util.Long)
                            (message.amount = $util.Long.fromValue(object.amount)).unsigned = true;
                        else if (typeof object.amount === "string")
                            message.amount = parseInt(object.amount, 10);
                        else if (typeof object.amount === "number")
                            message.amount = object.amount;
                        else if (typeof object.amount === "object")
                            message.amount = new $util.LongBits(object.amount.low >>> 0, object.amount.high >>> 0).toNumber(true);
                    if (object.metadata) {
                        if (!Array.isArray(object.metadata))
                            throw TypeError(".m10.sdk.transaction.TransferStep.metadata: array expected");
                        message.metadata = [];
                        for (var i = 0; i < object.metadata.length; ++i) {
                            if (typeof object.metadata[i] !== "object")
                                throw TypeError(".m10.sdk.transaction.TransferStep.metadata: object expected");
                            message.metadata[i] = $root.google.protobuf.Any.fromObject(object.metadata[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TransferStep message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.TransferStep
                 * @static
                 * @param {m10.sdk.transaction.TransferStep} message TransferStep
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TransferStep.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.metadata = [];
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.fromAccountId = "";
                        else {
                            object.fromAccountId = [];
                            if (options.bytes !== Array)
                                object.fromAccountId = $util.newBuffer(object.fromAccountId);
                        }
                        if (options.bytes === String)
                            object.toAccountId = "";
                        else {
                            object.toAccountId = [];
                            if (options.bytes !== Array)
                                object.toAccountId = $util.newBuffer(object.toAccountId);
                        }
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.amount = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.amount = options.longs === String ? "0" : 0;
                    }
                    if (message.fromAccountId != null && message.hasOwnProperty("fromAccountId"))
                        object.fromAccountId = options.bytes === String ? $util.base64.encode(message.fromAccountId, 0, message.fromAccountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.fromAccountId) : message.fromAccountId;
                    if (message.toAccountId != null && message.hasOwnProperty("toAccountId"))
                        object.toAccountId = options.bytes === String ? $util.base64.encode(message.toAccountId, 0, message.toAccountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.toAccountId) : message.toAccountId;
                    if (message.amount != null && message.hasOwnProperty("amount"))
                        if (typeof message.amount === "number")
                            object.amount = options.longs === String ? String(message.amount) : message.amount;
                        else
                            object.amount = options.longs === String ? $util.Long.prototype.toString.call(message.amount) : options.longs === Number ? new $util.LongBits(message.amount.low >>> 0, message.amount.high >>> 0).toNumber(true) : message.amount;
                    if (message.metadata && message.metadata.length) {
                        object.metadata = [];
                        for (var j = 0; j < message.metadata.length; ++j)
                            object.metadata[j] = $root.google.protobuf.Any.toObject(message.metadata[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this TransferStep to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.TransferStep
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TransferStep.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TransferStep;
            })();

            transaction.FinalizedTransfer = (function() {

                /**
                 * Properties of a FinalizedTransfer.
                 * @memberof m10.sdk.transaction
                 * @interface IFinalizedTransfer
                 * @property {number|Long|null} [txId] FinalizedTransfer txId
                 * @property {Uint8Array|null} [contextId] FinalizedTransfer contextId
                 * @property {Array.<m10.sdk.transaction.ITransferStep>|null} [transferSteps] FinalizedTransfer transferSteps
                 * @property {m10.sdk.transaction.ITransactionError|null} [error] FinalizedTransfer error
                 * @property {number|Long|null} [timestamp] FinalizedTransfer timestamp
                 * @property {m10.sdk.transaction.FinalizedTransfer.TransferState|null} [state] FinalizedTransfer state
                 */

                /**
                 * Constructs a new FinalizedTransfer.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a FinalizedTransfer.
                 * @implements IFinalizedTransfer
                 * @constructor
                 * @param {m10.sdk.transaction.IFinalizedTransfer=} [properties] Properties to set
                 */
                function FinalizedTransfer(properties) {
                    this.transferSteps = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FinalizedTransfer txId.
                 * @member {number|Long} txId
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @instance
                 */
                FinalizedTransfer.prototype.txId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * FinalizedTransfer contextId.
                 * @member {Uint8Array} contextId
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @instance
                 */
                FinalizedTransfer.prototype.contextId = $util.newBuffer([]);

                /**
                 * FinalizedTransfer transferSteps.
                 * @member {Array.<m10.sdk.transaction.ITransferStep>} transferSteps
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @instance
                 */
                FinalizedTransfer.prototype.transferSteps = $util.emptyArray;

                /**
                 * FinalizedTransfer error.
                 * @member {m10.sdk.transaction.ITransactionError|null|undefined} error
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @instance
                 */
                FinalizedTransfer.prototype.error = null;

                /**
                 * FinalizedTransfer timestamp.
                 * @member {number|Long} timestamp
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @instance
                 */
                FinalizedTransfer.prototype.timestamp = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * FinalizedTransfer state.
                 * @member {m10.sdk.transaction.FinalizedTransfer.TransferState} state
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @instance
                 */
                FinalizedTransfer.prototype.state = 0;

                /**
                 * Creates a new FinalizedTransfer instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @static
                 * @param {m10.sdk.transaction.IFinalizedTransfer=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.FinalizedTransfer} FinalizedTransfer instance
                 */
                FinalizedTransfer.create = function create(properties) {
                    return new FinalizedTransfer(properties);
                };

                /**
                 * Encodes the specified FinalizedTransfer message. Does not implicitly {@link m10.sdk.transaction.FinalizedTransfer.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @static
                 * @param {m10.sdk.transaction.IFinalizedTransfer} message FinalizedTransfer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FinalizedTransfer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.txId);
                    if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.contextId);
                    if (message.transferSteps != null && message.transferSteps.length)
                        for (var i = 0; i < message.transferSteps.length; ++i)
                            $root.m10.sdk.transaction.TransferStep.encode(message.transferSteps[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.error != null && Object.hasOwnProperty.call(message, "error"))
                        $root.m10.sdk.transaction.TransactionError.encode(message.error, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.timestamp != null && Object.hasOwnProperty.call(message, "timestamp"))
                        writer.uint32(/* id 5, wireType 1 =*/41).fixed64(message.timestamp);
                    if (message.state != null && Object.hasOwnProperty.call(message, "state"))
                        writer.uint32(/* id 7, wireType 0 =*/56).int32(message.state);
                    return writer;
                };

                /**
                 * Encodes the specified FinalizedTransfer message, length delimited. Does not implicitly {@link m10.sdk.transaction.FinalizedTransfer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @static
                 * @param {m10.sdk.transaction.IFinalizedTransfer} message FinalizedTransfer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FinalizedTransfer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FinalizedTransfer message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.FinalizedTransfer} FinalizedTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FinalizedTransfer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.FinalizedTransfer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.txId = reader.uint64();
                            break;
                        case 2:
                            message.contextId = reader.bytes();
                            break;
                        case 3:
                            if (!(message.transferSteps && message.transferSteps.length))
                                message.transferSteps = [];
                            message.transferSteps.push($root.m10.sdk.transaction.TransferStep.decode(reader, reader.uint32()));
                            break;
                        case 4:
                            message.error = $root.m10.sdk.transaction.TransactionError.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.timestamp = reader.fixed64();
                            break;
                        case 7:
                            message.state = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FinalizedTransfer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.FinalizedTransfer} FinalizedTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FinalizedTransfer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FinalizedTransfer message.
                 * @function verify
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FinalizedTransfer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.txId != null && message.hasOwnProperty("txId"))
                        if (!$util.isInteger(message.txId) && !(message.txId && $util.isInteger(message.txId.low) && $util.isInteger(message.txId.high)))
                            return "txId: integer|Long expected";
                    if (message.contextId != null && message.hasOwnProperty("contextId"))
                        if (!(message.contextId && typeof message.contextId.length === "number" || $util.isString(message.contextId)))
                            return "contextId: buffer expected";
                    if (message.transferSteps != null && message.hasOwnProperty("transferSteps")) {
                        if (!Array.isArray(message.transferSteps))
                            return "transferSteps: array expected";
                        for (var i = 0; i < message.transferSteps.length; ++i) {
                            var error = $root.m10.sdk.transaction.TransferStep.verify(message.transferSteps[i]);
                            if (error)
                                return "transferSteps." + error;
                        }
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        var error = $root.m10.sdk.transaction.TransactionError.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if (!$util.isInteger(message.timestamp) && !(message.timestamp && $util.isInteger(message.timestamp.low) && $util.isInteger(message.timestamp.high)))
                            return "timestamp: integer|Long expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a FinalizedTransfer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.FinalizedTransfer} FinalizedTransfer
                 */
                FinalizedTransfer.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.FinalizedTransfer)
                        return object;
                    var message = new $root.m10.sdk.transaction.FinalizedTransfer();
                    if (object.txId != null)
                        if ($util.Long)
                            (message.txId = $util.Long.fromValue(object.txId)).unsigned = true;
                        else if (typeof object.txId === "string")
                            message.txId = parseInt(object.txId, 10);
                        else if (typeof object.txId === "number")
                            message.txId = object.txId;
                        else if (typeof object.txId === "object")
                            message.txId = new $util.LongBits(object.txId.low >>> 0, object.txId.high >>> 0).toNumber(true);
                    if (object.contextId != null)
                        if (typeof object.contextId === "string")
                            $util.base64.decode(object.contextId, message.contextId = $util.newBuffer($util.base64.length(object.contextId)), 0);
                        else if (object.contextId.length)
                            message.contextId = object.contextId;
                    if (object.transferSteps) {
                        if (!Array.isArray(object.transferSteps))
                            throw TypeError(".m10.sdk.transaction.FinalizedTransfer.transferSteps: array expected");
                        message.transferSteps = [];
                        for (var i = 0; i < object.transferSteps.length; ++i) {
                            if (typeof object.transferSteps[i] !== "object")
                                throw TypeError(".m10.sdk.transaction.FinalizedTransfer.transferSteps: object expected");
                            message.transferSteps[i] = $root.m10.sdk.transaction.TransferStep.fromObject(object.transferSteps[i]);
                        }
                    }
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".m10.sdk.transaction.FinalizedTransfer.error: object expected");
                        message.error = $root.m10.sdk.transaction.TransactionError.fromObject(object.error);
                    }
                    if (object.timestamp != null)
                        if ($util.Long)
                            (message.timestamp = $util.Long.fromValue(object.timestamp)).unsigned = false;
                        else if (typeof object.timestamp === "string")
                            message.timestamp = parseInt(object.timestamp, 10);
                        else if (typeof object.timestamp === "number")
                            message.timestamp = object.timestamp;
                        else if (typeof object.timestamp === "object")
                            message.timestamp = new $util.LongBits(object.timestamp.low >>> 0, object.timestamp.high >>> 0).toNumber();
                    switch (object.state) {
                    case "ACCEPTED":
                    case 0:
                        message.state = 0;
                        break;
                    case "REJECTED":
                    case 1:
                        message.state = 1;
                        break;
                    case "PENDING":
                    case 2:
                        message.state = 2;
                        break;
                    case "EXPIRED":
                    case 3:
                        message.state = 3;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FinalizedTransfer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @static
                 * @param {m10.sdk.transaction.FinalizedTransfer} message FinalizedTransfer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FinalizedTransfer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.transferSteps = [];
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.txId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.txId = options.longs === String ? "0" : 0;
                        if (options.bytes === String)
                            object.contextId = "";
                        else {
                            object.contextId = [];
                            if (options.bytes !== Array)
                                object.contextId = $util.newBuffer(object.contextId);
                        }
                        object.error = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, false);
                            object.timestamp = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timestamp = options.longs === String ? "0" : 0;
                        object.state = options.enums === String ? "ACCEPTED" : 0;
                    }
                    if (message.txId != null && message.hasOwnProperty("txId"))
                        if (typeof message.txId === "number")
                            object.txId = options.longs === String ? String(message.txId) : message.txId;
                        else
                            object.txId = options.longs === String ? $util.Long.prototype.toString.call(message.txId) : options.longs === Number ? new $util.LongBits(message.txId.low >>> 0, message.txId.high >>> 0).toNumber(true) : message.txId;
                    if (message.contextId != null && message.hasOwnProperty("contextId"))
                        object.contextId = options.bytes === String ? $util.base64.encode(message.contextId, 0, message.contextId.length) : options.bytes === Array ? Array.prototype.slice.call(message.contextId) : message.contextId;
                    if (message.transferSteps && message.transferSteps.length) {
                        object.transferSteps = [];
                        for (var j = 0; j < message.transferSteps.length; ++j)
                            object.transferSteps[j] = $root.m10.sdk.transaction.TransferStep.toObject(message.transferSteps[j], options);
                    }
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.m10.sdk.transaction.TransactionError.toObject(message.error, options);
                    if (message.timestamp != null && message.hasOwnProperty("timestamp"))
                        if (typeof message.timestamp === "number")
                            object.timestamp = options.longs === String ? String(message.timestamp) : message.timestamp;
                        else
                            object.timestamp = options.longs === String ? $util.Long.prototype.toString.call(message.timestamp) : options.longs === Number ? new $util.LongBits(message.timestamp.low >>> 0, message.timestamp.high >>> 0).toNumber() : message.timestamp;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = options.enums === String ? $root.m10.sdk.transaction.FinalizedTransfer.TransferState[message.state] : message.state;
                    return object;
                };

                /**
                 * Converts this FinalizedTransfer to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.FinalizedTransfer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FinalizedTransfer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * TransferState enum.
                 * @name m10.sdk.transaction.FinalizedTransfer.TransferState
                 * @enum {number}
                 * @property {number} ACCEPTED=0 ACCEPTED value
                 * @property {number} REJECTED=1 REJECTED value
                 * @property {number} PENDING=2 PENDING value
                 * @property {number} EXPIRED=3 EXPIRED value
                 */
                FinalizedTransfer.TransferState = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ACCEPTED"] = 0;
                    values[valuesById[1] = "REJECTED"] = 1;
                    values[valuesById[2] = "PENDING"] = 2;
                    values[valuesById[3] = "EXPIRED"] = 3;
                    return values;
                })();

                return FinalizedTransfer;
            })();

            transaction.FinalizedTransfers = (function() {

                /**
                 * Properties of a FinalizedTransfers.
                 * @memberof m10.sdk.transaction
                 * @interface IFinalizedTransfers
                 * @property {Array.<m10.sdk.transaction.IFinalizedTransfer>|null} [transfers] FinalizedTransfers transfers
                 */

                /**
                 * Constructs a new FinalizedTransfers.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a FinalizedTransfers.
                 * @implements IFinalizedTransfers
                 * @constructor
                 * @param {m10.sdk.transaction.IFinalizedTransfers=} [properties] Properties to set
                 */
                function FinalizedTransfers(properties) {
                    this.transfers = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FinalizedTransfers transfers.
                 * @member {Array.<m10.sdk.transaction.IFinalizedTransfer>} transfers
                 * @memberof m10.sdk.transaction.FinalizedTransfers
                 * @instance
                 */
                FinalizedTransfers.prototype.transfers = $util.emptyArray;

                /**
                 * Creates a new FinalizedTransfers instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.FinalizedTransfers
                 * @static
                 * @param {m10.sdk.transaction.IFinalizedTransfers=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.FinalizedTransfers} FinalizedTransfers instance
                 */
                FinalizedTransfers.create = function create(properties) {
                    return new FinalizedTransfers(properties);
                };

                /**
                 * Encodes the specified FinalizedTransfers message. Does not implicitly {@link m10.sdk.transaction.FinalizedTransfers.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.FinalizedTransfers
                 * @static
                 * @param {m10.sdk.transaction.IFinalizedTransfers} message FinalizedTransfers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FinalizedTransfers.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.transfers != null && message.transfers.length)
                        for (var i = 0; i < message.transfers.length; ++i)
                            $root.m10.sdk.transaction.FinalizedTransfer.encode(message.transfers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified FinalizedTransfers message, length delimited. Does not implicitly {@link m10.sdk.transaction.FinalizedTransfers.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.FinalizedTransfers
                 * @static
                 * @param {m10.sdk.transaction.IFinalizedTransfers} message FinalizedTransfers message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                FinalizedTransfers.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a FinalizedTransfers message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.FinalizedTransfers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.FinalizedTransfers} FinalizedTransfers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FinalizedTransfers.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.FinalizedTransfers();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.transfers && message.transfers.length))
                                message.transfers = [];
                            message.transfers.push($root.m10.sdk.transaction.FinalizedTransfer.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a FinalizedTransfers message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.FinalizedTransfers
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.FinalizedTransfers} FinalizedTransfers
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                FinalizedTransfers.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a FinalizedTransfers message.
                 * @function verify
                 * @memberof m10.sdk.transaction.FinalizedTransfers
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FinalizedTransfers.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.transfers != null && message.hasOwnProperty("transfers")) {
                        if (!Array.isArray(message.transfers))
                            return "transfers: array expected";
                        for (var i = 0; i < message.transfers.length; ++i) {
                            var error = $root.m10.sdk.transaction.FinalizedTransfer.verify(message.transfers[i]);
                            if (error)
                                return "transfers." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a FinalizedTransfers message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.FinalizedTransfers
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.FinalizedTransfers} FinalizedTransfers
                 */
                FinalizedTransfers.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.FinalizedTransfers)
                        return object;
                    var message = new $root.m10.sdk.transaction.FinalizedTransfers();
                    if (object.transfers) {
                        if (!Array.isArray(object.transfers))
                            throw TypeError(".m10.sdk.transaction.FinalizedTransfers.transfers: array expected");
                        message.transfers = [];
                        for (var i = 0; i < object.transfers.length; ++i) {
                            if (typeof object.transfers[i] !== "object")
                                throw TypeError(".m10.sdk.transaction.FinalizedTransfers.transfers: object expected");
                            message.transfers[i] = $root.m10.sdk.transaction.FinalizedTransfer.fromObject(object.transfers[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FinalizedTransfers message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.FinalizedTransfers
                 * @static
                 * @param {m10.sdk.transaction.FinalizedTransfers} message FinalizedTransfers
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FinalizedTransfers.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.transfers = [];
                    if (message.transfers && message.transfers.length) {
                        object.transfers = [];
                        for (var j = 0; j < message.transfers.length; ++j)
                            object.transfers[j] = $root.m10.sdk.transaction.FinalizedTransfer.toObject(message.transfers[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this FinalizedTransfers to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.FinalizedTransfers
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FinalizedTransfers.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FinalizedTransfers;
            })();

            transaction.Instrument = (function() {

                /**
                 * Properties of an Instrument.
                 * @memberof m10.sdk.transaction
                 * @interface IInstrument
                 * @property {string|null} [code] Instrument code
                 * @property {number|null} [decimalPlaces] Instrument decimalPlaces
                 * @property {string|null} [description] Instrument description
                 */

                /**
                 * Constructs a new Instrument.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents an Instrument.
                 * @implements IInstrument
                 * @constructor
                 * @param {m10.sdk.transaction.IInstrument=} [properties] Properties to set
                 */
                function Instrument(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Instrument code.
                 * @member {string} code
                 * @memberof m10.sdk.transaction.Instrument
                 * @instance
                 */
                Instrument.prototype.code = "";

                /**
                 * Instrument decimalPlaces.
                 * @member {number} decimalPlaces
                 * @memberof m10.sdk.transaction.Instrument
                 * @instance
                 */
                Instrument.prototype.decimalPlaces = 0;

                /**
                 * Instrument description.
                 * @member {string} description
                 * @memberof m10.sdk.transaction.Instrument
                 * @instance
                 */
                Instrument.prototype.description = "";

                /**
                 * Creates a new Instrument instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.Instrument
                 * @static
                 * @param {m10.sdk.transaction.IInstrument=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.Instrument} Instrument instance
                 */
                Instrument.create = function create(properties) {
                    return new Instrument(properties);
                };

                /**
                 * Encodes the specified Instrument message. Does not implicitly {@link m10.sdk.transaction.Instrument.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.Instrument
                 * @static
                 * @param {m10.sdk.transaction.IInstrument} message Instrument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Instrument.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.code);
                    if (message.decimalPlaces != null && Object.hasOwnProperty.call(message, "decimalPlaces"))
                        writer.uint32(/* id 2, wireType 0 =*/16).uint32(message.decimalPlaces);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.description);
                    return writer;
                };

                /**
                 * Encodes the specified Instrument message, length delimited. Does not implicitly {@link m10.sdk.transaction.Instrument.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.Instrument
                 * @static
                 * @param {m10.sdk.transaction.IInstrument} message Instrument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Instrument.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Instrument message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.Instrument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.Instrument} Instrument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Instrument.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.Instrument();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.code = reader.string();
                            break;
                        case 2:
                            message.decimalPlaces = reader.uint32();
                            break;
                        case 3:
                            message.description = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Instrument message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.Instrument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.Instrument} Instrument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Instrument.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Instrument message.
                 * @function verify
                 * @memberof m10.sdk.transaction.Instrument
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Instrument.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isString(message.code))
                            return "code: string expected";
                    if (message.decimalPlaces != null && message.hasOwnProperty("decimalPlaces"))
                        if (!$util.isInteger(message.decimalPlaces))
                            return "decimalPlaces: integer expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    return null;
                };

                /**
                 * Creates an Instrument message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.Instrument
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.Instrument} Instrument
                 */
                Instrument.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.Instrument)
                        return object;
                    var message = new $root.m10.sdk.transaction.Instrument();
                    if (object.code != null)
                        message.code = String(object.code);
                    if (object.decimalPlaces != null)
                        message.decimalPlaces = object.decimalPlaces >>> 0;
                    if (object.description != null)
                        message.description = String(object.description);
                    return message;
                };

                /**
                 * Creates a plain object from an Instrument message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.Instrument
                 * @static
                 * @param {m10.sdk.transaction.Instrument} message Instrument
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Instrument.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.code = "";
                        object.decimalPlaces = 0;
                        object.description = "";
                    }
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = message.code;
                    if (message.decimalPlaces != null && message.hasOwnProperty("decimalPlaces"))
                        object.decimalPlaces = message.decimalPlaces;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    return object;
                };

                /**
                 * Converts this Instrument to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.Instrument
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Instrument.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Instrument;
            })();

            transaction.CreateLedgerAccount = (function() {

                /**
                 * Properties of a CreateLedgerAccount.
                 * @memberof m10.sdk.transaction
                 * @interface ICreateLedgerAccount
                 * @property {Uint8Array|null} [parentId] CreateLedgerAccount parentId
                 * @property {boolean|null} [issuance] CreateLedgerAccount issuance
                 * @property {boolean|null} [frozen] CreateLedgerAccount frozen
                 * @property {m10.sdk.transaction.IInstrument|null} [instrument] CreateLedgerAccount instrument
                 */

                /**
                 * Constructs a new CreateLedgerAccount.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a CreateLedgerAccount.
                 * @implements ICreateLedgerAccount
                 * @constructor
                 * @param {m10.sdk.transaction.ICreateLedgerAccount=} [properties] Properties to set
                 */
                function CreateLedgerAccount(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateLedgerAccount parentId.
                 * @member {Uint8Array} parentId
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @instance
                 */
                CreateLedgerAccount.prototype.parentId = $util.newBuffer([]);

                /**
                 * CreateLedgerAccount issuance.
                 * @member {boolean} issuance
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @instance
                 */
                CreateLedgerAccount.prototype.issuance = false;

                /**
                 * CreateLedgerAccount frozen.
                 * @member {boolean} frozen
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @instance
                 */
                CreateLedgerAccount.prototype.frozen = false;

                /**
                 * CreateLedgerAccount instrument.
                 * @member {m10.sdk.transaction.IInstrument|null|undefined} instrument
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @instance
                 */
                CreateLedgerAccount.prototype.instrument = null;

                /**
                 * Creates a new CreateLedgerAccount instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @static
                 * @param {m10.sdk.transaction.ICreateLedgerAccount=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.CreateLedgerAccount} CreateLedgerAccount instance
                 */
                CreateLedgerAccount.create = function create(properties) {
                    return new CreateLedgerAccount(properties);
                };

                /**
                 * Encodes the specified CreateLedgerAccount message. Does not implicitly {@link m10.sdk.transaction.CreateLedgerAccount.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @static
                 * @param {m10.sdk.transaction.ICreateLedgerAccount} message CreateLedgerAccount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateLedgerAccount.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.parentId != null && Object.hasOwnProperty.call(message, "parentId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.parentId);
                    if (message.issuance != null && Object.hasOwnProperty.call(message, "issuance"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.issuance);
                    if (message.frozen != null && Object.hasOwnProperty.call(message, "frozen"))
                        writer.uint32(/* id 3, wireType 0 =*/24).bool(message.frozen);
                    if (message.instrument != null && Object.hasOwnProperty.call(message, "instrument"))
                        $root.m10.sdk.transaction.Instrument.encode(message.instrument, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified CreateLedgerAccount message, length delimited. Does not implicitly {@link m10.sdk.transaction.CreateLedgerAccount.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @static
                 * @param {m10.sdk.transaction.ICreateLedgerAccount} message CreateLedgerAccount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CreateLedgerAccount.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CreateLedgerAccount message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.CreateLedgerAccount} CreateLedgerAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateLedgerAccount.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.CreateLedgerAccount();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.parentId = reader.bytes();
                            break;
                        case 2:
                            message.issuance = reader.bool();
                            break;
                        case 3:
                            message.frozen = reader.bool();
                            break;
                        case 4:
                            message.instrument = $root.m10.sdk.transaction.Instrument.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CreateLedgerAccount message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.CreateLedgerAccount} CreateLedgerAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CreateLedgerAccount.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CreateLedgerAccount message.
                 * @function verify
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateLedgerAccount.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.parentId != null && message.hasOwnProperty("parentId"))
                        if (!(message.parentId && typeof message.parentId.length === "number" || $util.isString(message.parentId)))
                            return "parentId: buffer expected";
                    if (message.issuance != null && message.hasOwnProperty("issuance"))
                        if (typeof message.issuance !== "boolean")
                            return "issuance: boolean expected";
                    if (message.frozen != null && message.hasOwnProperty("frozen"))
                        if (typeof message.frozen !== "boolean")
                            return "frozen: boolean expected";
                    if (message.instrument != null && message.hasOwnProperty("instrument")) {
                        var error = $root.m10.sdk.transaction.Instrument.verify(message.instrument);
                        if (error)
                            return "instrument." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CreateLedgerAccount message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.CreateLedgerAccount} CreateLedgerAccount
                 */
                CreateLedgerAccount.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.CreateLedgerAccount)
                        return object;
                    var message = new $root.m10.sdk.transaction.CreateLedgerAccount();
                    if (object.parentId != null)
                        if (typeof object.parentId === "string")
                            $util.base64.decode(object.parentId, message.parentId = $util.newBuffer($util.base64.length(object.parentId)), 0);
                        else if (object.parentId.length)
                            message.parentId = object.parentId;
                    if (object.issuance != null)
                        message.issuance = Boolean(object.issuance);
                    if (object.frozen != null)
                        message.frozen = Boolean(object.frozen);
                    if (object.instrument != null) {
                        if (typeof object.instrument !== "object")
                            throw TypeError(".m10.sdk.transaction.CreateLedgerAccount.instrument: object expected");
                        message.instrument = $root.m10.sdk.transaction.Instrument.fromObject(object.instrument);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateLedgerAccount message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @static
                 * @param {m10.sdk.transaction.CreateLedgerAccount} message CreateLedgerAccount
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateLedgerAccount.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.parentId = "";
                        else {
                            object.parentId = [];
                            if (options.bytes !== Array)
                                object.parentId = $util.newBuffer(object.parentId);
                        }
                        object.issuance = false;
                        object.frozen = false;
                        object.instrument = null;
                    }
                    if (message.parentId != null && message.hasOwnProperty("parentId"))
                        object.parentId = options.bytes === String ? $util.base64.encode(message.parentId, 0, message.parentId.length) : options.bytes === Array ? Array.prototype.slice.call(message.parentId) : message.parentId;
                    if (message.issuance != null && message.hasOwnProperty("issuance"))
                        object.issuance = message.issuance;
                    if (message.frozen != null && message.hasOwnProperty("frozen"))
                        object.frozen = message.frozen;
                    if (message.instrument != null && message.hasOwnProperty("instrument"))
                        object.instrument = $root.m10.sdk.transaction.Instrument.toObject(message.instrument, options);
                    return object;
                };

                /**
                 * Converts this CreateLedgerAccount to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.CreateLedgerAccount
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateLedgerAccount.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateLedgerAccount;
            })();

            transaction.SetFreezeState = (function() {

                /**
                 * Properties of a SetFreezeState.
                 * @memberof m10.sdk.transaction
                 * @interface ISetFreezeState
                 * @property {Uint8Array|null} [accountId] SetFreezeState accountId
                 * @property {boolean|null} [frozen] SetFreezeState frozen
                 */

                /**
                 * Constructs a new SetFreezeState.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a SetFreezeState.
                 * @implements ISetFreezeState
                 * @constructor
                 * @param {m10.sdk.transaction.ISetFreezeState=} [properties] Properties to set
                 */
                function SetFreezeState(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SetFreezeState accountId.
                 * @member {Uint8Array} accountId
                 * @memberof m10.sdk.transaction.SetFreezeState
                 * @instance
                 */
                SetFreezeState.prototype.accountId = $util.newBuffer([]);

                /**
                 * SetFreezeState frozen.
                 * @member {boolean} frozen
                 * @memberof m10.sdk.transaction.SetFreezeState
                 * @instance
                 */
                SetFreezeState.prototype.frozen = false;

                /**
                 * Creates a new SetFreezeState instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.SetFreezeState
                 * @static
                 * @param {m10.sdk.transaction.ISetFreezeState=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.SetFreezeState} SetFreezeState instance
                 */
                SetFreezeState.create = function create(properties) {
                    return new SetFreezeState(properties);
                };

                /**
                 * Encodes the specified SetFreezeState message. Does not implicitly {@link m10.sdk.transaction.SetFreezeState.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.SetFreezeState
                 * @static
                 * @param {m10.sdk.transaction.ISetFreezeState} message SetFreezeState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetFreezeState.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountId);
                    if (message.frozen != null && Object.hasOwnProperty.call(message, "frozen"))
                        writer.uint32(/* id 2, wireType 0 =*/16).bool(message.frozen);
                    return writer;
                };

                /**
                 * Encodes the specified SetFreezeState message, length delimited. Does not implicitly {@link m10.sdk.transaction.SetFreezeState.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.SetFreezeState
                 * @static
                 * @param {m10.sdk.transaction.ISetFreezeState} message SetFreezeState message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetFreezeState.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SetFreezeState message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.SetFreezeState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.SetFreezeState} SetFreezeState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetFreezeState.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.SetFreezeState();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.accountId = reader.bytes();
                            break;
                        case 2:
                            message.frozen = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SetFreezeState message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.SetFreezeState
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.SetFreezeState} SetFreezeState
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetFreezeState.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SetFreezeState message.
                 * @function verify
                 * @memberof m10.sdk.transaction.SetFreezeState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SetFreezeState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.accountId != null && message.hasOwnProperty("accountId"))
                        if (!(message.accountId && typeof message.accountId.length === "number" || $util.isString(message.accountId)))
                            return "accountId: buffer expected";
                    if (message.frozen != null && message.hasOwnProperty("frozen"))
                        if (typeof message.frozen !== "boolean")
                            return "frozen: boolean expected";
                    return null;
                };

                /**
                 * Creates a SetFreezeState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.SetFreezeState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.SetFreezeState} SetFreezeState
                 */
                SetFreezeState.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.SetFreezeState)
                        return object;
                    var message = new $root.m10.sdk.transaction.SetFreezeState();
                    if (object.accountId != null)
                        if (typeof object.accountId === "string")
                            $util.base64.decode(object.accountId, message.accountId = $util.newBuffer($util.base64.length(object.accountId)), 0);
                        else if (object.accountId.length)
                            message.accountId = object.accountId;
                    if (object.frozen != null)
                        message.frozen = Boolean(object.frozen);
                    return message;
                };

                /**
                 * Creates a plain object from a SetFreezeState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.SetFreezeState
                 * @static
                 * @param {m10.sdk.transaction.SetFreezeState} message SetFreezeState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SetFreezeState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.accountId = "";
                        else {
                            object.accountId = [];
                            if (options.bytes !== Array)
                                object.accountId = $util.newBuffer(object.accountId);
                        }
                        object.frozen = false;
                    }
                    if (message.accountId != null && message.hasOwnProperty("accountId"))
                        object.accountId = options.bytes === String ? $util.base64.encode(message.accountId, 0, message.accountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountId) : message.accountId;
                    if (message.frozen != null && message.hasOwnProperty("frozen"))
                        object.frozen = message.frozen;
                    return object;
                };

                /**
                 * Converts this SetFreezeState to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.SetFreezeState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SetFreezeState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SetFreezeState;
            })();

            transaction.SetInstrument = (function() {

                /**
                 * Properties of a SetInstrument.
                 * @memberof m10.sdk.transaction
                 * @interface ISetInstrument
                 * @property {Uint8Array|null} [accountId] SetInstrument accountId
                 * @property {string|null} [code] SetInstrument code
                 * @property {number|null} [decimalPlaces] SetInstrument decimalPlaces
                 * @property {string|null} [description] SetInstrument description
                 */

                /**
                 * Constructs a new SetInstrument.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a SetInstrument.
                 * @implements ISetInstrument
                 * @constructor
                 * @param {m10.sdk.transaction.ISetInstrument=} [properties] Properties to set
                 */
                function SetInstrument(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SetInstrument accountId.
                 * @member {Uint8Array} accountId
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @instance
                 */
                SetInstrument.prototype.accountId = $util.newBuffer([]);

                /**
                 * SetInstrument code.
                 * @member {string} code
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @instance
                 */
                SetInstrument.prototype.code = "";

                /**
                 * SetInstrument decimalPlaces.
                 * @member {number} decimalPlaces
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @instance
                 */
                SetInstrument.prototype.decimalPlaces = 0;

                /**
                 * SetInstrument description.
                 * @member {string} description
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @instance
                 */
                SetInstrument.prototype.description = "";

                /**
                 * Creates a new SetInstrument instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @static
                 * @param {m10.sdk.transaction.ISetInstrument=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.SetInstrument} SetInstrument instance
                 */
                SetInstrument.create = function create(properties) {
                    return new SetInstrument(properties);
                };

                /**
                 * Encodes the specified SetInstrument message. Does not implicitly {@link m10.sdk.transaction.SetInstrument.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @static
                 * @param {m10.sdk.transaction.ISetInstrument} message SetInstrument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetInstrument.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountId);
                    if (message.code != null && Object.hasOwnProperty.call(message, "code"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.code);
                    if (message.decimalPlaces != null && Object.hasOwnProperty.call(message, "decimalPlaces"))
                        writer.uint32(/* id 3, wireType 0 =*/24).uint32(message.decimalPlaces);
                    if (message.description != null && Object.hasOwnProperty.call(message, "description"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.description);
                    return writer;
                };

                /**
                 * Encodes the specified SetInstrument message, length delimited. Does not implicitly {@link m10.sdk.transaction.SetInstrument.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @static
                 * @param {m10.sdk.transaction.ISetInstrument} message SetInstrument message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                SetInstrument.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a SetInstrument message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.SetInstrument} SetInstrument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetInstrument.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.SetInstrument();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.accountId = reader.bytes();
                            break;
                        case 2:
                            message.code = reader.string();
                            break;
                        case 3:
                            message.decimalPlaces = reader.uint32();
                            break;
                        case 4:
                            message.description = reader.string();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a SetInstrument message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.SetInstrument} SetInstrument
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                SetInstrument.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a SetInstrument message.
                 * @function verify
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SetInstrument.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.accountId != null && message.hasOwnProperty("accountId"))
                        if (!(message.accountId && typeof message.accountId.length === "number" || $util.isString(message.accountId)))
                            return "accountId: buffer expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isString(message.code))
                            return "code: string expected";
                    if (message.decimalPlaces != null && message.hasOwnProperty("decimalPlaces"))
                        if (!$util.isInteger(message.decimalPlaces))
                            return "decimalPlaces: integer expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    return null;
                };

                /**
                 * Creates a SetInstrument message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.SetInstrument} SetInstrument
                 */
                SetInstrument.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.SetInstrument)
                        return object;
                    var message = new $root.m10.sdk.transaction.SetInstrument();
                    if (object.accountId != null)
                        if (typeof object.accountId === "string")
                            $util.base64.decode(object.accountId, message.accountId = $util.newBuffer($util.base64.length(object.accountId)), 0);
                        else if (object.accountId.length)
                            message.accountId = object.accountId;
                    if (object.code != null)
                        message.code = String(object.code);
                    if (object.decimalPlaces != null)
                        message.decimalPlaces = object.decimalPlaces >>> 0;
                    if (object.description != null)
                        message.description = String(object.description);
                    return message;
                };

                /**
                 * Creates a plain object from a SetInstrument message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @static
                 * @param {m10.sdk.transaction.SetInstrument} message SetInstrument
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SetInstrument.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.accountId = "";
                        else {
                            object.accountId = [];
                            if (options.bytes !== Array)
                                object.accountId = $util.newBuffer(object.accountId);
                        }
                        object.code = "";
                        object.decimalPlaces = 0;
                        object.description = "";
                    }
                    if (message.accountId != null && message.hasOwnProperty("accountId"))
                        object.accountId = options.bytes === String ? $util.base64.encode(message.accountId, 0, message.accountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountId) : message.accountId;
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = message.code;
                    if (message.decimalPlaces != null && message.hasOwnProperty("decimalPlaces"))
                        object.decimalPlaces = message.decimalPlaces;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    return object;
                };

                /**
                 * Converts this SetInstrument to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.SetInstrument
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SetInstrument.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SetInstrument;
            })();

            transaction.GetAccountRequest = (function() {

                /**
                 * Properties of a GetAccountRequest.
                 * @memberof m10.sdk.transaction
                 * @interface IGetAccountRequest
                 * @property {Uint8Array|null} [id] GetAccountRequest id
                 */

                /**
                 * Constructs a new GetAccountRequest.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a GetAccountRequest.
                 * @implements IGetAccountRequest
                 * @constructor
                 * @param {m10.sdk.transaction.IGetAccountRequest=} [properties] Properties to set
                 */
                function GetAccountRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetAccountRequest id.
                 * @member {Uint8Array} id
                 * @memberof m10.sdk.transaction.GetAccountRequest
                 * @instance
                 */
                GetAccountRequest.prototype.id = $util.newBuffer([]);

                /**
                 * Creates a new GetAccountRequest instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.GetAccountRequest
                 * @static
                 * @param {m10.sdk.transaction.IGetAccountRequest=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.GetAccountRequest} GetAccountRequest instance
                 */
                GetAccountRequest.create = function create(properties) {
                    return new GetAccountRequest(properties);
                };

                /**
                 * Encodes the specified GetAccountRequest message. Does not implicitly {@link m10.sdk.transaction.GetAccountRequest.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.GetAccountRequest
                 * @static
                 * @param {m10.sdk.transaction.IGetAccountRequest} message GetAccountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetAccountRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                    return writer;
                };

                /**
                 * Encodes the specified GetAccountRequest message, length delimited. Does not implicitly {@link m10.sdk.transaction.GetAccountRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.GetAccountRequest
                 * @static
                 * @param {m10.sdk.transaction.IGetAccountRequest} message GetAccountRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetAccountRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetAccountRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.GetAccountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.GetAccountRequest} GetAccountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetAccountRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.GetAccountRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GetAccountRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.GetAccountRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.GetAccountRequest} GetAccountRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetAccountRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetAccountRequest message.
                 * @function verify
                 * @memberof m10.sdk.transaction.GetAccountRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetAccountRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                            return "id: buffer expected";
                    return null;
                };

                /**
                 * Creates a GetAccountRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.GetAccountRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.GetAccountRequest} GetAccountRequest
                 */
                GetAccountRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.GetAccountRequest)
                        return object;
                    var message = new $root.m10.sdk.transaction.GetAccountRequest();
                    if (object.id != null)
                        if (typeof object.id === "string")
                            $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                        else if (object.id.length)
                            message.id = object.id;
                    return message;
                };

                /**
                 * Creates a plain object from a GetAccountRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.GetAccountRequest
                 * @static
                 * @param {m10.sdk.transaction.GetAccountRequest} message GetAccountRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetAccountRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if (options.bytes === String)
                            object.id = "";
                        else {
                            object.id = [];
                            if (options.bytes !== Array)
                                object.id = $util.newBuffer(object.id);
                        }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                    return object;
                };

                /**
                 * Converts this GetAccountRequest to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.GetAccountRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetAccountRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetAccountRequest;
            })();

            transaction.IndexedAccount = (function() {

                /**
                 * Properties of an IndexedAccount.
                 * @memberof m10.sdk.transaction
                 * @interface IIndexedAccount
                 * @property {Uint8Array|null} [id] IndexedAccount id
                 * @property {m10.sdk.transaction.IndexedAccount.IIssuance|null} [issuance] IndexedAccount issuance
                 * @property {number|Long|null} [balance] IndexedAccount balance
                 * @property {boolean|null} [frozen] IndexedAccount frozen
                 * @property {m10.sdk.transaction.IInstrument|null} [instrument] IndexedAccount instrument
                 */

                /**
                 * Constructs a new IndexedAccount.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents an IndexedAccount.
                 * @implements IIndexedAccount
                 * @constructor
                 * @param {m10.sdk.transaction.IIndexedAccount=} [properties] Properties to set
                 */
                function IndexedAccount(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * IndexedAccount id.
                 * @member {Uint8Array} id
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @instance
                 */
                IndexedAccount.prototype.id = $util.newBuffer([]);

                /**
                 * IndexedAccount issuance.
                 * @member {m10.sdk.transaction.IndexedAccount.IIssuance|null|undefined} issuance
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @instance
                 */
                IndexedAccount.prototype.issuance = null;

                /**
                 * IndexedAccount balance.
                 * @member {number|Long} balance
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @instance
                 */
                IndexedAccount.prototype.balance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * IndexedAccount frozen.
                 * @member {boolean} frozen
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @instance
                 */
                IndexedAccount.prototype.frozen = false;

                /**
                 * IndexedAccount instrument.
                 * @member {m10.sdk.transaction.IInstrument|null|undefined} instrument
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @instance
                 */
                IndexedAccount.prototype.instrument = null;

                /**
                 * Creates a new IndexedAccount instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @static
                 * @param {m10.sdk.transaction.IIndexedAccount=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.IndexedAccount} IndexedAccount instance
                 */
                IndexedAccount.create = function create(properties) {
                    return new IndexedAccount(properties);
                };

                /**
                 * Encodes the specified IndexedAccount message. Does not implicitly {@link m10.sdk.transaction.IndexedAccount.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @static
                 * @param {m10.sdk.transaction.IIndexedAccount} message IndexedAccount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IndexedAccount.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.id != null && Object.hasOwnProperty.call(message, "id"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.id);
                    if (message.issuance != null && Object.hasOwnProperty.call(message, "issuance"))
                        $root.m10.sdk.transaction.IndexedAccount.Issuance.encode(message.issuance, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                    if (message.balance != null && Object.hasOwnProperty.call(message, "balance"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.balance);
                    if (message.frozen != null && Object.hasOwnProperty.call(message, "frozen"))
                        writer.uint32(/* id 5, wireType 0 =*/40).bool(message.frozen);
                    if (message.instrument != null && Object.hasOwnProperty.call(message, "instrument"))
                        $root.m10.sdk.transaction.Instrument.encode(message.instrument, writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified IndexedAccount message, length delimited. Does not implicitly {@link m10.sdk.transaction.IndexedAccount.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @static
                 * @param {m10.sdk.transaction.IIndexedAccount} message IndexedAccount message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                IndexedAccount.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an IndexedAccount message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.IndexedAccount} IndexedAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IndexedAccount.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.IndexedAccount();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.id = reader.bytes();
                            break;
                        case 3:
                            message.issuance = $root.m10.sdk.transaction.IndexedAccount.Issuance.decode(reader, reader.uint32());
                            break;
                        case 4:
                            message.balance = reader.uint64();
                            break;
                        case 5:
                            message.frozen = reader.bool();
                            break;
                        case 6:
                            message.instrument = $root.m10.sdk.transaction.Instrument.decode(reader, reader.uint32());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an IndexedAccount message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.IndexedAccount} IndexedAccount
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                IndexedAccount.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an IndexedAccount message.
                 * @function verify
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                IndexedAccount.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!(message.id && typeof message.id.length === "number" || $util.isString(message.id)))
                            return "id: buffer expected";
                    if (message.issuance != null && message.hasOwnProperty("issuance")) {
                        var error = $root.m10.sdk.transaction.IndexedAccount.Issuance.verify(message.issuance);
                        if (error)
                            return "issuance." + error;
                    }
                    if (message.balance != null && message.hasOwnProperty("balance"))
                        if (!$util.isInteger(message.balance) && !(message.balance && $util.isInteger(message.balance.low) && $util.isInteger(message.balance.high)))
                            return "balance: integer|Long expected";
                    if (message.frozen != null && message.hasOwnProperty("frozen"))
                        if (typeof message.frozen !== "boolean")
                            return "frozen: boolean expected";
                    if (message.instrument != null && message.hasOwnProperty("instrument")) {
                        var error = $root.m10.sdk.transaction.Instrument.verify(message.instrument);
                        if (error)
                            return "instrument." + error;
                    }
                    return null;
                };

                /**
                 * Creates an IndexedAccount message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.IndexedAccount} IndexedAccount
                 */
                IndexedAccount.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.IndexedAccount)
                        return object;
                    var message = new $root.m10.sdk.transaction.IndexedAccount();
                    if (object.id != null)
                        if (typeof object.id === "string")
                            $util.base64.decode(object.id, message.id = $util.newBuffer($util.base64.length(object.id)), 0);
                        else if (object.id.length)
                            message.id = object.id;
                    if (object.issuance != null) {
                        if (typeof object.issuance !== "object")
                            throw TypeError(".m10.sdk.transaction.IndexedAccount.issuance: object expected");
                        message.issuance = $root.m10.sdk.transaction.IndexedAccount.Issuance.fromObject(object.issuance);
                    }
                    if (object.balance != null)
                        if ($util.Long)
                            (message.balance = $util.Long.fromValue(object.balance)).unsigned = true;
                        else if (typeof object.balance === "string")
                            message.balance = parseInt(object.balance, 10);
                        else if (typeof object.balance === "number")
                            message.balance = object.balance;
                        else if (typeof object.balance === "object")
                            message.balance = new $util.LongBits(object.balance.low >>> 0, object.balance.high >>> 0).toNumber(true);
                    if (object.frozen != null)
                        message.frozen = Boolean(object.frozen);
                    if (object.instrument != null) {
                        if (typeof object.instrument !== "object")
                            throw TypeError(".m10.sdk.transaction.IndexedAccount.instrument: object expected");
                        message.instrument = $root.m10.sdk.transaction.Instrument.fromObject(object.instrument);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an IndexedAccount message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @static
                 * @param {m10.sdk.transaction.IndexedAccount} message IndexedAccount
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                IndexedAccount.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if (options.bytes === String)
                            object.id = "";
                        else {
                            object.id = [];
                            if (options.bytes !== Array)
                                object.id = $util.newBuffer(object.id);
                        }
                        object.issuance = null;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.balance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.balance = options.longs === String ? "0" : 0;
                        object.frozen = false;
                        object.instrument = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = options.bytes === String ? $util.base64.encode(message.id, 0, message.id.length) : options.bytes === Array ? Array.prototype.slice.call(message.id) : message.id;
                    if (message.issuance != null && message.hasOwnProperty("issuance"))
                        object.issuance = $root.m10.sdk.transaction.IndexedAccount.Issuance.toObject(message.issuance, options);
                    if (message.balance != null && message.hasOwnProperty("balance"))
                        if (typeof message.balance === "number")
                            object.balance = options.longs === String ? String(message.balance) : message.balance;
                        else
                            object.balance = options.longs === String ? $util.Long.prototype.toString.call(message.balance) : options.longs === Number ? new $util.LongBits(message.balance.low >>> 0, message.balance.high >>> 0).toNumber(true) : message.balance;
                    if (message.frozen != null && message.hasOwnProperty("frozen"))
                        object.frozen = message.frozen;
                    if (message.instrument != null && message.hasOwnProperty("instrument"))
                        object.instrument = $root.m10.sdk.transaction.Instrument.toObject(message.instrument, options);
                    return object;
                };

                /**
                 * Converts this IndexedAccount to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.IndexedAccount
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                IndexedAccount.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                IndexedAccount.Issuance = (function() {

                    /**
                     * Properties of an Issuance.
                     * @memberof m10.sdk.transaction.IndexedAccount
                     * @interface IIssuance
                     * @property {number|Long|null} [issuedBalance] Issuance issuedBalance
                     * @property {number|Long|null} [nonLeafChildren] Issuance nonLeafChildren
                     * @property {number|Long|null} [leafChildren] Issuance leafChildren
                     */

                    /**
                     * Constructs a new Issuance.
                     * @memberof m10.sdk.transaction.IndexedAccount
                     * @classdesc Represents an Issuance.
                     * @implements IIssuance
                     * @constructor
                     * @param {m10.sdk.transaction.IndexedAccount.IIssuance=} [properties] Properties to set
                     */
                    function Issuance(properties) {
                        if (properties)
                            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Issuance issuedBalance.
                     * @member {number|Long} issuedBalance
                     * @memberof m10.sdk.transaction.IndexedAccount.Issuance
                     * @instance
                     */
                    Issuance.prototype.issuedBalance = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Issuance nonLeafChildren.
                     * @member {number|Long} nonLeafChildren
                     * @memberof m10.sdk.transaction.IndexedAccount.Issuance
                     * @instance
                     */
                    Issuance.prototype.nonLeafChildren = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Issuance leafChildren.
                     * @member {number|Long} leafChildren
                     * @memberof m10.sdk.transaction.IndexedAccount.Issuance
                     * @instance
                     */
                    Issuance.prototype.leafChildren = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Creates a new Issuance instance using the specified properties.
                     * @function create
                     * @memberof m10.sdk.transaction.IndexedAccount.Issuance
                     * @static
                     * @param {m10.sdk.transaction.IndexedAccount.IIssuance=} [properties] Properties to set
                     * @returns {m10.sdk.transaction.IndexedAccount.Issuance} Issuance instance
                     */
                    Issuance.create = function create(properties) {
                        return new Issuance(properties);
                    };

                    /**
                     * Encodes the specified Issuance message. Does not implicitly {@link m10.sdk.transaction.IndexedAccount.Issuance.verify|verify} messages.
                     * @function encode
                     * @memberof m10.sdk.transaction.IndexedAccount.Issuance
                     * @static
                     * @param {m10.sdk.transaction.IndexedAccount.IIssuance} message Issuance message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Issuance.encode = function encode(message, writer) {
                        if (!writer)
                            writer = $Writer.create();
                        if (message.issuedBalance != null && Object.hasOwnProperty.call(message, "issuedBalance"))
                            writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.issuedBalance);
                        if (message.nonLeafChildren != null && Object.hasOwnProperty.call(message, "nonLeafChildren"))
                            writer.uint32(/* id 2, wireType 0 =*/16).uint64(message.nonLeafChildren);
                        if (message.leafChildren != null && Object.hasOwnProperty.call(message, "leafChildren"))
                            writer.uint32(/* id 3, wireType 0 =*/24).uint64(message.leafChildren);
                        return writer;
                    };

                    /**
                     * Encodes the specified Issuance message, length delimited. Does not implicitly {@link m10.sdk.transaction.IndexedAccount.Issuance.verify|verify} messages.
                     * @function encodeDelimited
                     * @memberof m10.sdk.transaction.IndexedAccount.Issuance
                     * @static
                     * @param {m10.sdk.transaction.IndexedAccount.IIssuance} message Issuance message or plain object to encode
                     * @param {$protobuf.Writer} [writer] Writer to encode to
                     * @returns {$protobuf.Writer} Writer
                     */
                    Issuance.encodeDelimited = function encodeDelimited(message, writer) {
                        return this.encode(message, writer).ldelim();
                    };

                    /**
                     * Decodes an Issuance message from the specified reader or buffer.
                     * @function decode
                     * @memberof m10.sdk.transaction.IndexedAccount.Issuance
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @param {number} [length] Message length if known beforehand
                     * @returns {m10.sdk.transaction.IndexedAccount.Issuance} Issuance
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Issuance.decode = function decode(reader, length) {
                        if (!(reader instanceof $Reader))
                            reader = $Reader.create(reader);
                        var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.IndexedAccount.Issuance();
                        while (reader.pos < end) {
                            var tag = reader.uint32();
                            switch (tag >>> 3) {
                            case 1:
                                message.issuedBalance = reader.uint64();
                                break;
                            case 2:
                                message.nonLeafChildren = reader.uint64();
                                break;
                            case 3:
                                message.leafChildren = reader.uint64();
                                break;
                            default:
                                reader.skipType(tag & 7);
                                break;
                            }
                        }
                        return message;
                    };

                    /**
                     * Decodes an Issuance message from the specified reader or buffer, length delimited.
                     * @function decodeDelimited
                     * @memberof m10.sdk.transaction.IndexedAccount.Issuance
                     * @static
                     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                     * @returns {m10.sdk.transaction.IndexedAccount.Issuance} Issuance
                     * @throws {Error} If the payload is not a reader or valid buffer
                     * @throws {$protobuf.util.ProtocolError} If required fields are missing
                     */
                    Issuance.decodeDelimited = function decodeDelimited(reader) {
                        if (!(reader instanceof $Reader))
                            reader = new $Reader(reader);
                        return this.decode(reader, reader.uint32());
                    };

                    /**
                     * Verifies an Issuance message.
                     * @function verify
                     * @memberof m10.sdk.transaction.IndexedAccount.Issuance
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Issuance.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.issuedBalance != null && message.hasOwnProperty("issuedBalance"))
                            if (!$util.isInteger(message.issuedBalance) && !(message.issuedBalance && $util.isInteger(message.issuedBalance.low) && $util.isInteger(message.issuedBalance.high)))
                                return "issuedBalance: integer|Long expected";
                        if (message.nonLeafChildren != null && message.hasOwnProperty("nonLeafChildren"))
                            if (!$util.isInteger(message.nonLeafChildren) && !(message.nonLeafChildren && $util.isInteger(message.nonLeafChildren.low) && $util.isInteger(message.nonLeafChildren.high)))
                                return "nonLeafChildren: integer|Long expected";
                        if (message.leafChildren != null && message.hasOwnProperty("leafChildren"))
                            if (!$util.isInteger(message.leafChildren) && !(message.leafChildren && $util.isInteger(message.leafChildren.low) && $util.isInteger(message.leafChildren.high)))
                                return "leafChildren: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates an Issuance message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof m10.sdk.transaction.IndexedAccount.Issuance
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {m10.sdk.transaction.IndexedAccount.Issuance} Issuance
                     */
                    Issuance.fromObject = function fromObject(object) {
                        if (object instanceof $root.m10.sdk.transaction.IndexedAccount.Issuance)
                            return object;
                        var message = new $root.m10.sdk.transaction.IndexedAccount.Issuance();
                        if (object.issuedBalance != null)
                            if ($util.Long)
                                (message.issuedBalance = $util.Long.fromValue(object.issuedBalance)).unsigned = true;
                            else if (typeof object.issuedBalance === "string")
                                message.issuedBalance = parseInt(object.issuedBalance, 10);
                            else if (typeof object.issuedBalance === "number")
                                message.issuedBalance = object.issuedBalance;
                            else if (typeof object.issuedBalance === "object")
                                message.issuedBalance = new $util.LongBits(object.issuedBalance.low >>> 0, object.issuedBalance.high >>> 0).toNumber(true);
                        if (object.nonLeafChildren != null)
                            if ($util.Long)
                                (message.nonLeafChildren = $util.Long.fromValue(object.nonLeafChildren)).unsigned = true;
                            else if (typeof object.nonLeafChildren === "string")
                                message.nonLeafChildren = parseInt(object.nonLeafChildren, 10);
                            else if (typeof object.nonLeafChildren === "number")
                                message.nonLeafChildren = object.nonLeafChildren;
                            else if (typeof object.nonLeafChildren === "object")
                                message.nonLeafChildren = new $util.LongBits(object.nonLeafChildren.low >>> 0, object.nonLeafChildren.high >>> 0).toNumber(true);
                        if (object.leafChildren != null)
                            if ($util.Long)
                                (message.leafChildren = $util.Long.fromValue(object.leafChildren)).unsigned = true;
                            else if (typeof object.leafChildren === "string")
                                message.leafChildren = parseInt(object.leafChildren, 10);
                            else if (typeof object.leafChildren === "number")
                                message.leafChildren = object.leafChildren;
                            else if (typeof object.leafChildren === "object")
                                message.leafChildren = new $util.LongBits(object.leafChildren.low >>> 0, object.leafChildren.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Issuance message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof m10.sdk.transaction.IndexedAccount.Issuance
                     * @static
                     * @param {m10.sdk.transaction.IndexedAccount.Issuance} message Issuance
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Issuance.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        var object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.issuedBalance = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.issuedBalance = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.nonLeafChildren = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.nonLeafChildren = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                var long = new $util.Long(0, 0, true);
                                object.leafChildren = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.leafChildren = options.longs === String ? "0" : 0;
                        }
                        if (message.issuedBalance != null && message.hasOwnProperty("issuedBalance"))
                            if (typeof message.issuedBalance === "number")
                                object.issuedBalance = options.longs === String ? String(message.issuedBalance) : message.issuedBalance;
                            else
                                object.issuedBalance = options.longs === String ? $util.Long.prototype.toString.call(message.issuedBalance) : options.longs === Number ? new $util.LongBits(message.issuedBalance.low >>> 0, message.issuedBalance.high >>> 0).toNumber(true) : message.issuedBalance;
                        if (message.nonLeafChildren != null && message.hasOwnProperty("nonLeafChildren"))
                            if (typeof message.nonLeafChildren === "number")
                                object.nonLeafChildren = options.longs === String ? String(message.nonLeafChildren) : message.nonLeafChildren;
                            else
                                object.nonLeafChildren = options.longs === String ? $util.Long.prototype.toString.call(message.nonLeafChildren) : options.longs === Number ? new $util.LongBits(message.nonLeafChildren.low >>> 0, message.nonLeafChildren.high >>> 0).toNumber(true) : message.nonLeafChildren;
                        if (message.leafChildren != null && message.hasOwnProperty("leafChildren"))
                            if (typeof message.leafChildren === "number")
                                object.leafChildren = options.longs === String ? String(message.leafChildren) : message.leafChildren;
                            else
                                object.leafChildren = options.longs === String ? $util.Long.prototype.toString.call(message.leafChildren) : options.longs === Number ? new $util.LongBits(message.leafChildren.low >>> 0, message.leafChildren.high >>> 0).toNumber(true) : message.leafChildren;
                        return object;
                    };

                    /**
                     * Converts this Issuance to JSON.
                     * @function toJSON
                     * @memberof m10.sdk.transaction.IndexedAccount.Issuance
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Issuance.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Issuance;
                })();

                return IndexedAccount;
            })();

            transaction.InvokeAction = (function() {

                /**
                 * Properties of an InvokeAction.
                 * @memberof m10.sdk.transaction
                 * @interface IInvokeAction
                 * @property {string|null} [name] InvokeAction name
                 * @property {Uint8Array|null} [fromAccount] InvokeAction fromAccount
                 * @property {m10.sdk.transaction.ITarget|null} [target] InvokeAction target
                 * @property {Uint8Array|null} [payload] InvokeAction payload
                 */

                /**
                 * Constructs a new InvokeAction.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents an InvokeAction.
                 * @implements IInvokeAction
                 * @constructor
                 * @param {m10.sdk.transaction.IInvokeAction=} [properties] Properties to set
                 */
                function InvokeAction(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * InvokeAction name.
                 * @member {string} name
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @instance
                 */
                InvokeAction.prototype.name = "";

                /**
                 * InvokeAction fromAccount.
                 * @member {Uint8Array} fromAccount
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @instance
                 */
                InvokeAction.prototype.fromAccount = $util.newBuffer([]);

                /**
                 * InvokeAction target.
                 * @member {m10.sdk.transaction.ITarget|null|undefined} target
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @instance
                 */
                InvokeAction.prototype.target = null;

                /**
                 * InvokeAction payload.
                 * @member {Uint8Array} payload
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @instance
                 */
                InvokeAction.prototype.payload = $util.newBuffer([]);

                /**
                 * Creates a new InvokeAction instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @static
                 * @param {m10.sdk.transaction.IInvokeAction=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.InvokeAction} InvokeAction instance
                 */
                InvokeAction.create = function create(properties) {
                    return new InvokeAction(properties);
                };

                /**
                 * Encodes the specified InvokeAction message. Does not implicitly {@link m10.sdk.transaction.InvokeAction.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @static
                 * @param {m10.sdk.transaction.IInvokeAction} message InvokeAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvokeAction.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.fromAccount != null && Object.hasOwnProperty.call(message, "fromAccount"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.fromAccount);
                    if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                        $root.m10.sdk.transaction.Target.encode(message.target, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                    if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                        writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.payload);
                    return writer;
                };

                /**
                 * Encodes the specified InvokeAction message, length delimited. Does not implicitly {@link m10.sdk.transaction.InvokeAction.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @static
                 * @param {m10.sdk.transaction.IInvokeAction} message InvokeAction message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                InvokeAction.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an InvokeAction message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.InvokeAction} InvokeAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvokeAction.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.InvokeAction();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.fromAccount = reader.bytes();
                            break;
                        case 4:
                            message.target = $root.m10.sdk.transaction.Target.decode(reader, reader.uint32());
                            break;
                        case 5:
                            message.payload = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an InvokeAction message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.InvokeAction} InvokeAction
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                InvokeAction.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an InvokeAction message.
                 * @function verify
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                InvokeAction.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.fromAccount != null && message.hasOwnProperty("fromAccount"))
                        if (!(message.fromAccount && typeof message.fromAccount.length === "number" || $util.isString(message.fromAccount)))
                            return "fromAccount: buffer expected";
                    if (message.target != null && message.hasOwnProperty("target")) {
                        var error = $root.m10.sdk.transaction.Target.verify(message.target);
                        if (error)
                            return "target." + error;
                    }
                    if (message.payload != null && message.hasOwnProperty("payload"))
                        if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                            return "payload: buffer expected";
                    return null;
                };

                /**
                 * Creates an InvokeAction message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.InvokeAction} InvokeAction
                 */
                InvokeAction.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.InvokeAction)
                        return object;
                    var message = new $root.m10.sdk.transaction.InvokeAction();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.fromAccount != null)
                        if (typeof object.fromAccount === "string")
                            $util.base64.decode(object.fromAccount, message.fromAccount = $util.newBuffer($util.base64.length(object.fromAccount)), 0);
                        else if (object.fromAccount.length)
                            message.fromAccount = object.fromAccount;
                    if (object.target != null) {
                        if (typeof object.target !== "object")
                            throw TypeError(".m10.sdk.transaction.InvokeAction.target: object expected");
                        message.target = $root.m10.sdk.transaction.Target.fromObject(object.target);
                    }
                    if (object.payload != null)
                        if (typeof object.payload === "string")
                            $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                        else if (object.payload.length)
                            message.payload = object.payload;
                    return message;
                };

                /**
                 * Creates a plain object from an InvokeAction message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @static
                 * @param {m10.sdk.transaction.InvokeAction} message InvokeAction
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                InvokeAction.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        if (options.bytes === String)
                            object.fromAccount = "";
                        else {
                            object.fromAccount = [];
                            if (options.bytes !== Array)
                                object.fromAccount = $util.newBuffer(object.fromAccount);
                        }
                        object.target = null;
                        if (options.bytes === String)
                            object.payload = "";
                        else {
                            object.payload = [];
                            if (options.bytes !== Array)
                                object.payload = $util.newBuffer(object.payload);
                        }
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.fromAccount != null && message.hasOwnProperty("fromAccount"))
                        object.fromAccount = options.bytes === String ? $util.base64.encode(message.fromAccount, 0, message.fromAccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.fromAccount) : message.fromAccount;
                    if (message.target != null && message.hasOwnProperty("target"))
                        object.target = $root.m10.sdk.transaction.Target.toObject(message.target, options);
                    if (message.payload != null && message.hasOwnProperty("payload"))
                        object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                    return object;
                };

                /**
                 * Converts this InvokeAction to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.InvokeAction
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                InvokeAction.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return InvokeAction;
            })();

            transaction.Target = (function() {

                /**
                 * Properties of a Target.
                 * @memberof m10.sdk.transaction
                 * @interface ITarget
                 * @property {Uint8Array|null} [accountId] Target accountId
                 */

                /**
                 * Constructs a new Target.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a Target.
                 * @implements ITarget
                 * @constructor
                 * @param {m10.sdk.transaction.ITarget=} [properties] Properties to set
                 */
                function Target(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Target accountId.
                 * @member {Uint8Array|null|undefined} accountId
                 * @memberof m10.sdk.transaction.Target
                 * @instance
                 */
                Target.prototype.accountId = null;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * Target target.
                 * @member {"accountId"|undefined} target
                 * @memberof m10.sdk.transaction.Target
                 * @instance
                 */
                Object.defineProperty(Target.prototype, "target", {
                    get: $util.oneOfGetter($oneOfFields = ["accountId"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new Target instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.Target
                 * @static
                 * @param {m10.sdk.transaction.ITarget=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.Target} Target instance
                 */
                Target.create = function create(properties) {
                    return new Target(properties);
                };

                /**
                 * Encodes the specified Target message. Does not implicitly {@link m10.sdk.transaction.Target.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.Target
                 * @static
                 * @param {m10.sdk.transaction.ITarget} message Target message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Target.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                        writer.uint32(/* id 1, wireType 2 =*/10).bytes(message.accountId);
                    return writer;
                };

                /**
                 * Encodes the specified Target message, length delimited. Does not implicitly {@link m10.sdk.transaction.Target.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.Target
                 * @static
                 * @param {m10.sdk.transaction.ITarget} message Target message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Target.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Target message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.Target
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.Target} Target
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Target.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.Target();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.accountId = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Target message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.Target
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.Target} Target
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Target.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Target message.
                 * @function verify
                 * @memberof m10.sdk.transaction.Target
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Target.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.accountId != null && message.hasOwnProperty("accountId")) {
                        properties.target = 1;
                        if (!(message.accountId && typeof message.accountId.length === "number" || $util.isString(message.accountId)))
                            return "accountId: buffer expected";
                    }
                    return null;
                };

                /**
                 * Creates a Target message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.Target
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.Target} Target
                 */
                Target.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.Target)
                        return object;
                    var message = new $root.m10.sdk.transaction.Target();
                    if (object.accountId != null)
                        if (typeof object.accountId === "string")
                            $util.base64.decode(object.accountId, message.accountId = $util.newBuffer($util.base64.length(object.accountId)), 0);
                        else if (object.accountId.length)
                            message.accountId = object.accountId;
                    return message;
                };

                /**
                 * Creates a plain object from a Target message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.Target
                 * @static
                 * @param {m10.sdk.transaction.Target} message Target
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Target.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (message.accountId != null && message.hasOwnProperty("accountId")) {
                        object.accountId = options.bytes === String ? $util.base64.encode(message.accountId, 0, message.accountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountId) : message.accountId;
                        if (options.oneofs)
                            object.target = "accountId";
                    }
                    return object;
                };

                /**
                 * Converts this Target to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.Target
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Target.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Target;
            })();

            transaction.Action = (function() {

                /**
                 * Properties of an Action.
                 * @memberof m10.sdk.transaction
                 * @interface IAction
                 * @property {number|Long|null} [txId] Action txId
                 * @property {string|null} [name] Action name
                 * @property {Uint8Array|null} [contextId] Action contextId
                 * @property {Uint8Array|null} [fromAccount] Action fromAccount
                 * @property {m10.sdk.transaction.ITarget|null} [target] Action target
                 * @property {Uint8Array|null} [payload] Action payload
                 */

                /**
                 * Constructs a new Action.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents an Action.
                 * @implements IAction
                 * @constructor
                 * @param {m10.sdk.transaction.IAction=} [properties] Properties to set
                 */
                function Action(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Action txId.
                 * @member {number|Long} txId
                 * @memberof m10.sdk.transaction.Action
                 * @instance
                 */
                Action.prototype.txId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Action name.
                 * @member {string} name
                 * @memberof m10.sdk.transaction.Action
                 * @instance
                 */
                Action.prototype.name = "";

                /**
                 * Action contextId.
                 * @member {Uint8Array} contextId
                 * @memberof m10.sdk.transaction.Action
                 * @instance
                 */
                Action.prototype.contextId = $util.newBuffer([]);

                /**
                 * Action fromAccount.
                 * @member {Uint8Array} fromAccount
                 * @memberof m10.sdk.transaction.Action
                 * @instance
                 */
                Action.prototype.fromAccount = $util.newBuffer([]);

                /**
                 * Action target.
                 * @member {m10.sdk.transaction.ITarget|null|undefined} target
                 * @memberof m10.sdk.transaction.Action
                 * @instance
                 */
                Action.prototype.target = null;

                /**
                 * Action payload.
                 * @member {Uint8Array} payload
                 * @memberof m10.sdk.transaction.Action
                 * @instance
                 */
                Action.prototype.payload = $util.newBuffer([]);

                /**
                 * Creates a new Action instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.Action
                 * @static
                 * @param {m10.sdk.transaction.IAction=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.Action} Action instance
                 */
                Action.create = function create(properties) {
                    return new Action(properties);
                };

                /**
                 * Encodes the specified Action message. Does not implicitly {@link m10.sdk.transaction.Action.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.Action
                 * @static
                 * @param {m10.sdk.transaction.IAction} message Action message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Action.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.txId);
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.name);
                    if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.contextId);
                    if (message.fromAccount != null && Object.hasOwnProperty.call(message, "fromAccount"))
                        writer.uint32(/* id 4, wireType 2 =*/34).bytes(message.fromAccount);
                    if (message.target != null && Object.hasOwnProperty.call(message, "target"))
                        $root.m10.sdk.transaction.Target.encode(message.target, writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                    if (message.payload != null && Object.hasOwnProperty.call(message, "payload"))
                        writer.uint32(/* id 6, wireType 2 =*/50).bytes(message.payload);
                    return writer;
                };

                /**
                 * Encodes the specified Action message, length delimited. Does not implicitly {@link m10.sdk.transaction.Action.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.Action
                 * @static
                 * @param {m10.sdk.transaction.IAction} message Action message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Action.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Action message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.Action
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.Action} Action
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Action.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.Action();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.txId = reader.uint64();
                            break;
                        case 2:
                            message.name = reader.string();
                            break;
                        case 3:
                            message.contextId = reader.bytes();
                            break;
                        case 4:
                            message.fromAccount = reader.bytes();
                            break;
                        case 5:
                            message.target = $root.m10.sdk.transaction.Target.decode(reader, reader.uint32());
                            break;
                        case 6:
                            message.payload = reader.bytes();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Action message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.Action
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.Action} Action
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Action.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Action message.
                 * @function verify
                 * @memberof m10.sdk.transaction.Action
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Action.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.txId != null && message.hasOwnProperty("txId"))
                        if (!$util.isInteger(message.txId) && !(message.txId && $util.isInteger(message.txId.low) && $util.isInteger(message.txId.high)))
                            return "txId: integer|Long expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.contextId != null && message.hasOwnProperty("contextId"))
                        if (!(message.contextId && typeof message.contextId.length === "number" || $util.isString(message.contextId)))
                            return "contextId: buffer expected";
                    if (message.fromAccount != null && message.hasOwnProperty("fromAccount"))
                        if (!(message.fromAccount && typeof message.fromAccount.length === "number" || $util.isString(message.fromAccount)))
                            return "fromAccount: buffer expected";
                    if (message.target != null && message.hasOwnProperty("target")) {
                        var error = $root.m10.sdk.transaction.Target.verify(message.target);
                        if (error)
                            return "target." + error;
                    }
                    if (message.payload != null && message.hasOwnProperty("payload"))
                        if (!(message.payload && typeof message.payload.length === "number" || $util.isString(message.payload)))
                            return "payload: buffer expected";
                    return null;
                };

                /**
                 * Creates an Action message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.Action
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.Action} Action
                 */
                Action.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.Action)
                        return object;
                    var message = new $root.m10.sdk.transaction.Action();
                    if (object.txId != null)
                        if ($util.Long)
                            (message.txId = $util.Long.fromValue(object.txId)).unsigned = true;
                        else if (typeof object.txId === "string")
                            message.txId = parseInt(object.txId, 10);
                        else if (typeof object.txId === "number")
                            message.txId = object.txId;
                        else if (typeof object.txId === "object")
                            message.txId = new $util.LongBits(object.txId.low >>> 0, object.txId.high >>> 0).toNumber(true);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.contextId != null)
                        if (typeof object.contextId === "string")
                            $util.base64.decode(object.contextId, message.contextId = $util.newBuffer($util.base64.length(object.contextId)), 0);
                        else if (object.contextId.length)
                            message.contextId = object.contextId;
                    if (object.fromAccount != null)
                        if (typeof object.fromAccount === "string")
                            $util.base64.decode(object.fromAccount, message.fromAccount = $util.newBuffer($util.base64.length(object.fromAccount)), 0);
                        else if (object.fromAccount.length)
                            message.fromAccount = object.fromAccount;
                    if (object.target != null) {
                        if (typeof object.target !== "object")
                            throw TypeError(".m10.sdk.transaction.Action.target: object expected");
                        message.target = $root.m10.sdk.transaction.Target.fromObject(object.target);
                    }
                    if (object.payload != null)
                        if (typeof object.payload === "string")
                            $util.base64.decode(object.payload, message.payload = $util.newBuffer($util.base64.length(object.payload)), 0);
                        else if (object.payload.length)
                            message.payload = object.payload;
                    return message;
                };

                /**
                 * Creates a plain object from an Action message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.Action
                 * @static
                 * @param {m10.sdk.transaction.Action} message Action
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Action.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.txId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.txId = options.longs === String ? "0" : 0;
                        object.name = "";
                        if (options.bytes === String)
                            object.contextId = "";
                        else {
                            object.contextId = [];
                            if (options.bytes !== Array)
                                object.contextId = $util.newBuffer(object.contextId);
                        }
                        if (options.bytes === String)
                            object.fromAccount = "";
                        else {
                            object.fromAccount = [];
                            if (options.bytes !== Array)
                                object.fromAccount = $util.newBuffer(object.fromAccount);
                        }
                        object.target = null;
                        if (options.bytes === String)
                            object.payload = "";
                        else {
                            object.payload = [];
                            if (options.bytes !== Array)
                                object.payload = $util.newBuffer(object.payload);
                        }
                    }
                    if (message.txId != null && message.hasOwnProperty("txId"))
                        if (typeof message.txId === "number")
                            object.txId = options.longs === String ? String(message.txId) : message.txId;
                        else
                            object.txId = options.longs === String ? $util.Long.prototype.toString.call(message.txId) : options.longs === Number ? new $util.LongBits(message.txId.low >>> 0, message.txId.high >>> 0).toNumber(true) : message.txId;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.contextId != null && message.hasOwnProperty("contextId"))
                        object.contextId = options.bytes === String ? $util.base64.encode(message.contextId, 0, message.contextId.length) : options.bytes === Array ? Array.prototype.slice.call(message.contextId) : message.contextId;
                    if (message.fromAccount != null && message.hasOwnProperty("fromAccount"))
                        object.fromAccount = options.bytes === String ? $util.base64.encode(message.fromAccount, 0, message.fromAccount.length) : options.bytes === Array ? Array.prototype.slice.call(message.fromAccount) : message.fromAccount;
                    if (message.target != null && message.hasOwnProperty("target"))
                        object.target = $root.m10.sdk.transaction.Target.toObject(message.target, options);
                    if (message.payload != null && message.hasOwnProperty("payload"))
                        object.payload = options.bytes === String ? $util.base64.encode(message.payload, 0, message.payload.length) : options.bytes === Array ? Array.prototype.slice.call(message.payload) : message.payload;
                    return object;
                };

                /**
                 * Converts this Action to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.Action
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Action.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Action;
            })();

            transaction.Actions = (function() {

                /**
                 * Properties of an Actions.
                 * @memberof m10.sdk.transaction
                 * @interface IActions
                 * @property {Array.<m10.sdk.transaction.IAction>|null} [actions] Actions actions
                 */

                /**
                 * Constructs a new Actions.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents an Actions.
                 * @implements IActions
                 * @constructor
                 * @param {m10.sdk.transaction.IActions=} [properties] Properties to set
                 */
                function Actions(properties) {
                    this.actions = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Actions actions.
                 * @member {Array.<m10.sdk.transaction.IAction>} actions
                 * @memberof m10.sdk.transaction.Actions
                 * @instance
                 */
                Actions.prototype.actions = $util.emptyArray;

                /**
                 * Creates a new Actions instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.Actions
                 * @static
                 * @param {m10.sdk.transaction.IActions=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.Actions} Actions instance
                 */
                Actions.create = function create(properties) {
                    return new Actions(properties);
                };

                /**
                 * Encodes the specified Actions message. Does not implicitly {@link m10.sdk.transaction.Actions.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.Actions
                 * @static
                 * @param {m10.sdk.transaction.IActions} message Actions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Actions.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.actions != null && message.actions.length)
                        for (var i = 0; i < message.actions.length; ++i)
                            $root.m10.sdk.transaction.Action.encode(message.actions[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                    return writer;
                };

                /**
                 * Encodes the specified Actions message, length delimited. Does not implicitly {@link m10.sdk.transaction.Actions.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.Actions
                 * @static
                 * @param {m10.sdk.transaction.IActions} message Actions message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Actions.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Actions message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.Actions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.Actions} Actions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Actions.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.Actions();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.actions && message.actions.length))
                                message.actions = [];
                            message.actions.push($root.m10.sdk.transaction.Action.decode(reader, reader.uint32()));
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Actions message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.Actions
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.Actions} Actions
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Actions.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Actions message.
                 * @function verify
                 * @memberof m10.sdk.transaction.Actions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Actions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.actions != null && message.hasOwnProperty("actions")) {
                        if (!Array.isArray(message.actions))
                            return "actions: array expected";
                        for (var i = 0; i < message.actions.length; ++i) {
                            var error = $root.m10.sdk.transaction.Action.verify(message.actions[i]);
                            if (error)
                                return "actions." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Actions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.Actions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.Actions} Actions
                 */
                Actions.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.Actions)
                        return object;
                    var message = new $root.m10.sdk.transaction.Actions();
                    if (object.actions) {
                        if (!Array.isArray(object.actions))
                            throw TypeError(".m10.sdk.transaction.Actions.actions: array expected");
                        message.actions = [];
                        for (var i = 0; i < object.actions.length; ++i) {
                            if (typeof object.actions[i] !== "object")
                                throw TypeError(".m10.sdk.transaction.Actions.actions: object expected");
                            message.actions[i] = $root.m10.sdk.transaction.Action.fromObject(object.actions[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Actions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.Actions
                 * @static
                 * @param {m10.sdk.transaction.Actions} message Actions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Actions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.actions = [];
                    if (message.actions && message.actions.length) {
                        object.actions = [];
                        for (var j = 0; j < message.actions.length; ++j)
                            object.actions[j] = $root.m10.sdk.transaction.Action.toObject(message.actions[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Actions to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.Actions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Actions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Actions;
            })();

            transaction.GetActionRequest = (function() {

                /**
                 * Properties of a GetActionRequest.
                 * @memberof m10.sdk.transaction
                 * @interface IGetActionRequest
                 * @property {number|Long|null} [txId] GetActionRequest txId
                 */

                /**
                 * Constructs a new GetActionRequest.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a GetActionRequest.
                 * @implements IGetActionRequest
                 * @constructor
                 * @param {m10.sdk.transaction.IGetActionRequest=} [properties] Properties to set
                 */
                function GetActionRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetActionRequest txId.
                 * @member {number|Long} txId
                 * @memberof m10.sdk.transaction.GetActionRequest
                 * @instance
                 */
                GetActionRequest.prototype.txId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Creates a new GetActionRequest instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.GetActionRequest
                 * @static
                 * @param {m10.sdk.transaction.IGetActionRequest=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.GetActionRequest} GetActionRequest instance
                 */
                GetActionRequest.create = function create(properties) {
                    return new GetActionRequest(properties);
                };

                /**
                 * Encodes the specified GetActionRequest message. Does not implicitly {@link m10.sdk.transaction.GetActionRequest.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.GetActionRequest
                 * @static
                 * @param {m10.sdk.transaction.IGetActionRequest} message GetActionRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetActionRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.txId != null && Object.hasOwnProperty.call(message, "txId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.txId);
                    return writer;
                };

                /**
                 * Encodes the specified GetActionRequest message, length delimited. Does not implicitly {@link m10.sdk.transaction.GetActionRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.GetActionRequest
                 * @static
                 * @param {m10.sdk.transaction.IGetActionRequest} message GetActionRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                GetActionRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a GetActionRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.GetActionRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.GetActionRequest} GetActionRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetActionRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.GetActionRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.txId = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a GetActionRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.GetActionRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.GetActionRequest} GetActionRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                GetActionRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a GetActionRequest message.
                 * @function verify
                 * @memberof m10.sdk.transaction.GetActionRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetActionRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.txId != null && message.hasOwnProperty("txId"))
                        if (!$util.isInteger(message.txId) && !(message.txId && $util.isInteger(message.txId.low) && $util.isInteger(message.txId.high)))
                            return "txId: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a GetActionRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.GetActionRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.GetActionRequest} GetActionRequest
                 */
                GetActionRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.GetActionRequest)
                        return object;
                    var message = new $root.m10.sdk.transaction.GetActionRequest();
                    if (object.txId != null)
                        if ($util.Long)
                            (message.txId = $util.Long.fromValue(object.txId)).unsigned = true;
                        else if (typeof object.txId === "string")
                            message.txId = parseInt(object.txId, 10);
                        else if (typeof object.txId === "number")
                            message.txId = object.txId;
                        else if (typeof object.txId === "object")
                            message.txId = new $util.LongBits(object.txId.low >>> 0, object.txId.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a GetActionRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.GetActionRequest
                 * @static
                 * @param {m10.sdk.transaction.GetActionRequest} message GetActionRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetActionRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults)
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.txId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.txId = options.longs === String ? "0" : 0;
                    if (message.txId != null && message.hasOwnProperty("txId"))
                        if (typeof message.txId === "number")
                            object.txId = options.longs === String ? String(message.txId) : message.txId;
                        else
                            object.txId = options.longs === String ? $util.Long.prototype.toString.call(message.txId) : options.longs === Number ? new $util.LongBits(message.txId.low >>> 0, message.txId.high >>> 0).toNumber(true) : message.txId;
                    return object;
                };

                /**
                 * Converts this GetActionRequest to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.GetActionRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetActionRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetActionRequest;
            })();

            transaction.ListActionsRequest = (function() {

                /**
                 * Properties of a ListActionsRequest.
                 * @memberof m10.sdk.transaction
                 * @interface IListActionsRequest
                 * @property {string|null} [name] ListActionsRequest name
                 * @property {Uint8Array|null} [accountId] ListActionsRequest accountId
                 * @property {Uint8Array|null} [contextId] ListActionsRequest contextId
                 * @property {number|Long|null} [limit] ListActionsRequest limit
                 * @property {number|Long|null} [minTxId] ListActionsRequest minTxId
                 * @property {number|Long|null} [maxTxId] ListActionsRequest maxTxId
                 */

                /**
                 * Constructs a new ListActionsRequest.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a ListActionsRequest.
                 * @implements IListActionsRequest
                 * @constructor
                 * @param {m10.sdk.transaction.IListActionsRequest=} [properties] Properties to set
                 */
                function ListActionsRequest(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListActionsRequest name.
                 * @member {string} name
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @instance
                 */
                ListActionsRequest.prototype.name = "";

                /**
                 * ListActionsRequest accountId.
                 * @member {Uint8Array|null|undefined} accountId
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @instance
                 */
                ListActionsRequest.prototype.accountId = null;

                /**
                 * ListActionsRequest contextId.
                 * @member {Uint8Array|null|undefined} contextId
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @instance
                 */
                ListActionsRequest.prototype.contextId = null;

                /**
                 * ListActionsRequest limit.
                 * @member {number|Long} limit
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @instance
                 */
                ListActionsRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ListActionsRequest minTxId.
                 * @member {number|Long} minTxId
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @instance
                 */
                ListActionsRequest.prototype.minTxId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * ListActionsRequest maxTxId.
                 * @member {number|Long} maxTxId
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @instance
                 */
                ListActionsRequest.prototype.maxTxId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                // OneOf field names bound to virtual getters and setters
                var $oneOfFields;

                /**
                 * ListActionsRequest filter.
                 * @member {"accountId"|"contextId"|undefined} filter
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @instance
                 */
                Object.defineProperty(ListActionsRequest.prototype, "filter", {
                    get: $util.oneOfGetter($oneOfFields = ["accountId", "contextId"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Creates a new ListActionsRequest instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @static
                 * @param {m10.sdk.transaction.IListActionsRequest=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.ListActionsRequest} ListActionsRequest instance
                 */
                ListActionsRequest.create = function create(properties) {
                    return new ListActionsRequest(properties);
                };

                /**
                 * Encodes the specified ListActionsRequest message. Does not implicitly {@link m10.sdk.transaction.ListActionsRequest.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @static
                 * @param {m10.sdk.transaction.IListActionsRequest} message ListActionsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListActionsRequest.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                    if (message.accountId != null && Object.hasOwnProperty.call(message, "accountId"))
                        writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.accountId);
                    if (message.contextId != null && Object.hasOwnProperty.call(message, "contextId"))
                        writer.uint32(/* id 3, wireType 2 =*/26).bytes(message.contextId);
                    if (message.limit != null && Object.hasOwnProperty.call(message, "limit"))
                        writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.limit);
                    if (message.minTxId != null && Object.hasOwnProperty.call(message, "minTxId"))
                        writer.uint32(/* id 5, wireType 0 =*/40).uint64(message.minTxId);
                    if (message.maxTxId != null && Object.hasOwnProperty.call(message, "maxTxId"))
                        writer.uint32(/* id 6, wireType 0 =*/48).uint64(message.maxTxId);
                    return writer;
                };

                /**
                 * Encodes the specified ListActionsRequest message, length delimited. Does not implicitly {@link m10.sdk.transaction.ListActionsRequest.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @static
                 * @param {m10.sdk.transaction.IListActionsRequest} message ListActionsRequest message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ListActionsRequest.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ListActionsRequest message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.ListActionsRequest} ListActionsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListActionsRequest.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.ListActionsRequest();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.name = reader.string();
                            break;
                        case 2:
                            message.accountId = reader.bytes();
                            break;
                        case 3:
                            message.contextId = reader.bytes();
                            break;
                        case 4:
                            message.limit = reader.uint64();
                            break;
                        case 5:
                            message.minTxId = reader.uint64();
                            break;
                        case 6:
                            message.maxTxId = reader.uint64();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ListActionsRequest message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.ListActionsRequest} ListActionsRequest
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ListActionsRequest.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ListActionsRequest message.
                 * @function verify
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListActionsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    var properties = {};
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.accountId != null && message.hasOwnProperty("accountId")) {
                        properties.filter = 1;
                        if (!(message.accountId && typeof message.accountId.length === "number" || $util.isString(message.accountId)))
                            return "accountId: buffer expected";
                    }
                    if (message.contextId != null && message.hasOwnProperty("contextId")) {
                        if (properties.filter === 1)
                            return "filter: multiple values";
                        properties.filter = 1;
                        if (!(message.contextId && typeof message.contextId.length === "number" || $util.isString(message.contextId)))
                            return "contextId: buffer expected";
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                            return "limit: integer|Long expected";
                    if (message.minTxId != null && message.hasOwnProperty("minTxId"))
                        if (!$util.isInteger(message.minTxId) && !(message.minTxId && $util.isInteger(message.minTxId.low) && $util.isInteger(message.minTxId.high)))
                            return "minTxId: integer|Long expected";
                    if (message.maxTxId != null && message.hasOwnProperty("maxTxId"))
                        if (!$util.isInteger(message.maxTxId) && !(message.maxTxId && $util.isInteger(message.maxTxId.low) && $util.isInteger(message.maxTxId.high)))
                            return "maxTxId: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a ListActionsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.ListActionsRequest} ListActionsRequest
                 */
                ListActionsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.ListActionsRequest)
                        return object;
                    var message = new $root.m10.sdk.transaction.ListActionsRequest();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.accountId != null)
                        if (typeof object.accountId === "string")
                            $util.base64.decode(object.accountId, message.accountId = $util.newBuffer($util.base64.length(object.accountId)), 0);
                        else if (object.accountId.length)
                            message.accountId = object.accountId;
                    if (object.contextId != null)
                        if (typeof object.contextId === "string")
                            $util.base64.decode(object.contextId, message.contextId = $util.newBuffer($util.base64.length(object.contextId)), 0);
                        else if (object.contextId.length)
                            message.contextId = object.contextId;
                    if (object.limit != null)
                        if ($util.Long)
                            (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                        else if (typeof object.limit === "string")
                            message.limit = parseInt(object.limit, 10);
                        else if (typeof object.limit === "number")
                            message.limit = object.limit;
                        else if (typeof object.limit === "object")
                            message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                    if (object.minTxId != null)
                        if ($util.Long)
                            (message.minTxId = $util.Long.fromValue(object.minTxId)).unsigned = true;
                        else if (typeof object.minTxId === "string")
                            message.minTxId = parseInt(object.minTxId, 10);
                        else if (typeof object.minTxId === "number")
                            message.minTxId = object.minTxId;
                        else if (typeof object.minTxId === "object")
                            message.minTxId = new $util.LongBits(object.minTxId.low >>> 0, object.minTxId.high >>> 0).toNumber(true);
                    if (object.maxTxId != null)
                        if ($util.Long)
                            (message.maxTxId = $util.Long.fromValue(object.maxTxId)).unsigned = true;
                        else if (typeof object.maxTxId === "string")
                            message.maxTxId = parseInt(object.maxTxId, 10);
                        else if (typeof object.maxTxId === "number")
                            message.maxTxId = object.maxTxId;
                        else if (typeof object.maxTxId === "object")
                            message.maxTxId = new $util.LongBits(object.maxTxId.low >>> 0, object.maxTxId.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from a ListActionsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @static
                 * @param {m10.sdk.transaction.ListActionsRequest} message ListActionsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListActionsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.name = "";
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.limit = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.minTxId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.minTxId = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.maxTxId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.maxTxId = options.longs === String ? "0" : 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.accountId != null && message.hasOwnProperty("accountId")) {
                        object.accountId = options.bytes === String ? $util.base64.encode(message.accountId, 0, message.accountId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountId) : message.accountId;
                        if (options.oneofs)
                            object.filter = "accountId";
                    }
                    if (message.contextId != null && message.hasOwnProperty("contextId")) {
                        object.contextId = options.bytes === String ? $util.base64.encode(message.contextId, 0, message.contextId.length) : options.bytes === Array ? Array.prototype.slice.call(message.contextId) : message.contextId;
                        if (options.oneofs)
                            object.filter = "contextId";
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (typeof message.limit === "number")
                            object.limit = options.longs === String ? String(message.limit) : message.limit;
                        else
                            object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                    if (message.minTxId != null && message.hasOwnProperty("minTxId"))
                        if (typeof message.minTxId === "number")
                            object.minTxId = options.longs === String ? String(message.minTxId) : message.minTxId;
                        else
                            object.minTxId = options.longs === String ? $util.Long.prototype.toString.call(message.minTxId) : options.longs === Number ? new $util.LongBits(message.minTxId.low >>> 0, message.minTxId.high >>> 0).toNumber(true) : message.minTxId;
                    if (message.maxTxId != null && message.hasOwnProperty("maxTxId"))
                        if (typeof message.maxTxId === "number")
                            object.maxTxId = options.longs === String ? String(message.maxTxId) : message.maxTxId;
                        else
                            object.maxTxId = options.longs === String ? $util.Long.prototype.toString.call(message.maxTxId) : options.longs === Number ? new $util.LongBits(message.maxTxId.low >>> 0, message.maxTxId.high >>> 0).toNumber(true) : message.maxTxId;
                    return object;
                };

                /**
                 * Converts this ListActionsRequest to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.ListActionsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListActionsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListActionsRequest;
            })();

            transaction.CommitTransfer = (function() {

                /**
                 * Properties of a CommitTransfer.
                 * @memberof m10.sdk.transaction
                 * @interface ICommitTransfer
                 * @property {number|Long|null} [pendingTxId] CommitTransfer pendingTxId
                 * @property {m10.sdk.transaction.CommitTransfer.TransferState|null} [newState] CommitTransfer newState
                 */

                /**
                 * Constructs a new CommitTransfer.
                 * @memberof m10.sdk.transaction
                 * @classdesc Represents a CommitTransfer.
                 * @implements ICommitTransfer
                 * @constructor
                 * @param {m10.sdk.transaction.ICommitTransfer=} [properties] Properties to set
                 */
                function CommitTransfer(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CommitTransfer pendingTxId.
                 * @member {number|Long} pendingTxId
                 * @memberof m10.sdk.transaction.CommitTransfer
                 * @instance
                 */
                CommitTransfer.prototype.pendingTxId = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * CommitTransfer newState.
                 * @member {m10.sdk.transaction.CommitTransfer.TransferState} newState
                 * @memberof m10.sdk.transaction.CommitTransfer
                 * @instance
                 */
                CommitTransfer.prototype.newState = 0;

                /**
                 * Creates a new CommitTransfer instance using the specified properties.
                 * @function create
                 * @memberof m10.sdk.transaction.CommitTransfer
                 * @static
                 * @param {m10.sdk.transaction.ICommitTransfer=} [properties] Properties to set
                 * @returns {m10.sdk.transaction.CommitTransfer} CommitTransfer instance
                 */
                CommitTransfer.create = function create(properties) {
                    return new CommitTransfer(properties);
                };

                /**
                 * Encodes the specified CommitTransfer message. Does not implicitly {@link m10.sdk.transaction.CommitTransfer.verify|verify} messages.
                 * @function encode
                 * @memberof m10.sdk.transaction.CommitTransfer
                 * @static
                 * @param {m10.sdk.transaction.ICommitTransfer} message CommitTransfer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommitTransfer.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.pendingTxId != null && Object.hasOwnProperty.call(message, "pendingTxId"))
                        writer.uint32(/* id 1, wireType 0 =*/8).uint64(message.pendingTxId);
                    if (message.newState != null && Object.hasOwnProperty.call(message, "newState"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.newState);
                    return writer;
                };

                /**
                 * Encodes the specified CommitTransfer message, length delimited. Does not implicitly {@link m10.sdk.transaction.CommitTransfer.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof m10.sdk.transaction.CommitTransfer
                 * @static
                 * @param {m10.sdk.transaction.ICommitTransfer} message CommitTransfer message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                CommitTransfer.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a CommitTransfer message from the specified reader or buffer.
                 * @function decode
                 * @memberof m10.sdk.transaction.CommitTransfer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {m10.sdk.transaction.CommitTransfer} CommitTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommitTransfer.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.sdk.transaction.CommitTransfer();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.pendingTxId = reader.uint64();
                            break;
                        case 2:
                            message.newState = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a CommitTransfer message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof m10.sdk.transaction.CommitTransfer
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {m10.sdk.transaction.CommitTransfer} CommitTransfer
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                CommitTransfer.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a CommitTransfer message.
                 * @function verify
                 * @memberof m10.sdk.transaction.CommitTransfer
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CommitTransfer.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pendingTxId != null && message.hasOwnProperty("pendingTxId"))
                        if (!$util.isInteger(message.pendingTxId) && !(message.pendingTxId && $util.isInteger(message.pendingTxId.low) && $util.isInteger(message.pendingTxId.high)))
                            return "pendingTxId: integer|Long expected";
                    if (message.newState != null && message.hasOwnProperty("newState"))
                        switch (message.newState) {
                        default:
                            return "newState: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a CommitTransfer message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof m10.sdk.transaction.CommitTransfer
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {m10.sdk.transaction.CommitTransfer} CommitTransfer
                 */
                CommitTransfer.fromObject = function fromObject(object) {
                    if (object instanceof $root.m10.sdk.transaction.CommitTransfer)
                        return object;
                    var message = new $root.m10.sdk.transaction.CommitTransfer();
                    if (object.pendingTxId != null)
                        if ($util.Long)
                            (message.pendingTxId = $util.Long.fromValue(object.pendingTxId)).unsigned = true;
                        else if (typeof object.pendingTxId === "string")
                            message.pendingTxId = parseInt(object.pendingTxId, 10);
                        else if (typeof object.pendingTxId === "number")
                            message.pendingTxId = object.pendingTxId;
                        else if (typeof object.pendingTxId === "object")
                            message.pendingTxId = new $util.LongBits(object.pendingTxId.low >>> 0, object.pendingTxId.high >>> 0).toNumber(true);
                    switch (object.newState) {
                    case "ACCEPTED":
                    case 0:
                        message.newState = 0;
                        break;
                    case "REJECTED":
                    case 1:
                        message.newState = 1;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CommitTransfer message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof m10.sdk.transaction.CommitTransfer
                 * @static
                 * @param {m10.sdk.transaction.CommitTransfer} message CommitTransfer
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CommitTransfer.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            var long = new $util.Long(0, 0, true);
                            object.pendingTxId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.pendingTxId = options.longs === String ? "0" : 0;
                        object.newState = options.enums === String ? "ACCEPTED" : 0;
                    }
                    if (message.pendingTxId != null && message.hasOwnProperty("pendingTxId"))
                        if (typeof message.pendingTxId === "number")
                            object.pendingTxId = options.longs === String ? String(message.pendingTxId) : message.pendingTxId;
                        else
                            object.pendingTxId = options.longs === String ? $util.Long.prototype.toString.call(message.pendingTxId) : options.longs === Number ? new $util.LongBits(message.pendingTxId.low >>> 0, message.pendingTxId.high >>> 0).toNumber(true) : message.pendingTxId;
                    if (message.newState != null && message.hasOwnProperty("newState"))
                        object.newState = options.enums === String ? $root.m10.sdk.transaction.CommitTransfer.TransferState[message.newState] : message.newState;
                    return object;
                };

                /**
                 * Converts this CommitTransfer to JSON.
                 * @function toJSON
                 * @memberof m10.sdk.transaction.CommitTransfer
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CommitTransfer.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * TransferState enum.
                 * @name m10.sdk.transaction.CommitTransfer.TransferState
                 * @enum {number}
                 * @property {number} ACCEPTED=0 ACCEPTED value
                 * @property {number} REJECTED=1 REJECTED value
                 */
                CommitTransfer.TransferState = (function() {
                    var valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "ACCEPTED"] = 0;
                    values[valuesById[1] = "REJECTED"] = 1;
                    return values;
                })();

                return CommitTransfer;
            })();

            return transaction;
        })();

        return sdk;
    })();

    m10.directory = (function() {

        /**
         * Namespace directory.
         * @memberof m10
         * @namespace
         */
        var directory = {};

        directory.DirectoryService = (function() {

            /**
             * Constructs a new DirectoryService service.
             * @memberof m10.directory
             * @classdesc Represents a DirectoryService
             * @extends $protobuf.rpc.Service
             * @constructor
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             */
            function DirectoryService(rpcImpl, requestDelimited, responseDelimited) {
                $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
            }

            (DirectoryService.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DirectoryService;

            /**
             * Creates new DirectoryService service using the specified rpc implementation.
             * @function create
             * @memberof m10.directory.DirectoryService
             * @static
             * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
             * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
             * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
             * @returns {DirectoryService} RPC service. Useful where requests and/or responses are streamed.
             */
            DirectoryService.create = function create(rpcImpl, requestDelimited, responseDelimited) {
                return new this(rpcImpl, requestDelimited, responseDelimited);
            };

            /**
             * Callback as used by {@link m10.directory.DirectoryService#createLedger}.
             * @memberof m10.directory.DirectoryService
             * @typedef CreateLedgerCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls CreateLedger.
             * @function createLedger
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {m10.directory.ILedger} request Ledger message or plain object
             * @param {m10.directory.DirectoryService.CreateLedgerCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DirectoryService.prototype.createLedger = function createLedger(request, callback) {
                return this.rpcCall(createLedger, $root.m10.directory.Ledger, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "CreateLedger" });

            /**
             * Calls CreateLedger.
             * @function createLedger
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {m10.directory.ILedger} request Ledger message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.directory.DirectoryService#listLedgers}.
             * @memberof m10.directory.DirectoryService
             * @typedef ListLedgersCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.directory.ListLedgersResponse} [response] ListLedgersResponse
             */

            /**
             * Calls ListLedgers.
             * @function listLedgers
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {m10.directory.DirectoryService.ListLedgersCallback} callback Node-style callback called with the error, if any, and ListLedgersResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DirectoryService.prototype.listLedgers = function listLedgers(request, callback) {
                return this.rpcCall(listLedgers, $root.google.protobuf.Empty, $root.m10.directory.ListLedgersResponse, request, callback);
            }, "name", { value: "ListLedgers" });

            /**
             * Calls ListLedgers.
             * @function listLedgers
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<m10.directory.ListLedgersResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.directory.DirectoryService#checkAlias}.
             * @memberof m10.directory.DirectoryService
             * @typedef CheckAliasCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls CheckAlias.
             * @function checkAlias
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {m10.directory.ICheckAliasRequest} request CheckAliasRequest message or plain object
             * @param {m10.directory.DirectoryService.CheckAliasCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DirectoryService.prototype.checkAlias = function checkAlias(request, callback) {
                return this.rpcCall(checkAlias, $root.m10.directory.CheckAliasRequest, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "CheckAlias" });

            /**
             * Calls CheckAlias.
             * @function checkAlias
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {m10.directory.ICheckAliasRequest} request CheckAliasRequest message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.directory.DirectoryService#createAlias}.
             * @memberof m10.directory.DirectoryService
             * @typedef CreateAliasCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {google.protobuf.Empty} [response] Empty
             */

            /**
             * Calls CreateAlias.
             * @function createAlias
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {m10.directory.IAlias} request Alias message or plain object
             * @param {m10.directory.DirectoryService.CreateAliasCallback} callback Node-style callback called with the error, if any, and Empty
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DirectoryService.prototype.createAlias = function createAlias(request, callback) {
                return this.rpcCall(createAlias, $root.m10.directory.Alias, $root.google.protobuf.Empty, request, callback);
            }, "name", { value: "CreateAlias" });

            /**
             * Calls CreateAlias.
             * @function createAlias
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {m10.directory.IAlias} request Alias message or plain object
             * @returns {Promise<google.protobuf.Empty>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.directory.DirectoryService#searchAliases}.
             * @memberof m10.directory.DirectoryService
             * @typedef SearchAliasesCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.directory.SearchAliasesResponse} [response] SearchAliasesResponse
             */

            /**
             * Calls SearchAliases.
             * @function searchAliases
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {m10.directory.ISearchAliasesRequest} request SearchAliasesRequest message or plain object
             * @param {m10.directory.DirectoryService.SearchAliasesCallback} callback Node-style callback called with the error, if any, and SearchAliasesResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DirectoryService.prototype.searchAliases = function searchAliases(request, callback) {
                return this.rpcCall(searchAliases, $root.m10.directory.SearchAliasesRequest, $root.m10.directory.SearchAliasesResponse, request, callback);
            }, "name", { value: "SearchAliases" });

            /**
             * Calls SearchAliases.
             * @function searchAliases
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {m10.directory.ISearchAliasesRequest} request SearchAliasesRequest message or plain object
             * @returns {Promise<m10.directory.SearchAliasesResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.directory.DirectoryService#createObjectUrl}.
             * @memberof m10.directory.DirectoryService
             * @typedef CreateObjectUrlCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.directory.ObjectUrlResponse} [response] ObjectUrlResponse
             */

            /**
             * Calls CreateObjectUrl.
             * @function createObjectUrl
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @param {m10.directory.DirectoryService.CreateObjectUrlCallback} callback Node-style callback called with the error, if any, and ObjectUrlResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DirectoryService.prototype.createObjectUrl = function createObjectUrl(request, callback) {
                return this.rpcCall(createObjectUrl, $root.google.protobuf.Empty, $root.m10.directory.ObjectUrlResponse, request, callback);
            }, "name", { value: "CreateObjectUrl" });

            /**
             * Calls CreateObjectUrl.
             * @function createObjectUrl
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {google.protobuf.IEmpty} request Empty message or plain object
             * @returns {Promise<m10.directory.ObjectUrlResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.directory.DirectoryService#getObjectUrl}.
             * @memberof m10.directory.DirectoryService
             * @typedef GetObjectUrlCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.directory.ObjectUrlResponse} [response] ObjectUrlResponse
             */

            /**
             * Calls GetObjectUrl.
             * @function getObjectUrl
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {m10.directory.IGetObjectUrlRequest} request GetObjectUrlRequest message or plain object
             * @param {m10.directory.DirectoryService.GetObjectUrlCallback} callback Node-style callback called with the error, if any, and ObjectUrlResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DirectoryService.prototype.getObjectUrl = function getObjectUrl(request, callback) {
                return this.rpcCall(getObjectUrl, $root.m10.directory.GetObjectUrlRequest, $root.m10.directory.ObjectUrlResponse, request, callback);
            }, "name", { value: "GetObjectUrl" });

            /**
             * Calls GetObjectUrl.
             * @function getObjectUrl
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {m10.directory.IGetObjectUrlRequest} request GetObjectUrlRequest message or plain object
             * @returns {Promise<m10.directory.ObjectUrlResponse>} Promise
             * @variation 2
             */

            /**
             * Callback as used by {@link m10.directory.DirectoryService#createImageUrl}.
             * @memberof m10.directory.DirectoryService
             * @typedef CreateImageUrlCallback
             * @type {function}
             * @param {Error|null} error Error, if any
             * @param {m10.directory.ObjectUrlResponse} [response] ObjectUrlResponse
             */

            /**
             * Calls CreateImageUrl.
             * @function createImageUrl
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {m10.directory.ICreateImageUrlRequest} request CreateImageUrlRequest message or plain object
             * @param {m10.directory.DirectoryService.CreateImageUrlCallback} callback Node-style callback called with the error, if any, and ObjectUrlResponse
             * @returns {undefined}
             * @variation 1
             */
            Object.defineProperty(DirectoryService.prototype.createImageUrl = function createImageUrl(request, callback) {
                return this.rpcCall(createImageUrl, $root.m10.directory.CreateImageUrlRequest, $root.m10.directory.ObjectUrlResponse, request, callback);
            }, "name", { value: "CreateImageUrl" });

            /**
             * Calls CreateImageUrl.
             * @function createImageUrl
             * @memberof m10.directory.DirectoryService
             * @instance
             * @param {m10.directory.ICreateImageUrlRequest} request CreateImageUrlRequest message or plain object
             * @returns {Promise<m10.directory.ObjectUrlResponse>} Promise
             * @variation 2
             */

            return DirectoryService;
        })();

        directory.Ledger = (function() {

            /**
             * Properties of a Ledger.
             * @memberof m10.directory
             * @interface ILedger
             * @property {string|null} [operator] Ledger operator
             * @property {string|null} [url] Ledger url
             */

            /**
             * Constructs a new Ledger.
             * @memberof m10.directory
             * @classdesc Represents a Ledger.
             * @implements ILedger
             * @constructor
             * @param {m10.directory.ILedger=} [properties] Properties to set
             */
            function Ledger(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Ledger operator.
             * @member {string} operator
             * @memberof m10.directory.Ledger
             * @instance
             */
            Ledger.prototype.operator = "";

            /**
             * Ledger url.
             * @member {string} url
             * @memberof m10.directory.Ledger
             * @instance
             */
            Ledger.prototype.url = "";

            /**
             * Creates a new Ledger instance using the specified properties.
             * @function create
             * @memberof m10.directory.Ledger
             * @static
             * @param {m10.directory.ILedger=} [properties] Properties to set
             * @returns {m10.directory.Ledger} Ledger instance
             */
            Ledger.create = function create(properties) {
                return new Ledger(properties);
            };

            /**
             * Encodes the specified Ledger message. Does not implicitly {@link m10.directory.Ledger.verify|verify} messages.
             * @function encode
             * @memberof m10.directory.Ledger
             * @static
             * @param {m10.directory.ILedger} message Ledger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ledger.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.operator);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.url);
                return writer;
            };

            /**
             * Encodes the specified Ledger message, length delimited. Does not implicitly {@link m10.directory.Ledger.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.directory.Ledger
             * @static
             * @param {m10.directory.ILedger} message Ledger message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Ledger.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a Ledger message from the specified reader or buffer.
             * @function decode
             * @memberof m10.directory.Ledger
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.directory.Ledger} Ledger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ledger.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.directory.Ledger();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.operator = reader.string();
                        break;
                    case 2:
                        message.url = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a Ledger message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.directory.Ledger
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.directory.Ledger} Ledger
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Ledger.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a Ledger message.
             * @function verify
             * @memberof m10.directory.Ledger
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Ledger.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (!$util.isString(message.operator))
                        return "operator: string expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };

            /**
             * Creates a Ledger message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.directory.Ledger
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.directory.Ledger} Ledger
             */
            Ledger.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.directory.Ledger)
                    return object;
                var message = new $root.m10.directory.Ledger();
                if (object.operator != null)
                    message.operator = String(object.operator);
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };

            /**
             * Creates a plain object from a Ledger message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.directory.Ledger
             * @static
             * @param {m10.directory.Ledger} message Ledger
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Ledger.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.operator = "";
                    object.url = "";
                }
                if (message.operator != null && message.hasOwnProperty("operator"))
                    object.operator = message.operator;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };

            /**
             * Converts this Ledger to JSON.
             * @function toJSON
             * @memberof m10.directory.Ledger
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Ledger.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Ledger;
        })();

        directory.ListLedgersResponse = (function() {

            /**
             * Properties of a ListLedgersResponse.
             * @memberof m10.directory
             * @interface IListLedgersResponse
             * @property {Array.<m10.directory.ILedger>|null} [ledgers] ListLedgersResponse ledgers
             */

            /**
             * Constructs a new ListLedgersResponse.
             * @memberof m10.directory
             * @classdesc Represents a ListLedgersResponse.
             * @implements IListLedgersResponse
             * @constructor
             * @param {m10.directory.IListLedgersResponse=} [properties] Properties to set
             */
            function ListLedgersResponse(properties) {
                this.ledgers = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListLedgersResponse ledgers.
             * @member {Array.<m10.directory.ILedger>} ledgers
             * @memberof m10.directory.ListLedgersResponse
             * @instance
             */
            ListLedgersResponse.prototype.ledgers = $util.emptyArray;

            /**
             * Creates a new ListLedgersResponse instance using the specified properties.
             * @function create
             * @memberof m10.directory.ListLedgersResponse
             * @static
             * @param {m10.directory.IListLedgersResponse=} [properties] Properties to set
             * @returns {m10.directory.ListLedgersResponse} ListLedgersResponse instance
             */
            ListLedgersResponse.create = function create(properties) {
                return new ListLedgersResponse(properties);
            };

            /**
             * Encodes the specified ListLedgersResponse message. Does not implicitly {@link m10.directory.ListLedgersResponse.verify|verify} messages.
             * @function encode
             * @memberof m10.directory.ListLedgersResponse
             * @static
             * @param {m10.directory.IListLedgersResponse} message ListLedgersResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListLedgersResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ledgers != null && message.ledgers.length)
                    for (var i = 0; i < message.ledgers.length; ++i)
                        $root.m10.directory.Ledger.encode(message.ledgers[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ListLedgersResponse message, length delimited. Does not implicitly {@link m10.directory.ListLedgersResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.directory.ListLedgersResponse
             * @static
             * @param {m10.directory.IListLedgersResponse} message ListLedgersResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ListLedgersResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ListLedgersResponse message from the specified reader or buffer.
             * @function decode
             * @memberof m10.directory.ListLedgersResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.directory.ListLedgersResponse} ListLedgersResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListLedgersResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.directory.ListLedgersResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.ledgers && message.ledgers.length))
                            message.ledgers = [];
                        message.ledgers.push($root.m10.directory.Ledger.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ListLedgersResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.directory.ListLedgersResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.directory.ListLedgersResponse} ListLedgersResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ListLedgersResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ListLedgersResponse message.
             * @function verify
             * @memberof m10.directory.ListLedgersResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListLedgersResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ledgers != null && message.hasOwnProperty("ledgers")) {
                    if (!Array.isArray(message.ledgers))
                        return "ledgers: array expected";
                    for (var i = 0; i < message.ledgers.length; ++i) {
                        var error = $root.m10.directory.Ledger.verify(message.ledgers[i]);
                        if (error)
                            return "ledgers." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListLedgersResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.directory.ListLedgersResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.directory.ListLedgersResponse} ListLedgersResponse
             */
            ListLedgersResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.directory.ListLedgersResponse)
                    return object;
                var message = new $root.m10.directory.ListLedgersResponse();
                if (object.ledgers) {
                    if (!Array.isArray(object.ledgers))
                        throw TypeError(".m10.directory.ListLedgersResponse.ledgers: array expected");
                    message.ledgers = [];
                    for (var i = 0; i < object.ledgers.length; ++i) {
                        if (typeof object.ledgers[i] !== "object")
                            throw TypeError(".m10.directory.ListLedgersResponse.ledgers: object expected");
                        message.ledgers[i] = $root.m10.directory.Ledger.fromObject(object.ledgers[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListLedgersResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.directory.ListLedgersResponse
             * @static
             * @param {m10.directory.ListLedgersResponse} message ListLedgersResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListLedgersResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.ledgers = [];
                if (message.ledgers && message.ledgers.length) {
                    object.ledgers = [];
                    for (var j = 0; j < message.ledgers.length; ++j)
                        object.ledgers[j] = $root.m10.directory.Ledger.toObject(message.ledgers[j], options);
                }
                return object;
            };

            /**
             * Converts this ListLedgersResponse to JSON.
             * @function toJSON
             * @memberof m10.directory.ListLedgersResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListLedgersResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListLedgersResponse;
        })();

        directory.Alias = (function() {

            /**
             * Properties of an Alias.
             * @memberof m10.directory
             * @interface IAlias
             * @property {string|null} [handle] Alias handle
             * @property {string|null} [displayName] Alias displayName
             * @property {Uint8Array|null} [accountSetId] Alias accountSetId
             * @property {string|null} [operator] Alias operator
             * @property {m10.directory.Alias.Type|null} [aliasType] Alias aliasType
             */

            /**
             * Constructs a new Alias.
             * @memberof m10.directory
             * @classdesc Represents an Alias.
             * @implements IAlias
             * @constructor
             * @param {m10.directory.IAlias=} [properties] Properties to set
             */
            function Alias(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Alias handle.
             * @member {string} handle
             * @memberof m10.directory.Alias
             * @instance
             */
            Alias.prototype.handle = "";

            /**
             * Alias displayName.
             * @member {string} displayName
             * @memberof m10.directory.Alias
             * @instance
             */
            Alias.prototype.displayName = "";

            /**
             * Alias accountSetId.
             * @member {Uint8Array} accountSetId
             * @memberof m10.directory.Alias
             * @instance
             */
            Alias.prototype.accountSetId = $util.newBuffer([]);

            /**
             * Alias operator.
             * @member {string} operator
             * @memberof m10.directory.Alias
             * @instance
             */
            Alias.prototype.operator = "";

            /**
             * Alias aliasType.
             * @member {m10.directory.Alias.Type} aliasType
             * @memberof m10.directory.Alias
             * @instance
             */
            Alias.prototype.aliasType = 0;

            /**
             * Creates a new Alias instance using the specified properties.
             * @function create
             * @memberof m10.directory.Alias
             * @static
             * @param {m10.directory.IAlias=} [properties] Properties to set
             * @returns {m10.directory.Alias} Alias instance
             */
            Alias.create = function create(properties) {
                return new Alias(properties);
            };

            /**
             * Encodes the specified Alias message. Does not implicitly {@link m10.directory.Alias.verify|verify} messages.
             * @function encode
             * @memberof m10.directory.Alias
             * @static
             * @param {m10.directory.IAlias} message Alias message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Alias.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.handle != null && Object.hasOwnProperty.call(message, "handle"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.handle);
                if (message.displayName != null && Object.hasOwnProperty.call(message, "displayName"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.displayName);
                if (message.accountSetId != null && Object.hasOwnProperty.call(message, "accountSetId"))
                    writer.uint32(/* id 5, wireType 2 =*/42).bytes(message.accountSetId);
                if (message.operator != null && Object.hasOwnProperty.call(message, "operator"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.operator);
                if (message.aliasType != null && Object.hasOwnProperty.call(message, "aliasType"))
                    writer.uint32(/* id 10, wireType 0 =*/80).int32(message.aliasType);
                return writer;
            };

            /**
             * Encodes the specified Alias message, length delimited. Does not implicitly {@link m10.directory.Alias.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.directory.Alias
             * @static
             * @param {m10.directory.IAlias} message Alias message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Alias.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Alias message from the specified reader or buffer.
             * @function decode
             * @memberof m10.directory.Alias
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.directory.Alias} Alias
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Alias.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.directory.Alias();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.handle = reader.string();
                        break;
                    case 2:
                        message.displayName = reader.string();
                        break;
                    case 5:
                        message.accountSetId = reader.bytes();
                        break;
                    case 8:
                        message.operator = reader.string();
                        break;
                    case 10:
                        message.aliasType = reader.int32();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Alias message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.directory.Alias
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.directory.Alias} Alias
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Alias.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Alias message.
             * @function verify
             * @memberof m10.directory.Alias
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Alias.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.handle != null && message.hasOwnProperty("handle"))
                    if (!$util.isString(message.handle))
                        return "handle: string expected";
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    if (!$util.isString(message.displayName))
                        return "displayName: string expected";
                if (message.accountSetId != null && message.hasOwnProperty("accountSetId"))
                    if (!(message.accountSetId && typeof message.accountSetId.length === "number" || $util.isString(message.accountSetId)))
                        return "accountSetId: buffer expected";
                if (message.operator != null && message.hasOwnProperty("operator"))
                    if (!$util.isString(message.operator))
                        return "operator: string expected";
                if (message.aliasType != null && message.hasOwnProperty("aliasType"))
                    switch (message.aliasType) {
                    default:
                        return "aliasType: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                return null;
            };

            /**
             * Creates an Alias message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.directory.Alias
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.directory.Alias} Alias
             */
            Alias.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.directory.Alias)
                    return object;
                var message = new $root.m10.directory.Alias();
                if (object.handle != null)
                    message.handle = String(object.handle);
                if (object.displayName != null)
                    message.displayName = String(object.displayName);
                if (object.accountSetId != null)
                    if (typeof object.accountSetId === "string")
                        $util.base64.decode(object.accountSetId, message.accountSetId = $util.newBuffer($util.base64.length(object.accountSetId)), 0);
                    else if (object.accountSetId.length)
                        message.accountSetId = object.accountSetId;
                if (object.operator != null)
                    message.operator = String(object.operator);
                switch (object.aliasType) {
                case "HANDLE":
                case 0:
                    message.aliasType = 0;
                    break;
                case "EMAIL":
                case 1:
                    message.aliasType = 1;
                    break;
                case "PHONE":
                case 2:
                    message.aliasType = 2;
                    break;
                }
                return message;
            };

            /**
             * Creates a plain object from an Alias message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.directory.Alias
             * @static
             * @param {m10.directory.Alias} message Alias
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Alias.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.handle = "";
                    object.displayName = "";
                    if (options.bytes === String)
                        object.accountSetId = "";
                    else {
                        object.accountSetId = [];
                        if (options.bytes !== Array)
                            object.accountSetId = $util.newBuffer(object.accountSetId);
                    }
                    object.operator = "";
                    object.aliasType = options.enums === String ? "HANDLE" : 0;
                }
                if (message.handle != null && message.hasOwnProperty("handle"))
                    object.handle = message.handle;
                if (message.displayName != null && message.hasOwnProperty("displayName"))
                    object.displayName = message.displayName;
                if (message.accountSetId != null && message.hasOwnProperty("accountSetId"))
                    object.accountSetId = options.bytes === String ? $util.base64.encode(message.accountSetId, 0, message.accountSetId.length) : options.bytes === Array ? Array.prototype.slice.call(message.accountSetId) : message.accountSetId;
                if (message.operator != null && message.hasOwnProperty("operator"))
                    object.operator = message.operator;
                if (message.aliasType != null && message.hasOwnProperty("aliasType"))
                    object.aliasType = options.enums === String ? $root.m10.directory.Alias.Type[message.aliasType] : message.aliasType;
                return object;
            };

            /**
             * Converts this Alias to JSON.
             * @function toJSON
             * @memberof m10.directory.Alias
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Alias.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name m10.directory.Alias.Type
             * @enum {number}
             * @property {number} HANDLE=0 HANDLE value
             * @property {number} EMAIL=1 EMAIL value
             * @property {number} PHONE=2 PHONE value
             */
            Alias.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "HANDLE"] = 0;
                values[valuesById[1] = "EMAIL"] = 1;
                values[valuesById[2] = "PHONE"] = 2;
                return values;
            })();

            return Alias;
        })();

        directory.CheckAliasRequest = (function() {

            /**
             * Properties of a CheckAliasRequest.
             * @memberof m10.directory
             * @interface ICheckAliasRequest
             * @property {string|null} [handle] CheckAliasRequest handle
             */

            /**
             * Constructs a new CheckAliasRequest.
             * @memberof m10.directory
             * @classdesc Represents a CheckAliasRequest.
             * @implements ICheckAliasRequest
             * @constructor
             * @param {m10.directory.ICheckAliasRequest=} [properties] Properties to set
             */
            function CheckAliasRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CheckAliasRequest handle.
             * @member {string} handle
             * @memberof m10.directory.CheckAliasRequest
             * @instance
             */
            CheckAliasRequest.prototype.handle = "";

            /**
             * Creates a new CheckAliasRequest instance using the specified properties.
             * @function create
             * @memberof m10.directory.CheckAliasRequest
             * @static
             * @param {m10.directory.ICheckAliasRequest=} [properties] Properties to set
             * @returns {m10.directory.CheckAliasRequest} CheckAliasRequest instance
             */
            CheckAliasRequest.create = function create(properties) {
                return new CheckAliasRequest(properties);
            };

            /**
             * Encodes the specified CheckAliasRequest message. Does not implicitly {@link m10.directory.CheckAliasRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.directory.CheckAliasRequest
             * @static
             * @param {m10.directory.ICheckAliasRequest} message CheckAliasRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckAliasRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.handle != null && Object.hasOwnProperty.call(message, "handle"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.handle);
                return writer;
            };

            /**
             * Encodes the specified CheckAliasRequest message, length delimited. Does not implicitly {@link m10.directory.CheckAliasRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.directory.CheckAliasRequest
             * @static
             * @param {m10.directory.ICheckAliasRequest} message CheckAliasRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CheckAliasRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CheckAliasRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.directory.CheckAliasRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.directory.CheckAliasRequest} CheckAliasRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckAliasRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.directory.CheckAliasRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.handle = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CheckAliasRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.directory.CheckAliasRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.directory.CheckAliasRequest} CheckAliasRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CheckAliasRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CheckAliasRequest message.
             * @function verify
             * @memberof m10.directory.CheckAliasRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CheckAliasRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.handle != null && message.hasOwnProperty("handle"))
                    if (!$util.isString(message.handle))
                        return "handle: string expected";
                return null;
            };

            /**
             * Creates a CheckAliasRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.directory.CheckAliasRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.directory.CheckAliasRequest} CheckAliasRequest
             */
            CheckAliasRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.directory.CheckAliasRequest)
                    return object;
                var message = new $root.m10.directory.CheckAliasRequest();
                if (object.handle != null)
                    message.handle = String(object.handle);
                return message;
            };

            /**
             * Creates a plain object from a CheckAliasRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.directory.CheckAliasRequest
             * @static
             * @param {m10.directory.CheckAliasRequest} message CheckAliasRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CheckAliasRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.handle = "";
                if (message.handle != null && message.hasOwnProperty("handle"))
                    object.handle = message.handle;
                return object;
            };

            /**
             * Converts this CheckAliasRequest to JSON.
             * @function toJSON
             * @memberof m10.directory.CheckAliasRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CheckAliasRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CheckAliasRequest;
        })();

        directory.SearchAliasesRequest = (function() {

            /**
             * Properties of a SearchAliasesRequest.
             * @memberof m10.directory
             * @interface ISearchAliasesRequest
             * @property {string|null} [handlePrefix] SearchAliasesRequest handlePrefix
             * @property {number|null} [pageSize] SearchAliasesRequest pageSize
             * @property {string|null} [pageToken] SearchAliasesRequest pageToken
             * @property {string|null} [subject] SearchAliasesRequest subject
             */

            /**
             * Constructs a new SearchAliasesRequest.
             * @memberof m10.directory
             * @classdesc Represents a SearchAliasesRequest.
             * @implements ISearchAliasesRequest
             * @constructor
             * @param {m10.directory.ISearchAliasesRequest=} [properties] Properties to set
             */
            function SearchAliasesRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchAliasesRequest handlePrefix.
             * @member {string} handlePrefix
             * @memberof m10.directory.SearchAliasesRequest
             * @instance
             */
            SearchAliasesRequest.prototype.handlePrefix = "";

            /**
             * SearchAliasesRequest pageSize.
             * @member {number} pageSize
             * @memberof m10.directory.SearchAliasesRequest
             * @instance
             */
            SearchAliasesRequest.prototype.pageSize = 0;

            /**
             * SearchAliasesRequest pageToken.
             * @member {string} pageToken
             * @memberof m10.directory.SearchAliasesRequest
             * @instance
             */
            SearchAliasesRequest.prototype.pageToken = "";

            /**
             * SearchAliasesRequest subject.
             * @member {string} subject
             * @memberof m10.directory.SearchAliasesRequest
             * @instance
             */
            SearchAliasesRequest.prototype.subject = "";

            /**
             * Creates a new SearchAliasesRequest instance using the specified properties.
             * @function create
             * @memberof m10.directory.SearchAliasesRequest
             * @static
             * @param {m10.directory.ISearchAliasesRequest=} [properties] Properties to set
             * @returns {m10.directory.SearchAliasesRequest} SearchAliasesRequest instance
             */
            SearchAliasesRequest.create = function create(properties) {
                return new SearchAliasesRequest(properties);
            };

            /**
             * Encodes the specified SearchAliasesRequest message. Does not implicitly {@link m10.directory.SearchAliasesRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.directory.SearchAliasesRequest
             * @static
             * @param {m10.directory.ISearchAliasesRequest} message SearchAliasesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchAliasesRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.handlePrefix != null && Object.hasOwnProperty.call(message, "handlePrefix"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.handlePrefix);
                if (message.pageSize != null && Object.hasOwnProperty.call(message, "pageSize"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.pageSize);
                if (message.pageToken != null && Object.hasOwnProperty.call(message, "pageToken"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.pageToken);
                if (message.subject != null && Object.hasOwnProperty.call(message, "subject"))
                    writer.uint32(/* id 5, wireType 2 =*/42).string(message.subject);
                return writer;
            };

            /**
             * Encodes the specified SearchAliasesRequest message, length delimited. Does not implicitly {@link m10.directory.SearchAliasesRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.directory.SearchAliasesRequest
             * @static
             * @param {m10.directory.ISearchAliasesRequest} message SearchAliasesRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchAliasesRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchAliasesRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.directory.SearchAliasesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.directory.SearchAliasesRequest} SearchAliasesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchAliasesRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.directory.SearchAliasesRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.handlePrefix = reader.string();
                        break;
                    case 2:
                        message.pageSize = reader.int32();
                        break;
                    case 3:
                        message.pageToken = reader.string();
                        break;
                    case 5:
                        message.subject = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SearchAliasesRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.directory.SearchAliasesRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.directory.SearchAliasesRequest} SearchAliasesRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchAliasesRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchAliasesRequest message.
             * @function verify
             * @memberof m10.directory.SearchAliasesRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchAliasesRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.handlePrefix != null && message.hasOwnProperty("handlePrefix"))
                    if (!$util.isString(message.handlePrefix))
                        return "handlePrefix: string expected";
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    if (!$util.isInteger(message.pageSize))
                        return "pageSize: integer expected";
                if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                    if (!$util.isString(message.pageToken))
                        return "pageToken: string expected";
                if (message.subject != null && message.hasOwnProperty("subject"))
                    if (!$util.isString(message.subject))
                        return "subject: string expected";
                return null;
            };

            /**
             * Creates a SearchAliasesRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.directory.SearchAliasesRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.directory.SearchAliasesRequest} SearchAliasesRequest
             */
            SearchAliasesRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.directory.SearchAliasesRequest)
                    return object;
                var message = new $root.m10.directory.SearchAliasesRequest();
                if (object.handlePrefix != null)
                    message.handlePrefix = String(object.handlePrefix);
                if (object.pageSize != null)
                    message.pageSize = object.pageSize | 0;
                if (object.pageToken != null)
                    message.pageToken = String(object.pageToken);
                if (object.subject != null)
                    message.subject = String(object.subject);
                return message;
            };

            /**
             * Creates a plain object from a SearchAliasesRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.directory.SearchAliasesRequest
             * @static
             * @param {m10.directory.SearchAliasesRequest} message SearchAliasesRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SearchAliasesRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.handlePrefix = "";
                    object.pageSize = 0;
                    object.pageToken = "";
                    object.subject = "";
                }
                if (message.handlePrefix != null && message.hasOwnProperty("handlePrefix"))
                    object.handlePrefix = message.handlePrefix;
                if (message.pageSize != null && message.hasOwnProperty("pageSize"))
                    object.pageSize = message.pageSize;
                if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                    object.pageToken = message.pageToken;
                if (message.subject != null && message.hasOwnProperty("subject"))
                    object.subject = message.subject;
                return object;
            };

            /**
             * Converts this SearchAliasesRequest to JSON.
             * @function toJSON
             * @memberof m10.directory.SearchAliasesRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SearchAliasesRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SearchAliasesRequest;
        })();

        directory.SearchAliasesResponse = (function() {

            /**
             * Properties of a SearchAliasesResponse.
             * @memberof m10.directory
             * @interface ISearchAliasesResponse
             * @property {Array.<m10.directory.IAlias>|null} [aliases] SearchAliasesResponse aliases
             * @property {string|null} [nextPageToken] SearchAliasesResponse nextPageToken
             */

            /**
             * Constructs a new SearchAliasesResponse.
             * @memberof m10.directory
             * @classdesc Represents a SearchAliasesResponse.
             * @implements ISearchAliasesResponse
             * @constructor
             * @param {m10.directory.ISearchAliasesResponse=} [properties] Properties to set
             */
            function SearchAliasesResponse(properties) {
                this.aliases = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SearchAliasesResponse aliases.
             * @member {Array.<m10.directory.IAlias>} aliases
             * @memberof m10.directory.SearchAliasesResponse
             * @instance
             */
            SearchAliasesResponse.prototype.aliases = $util.emptyArray;

            /**
             * SearchAliasesResponse nextPageToken.
             * @member {string} nextPageToken
             * @memberof m10.directory.SearchAliasesResponse
             * @instance
             */
            SearchAliasesResponse.prototype.nextPageToken = "";

            /**
             * Creates a new SearchAliasesResponse instance using the specified properties.
             * @function create
             * @memberof m10.directory.SearchAliasesResponse
             * @static
             * @param {m10.directory.ISearchAliasesResponse=} [properties] Properties to set
             * @returns {m10.directory.SearchAliasesResponse} SearchAliasesResponse instance
             */
            SearchAliasesResponse.create = function create(properties) {
                return new SearchAliasesResponse(properties);
            };

            /**
             * Encodes the specified SearchAliasesResponse message. Does not implicitly {@link m10.directory.SearchAliasesResponse.verify|verify} messages.
             * @function encode
             * @memberof m10.directory.SearchAliasesResponse
             * @static
             * @param {m10.directory.ISearchAliasesResponse} message SearchAliasesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchAliasesResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.aliases != null && message.aliases.length)
                    for (var i = 0; i < message.aliases.length; ++i)
                        $root.m10.directory.Alias.encode(message.aliases[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                if (message.nextPageToken != null && Object.hasOwnProperty.call(message, "nextPageToken"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.nextPageToken);
                return writer;
            };

            /**
             * Encodes the specified SearchAliasesResponse message, length delimited. Does not implicitly {@link m10.directory.SearchAliasesResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.directory.SearchAliasesResponse
             * @static
             * @param {m10.directory.ISearchAliasesResponse} message SearchAliasesResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SearchAliasesResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SearchAliasesResponse message from the specified reader or buffer.
             * @function decode
             * @memberof m10.directory.SearchAliasesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.directory.SearchAliasesResponse} SearchAliasesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchAliasesResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.directory.SearchAliasesResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.aliases && message.aliases.length))
                            message.aliases = [];
                        message.aliases.push($root.m10.directory.Alias.decode(reader, reader.uint32()));
                        break;
                    case 2:
                        message.nextPageToken = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SearchAliasesResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.directory.SearchAliasesResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.directory.SearchAliasesResponse} SearchAliasesResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SearchAliasesResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SearchAliasesResponse message.
             * @function verify
             * @memberof m10.directory.SearchAliasesResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SearchAliasesResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.aliases != null && message.hasOwnProperty("aliases")) {
                    if (!Array.isArray(message.aliases))
                        return "aliases: array expected";
                    for (var i = 0; i < message.aliases.length; ++i) {
                        var error = $root.m10.directory.Alias.verify(message.aliases[i]);
                        if (error)
                            return "aliases." + error;
                    }
                }
                if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                    if (!$util.isString(message.nextPageToken))
                        return "nextPageToken: string expected";
                return null;
            };

            /**
             * Creates a SearchAliasesResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.directory.SearchAliasesResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.directory.SearchAliasesResponse} SearchAliasesResponse
             */
            SearchAliasesResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.directory.SearchAliasesResponse)
                    return object;
                var message = new $root.m10.directory.SearchAliasesResponse();
                if (object.aliases) {
                    if (!Array.isArray(object.aliases))
                        throw TypeError(".m10.directory.SearchAliasesResponse.aliases: array expected");
                    message.aliases = [];
                    for (var i = 0; i < object.aliases.length; ++i) {
                        if (typeof object.aliases[i] !== "object")
                            throw TypeError(".m10.directory.SearchAliasesResponse.aliases: object expected");
                        message.aliases[i] = $root.m10.directory.Alias.fromObject(object.aliases[i]);
                    }
                }
                if (object.nextPageToken != null)
                    message.nextPageToken = String(object.nextPageToken);
                return message;
            };

            /**
             * Creates a plain object from a SearchAliasesResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.directory.SearchAliasesResponse
             * @static
             * @param {m10.directory.SearchAliasesResponse} message SearchAliasesResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SearchAliasesResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.aliases = [];
                if (options.defaults)
                    object.nextPageToken = "";
                if (message.aliases && message.aliases.length) {
                    object.aliases = [];
                    for (var j = 0; j < message.aliases.length; ++j)
                        object.aliases[j] = $root.m10.directory.Alias.toObject(message.aliases[j], options);
                }
                if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                    object.nextPageToken = message.nextPageToken;
                return object;
            };

            /**
             * Converts this SearchAliasesResponse to JSON.
             * @function toJSON
             * @memberof m10.directory.SearchAliasesResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SearchAliasesResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return SearchAliasesResponse;
        })();

        directory.GetObjectUrlRequest = (function() {

            /**
             * Properties of a GetObjectUrlRequest.
             * @memberof m10.directory
             * @interface IGetObjectUrlRequest
             * @property {string|null} [objectId] GetObjectUrlRequest objectId
             */

            /**
             * Constructs a new GetObjectUrlRequest.
             * @memberof m10.directory
             * @classdesc Represents a GetObjectUrlRequest.
             * @implements IGetObjectUrlRequest
             * @constructor
             * @param {m10.directory.IGetObjectUrlRequest=} [properties] Properties to set
             */
            function GetObjectUrlRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GetObjectUrlRequest objectId.
             * @member {string} objectId
             * @memberof m10.directory.GetObjectUrlRequest
             * @instance
             */
            GetObjectUrlRequest.prototype.objectId = "";

            /**
             * Creates a new GetObjectUrlRequest instance using the specified properties.
             * @function create
             * @memberof m10.directory.GetObjectUrlRequest
             * @static
             * @param {m10.directory.IGetObjectUrlRequest=} [properties] Properties to set
             * @returns {m10.directory.GetObjectUrlRequest} GetObjectUrlRequest instance
             */
            GetObjectUrlRequest.create = function create(properties) {
                return new GetObjectUrlRequest(properties);
            };

            /**
             * Encodes the specified GetObjectUrlRequest message. Does not implicitly {@link m10.directory.GetObjectUrlRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.directory.GetObjectUrlRequest
             * @static
             * @param {m10.directory.IGetObjectUrlRequest} message GetObjectUrlRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetObjectUrlRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.objectId != null && Object.hasOwnProperty.call(message, "objectId"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.objectId);
                return writer;
            };

            /**
             * Encodes the specified GetObjectUrlRequest message, length delimited. Does not implicitly {@link m10.directory.GetObjectUrlRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.directory.GetObjectUrlRequest
             * @static
             * @param {m10.directory.IGetObjectUrlRequest} message GetObjectUrlRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GetObjectUrlRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GetObjectUrlRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.directory.GetObjectUrlRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.directory.GetObjectUrlRequest} GetObjectUrlRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetObjectUrlRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.directory.GetObjectUrlRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.objectId = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GetObjectUrlRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.directory.GetObjectUrlRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.directory.GetObjectUrlRequest} GetObjectUrlRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GetObjectUrlRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GetObjectUrlRequest message.
             * @function verify
             * @memberof m10.directory.GetObjectUrlRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GetObjectUrlRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    if (!$util.isString(message.objectId))
                        return "objectId: string expected";
                return null;
            };

            /**
             * Creates a GetObjectUrlRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.directory.GetObjectUrlRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.directory.GetObjectUrlRequest} GetObjectUrlRequest
             */
            GetObjectUrlRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.directory.GetObjectUrlRequest)
                    return object;
                var message = new $root.m10.directory.GetObjectUrlRequest();
                if (object.objectId != null)
                    message.objectId = String(object.objectId);
                return message;
            };

            /**
             * Creates a plain object from a GetObjectUrlRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.directory.GetObjectUrlRequest
             * @static
             * @param {m10.directory.GetObjectUrlRequest} message GetObjectUrlRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GetObjectUrlRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults)
                    object.objectId = "";
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    object.objectId = message.objectId;
                return object;
            };

            /**
             * Converts this GetObjectUrlRequest to JSON.
             * @function toJSON
             * @memberof m10.directory.GetObjectUrlRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GetObjectUrlRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return GetObjectUrlRequest;
        })();

        directory.ObjectUrlResponse = (function() {

            /**
             * Properties of an ObjectUrlResponse.
             * @memberof m10.directory
             * @interface IObjectUrlResponse
             * @property {string|null} [presignedUrl] ObjectUrlResponse presignedUrl
             * @property {string|null} [objectId] ObjectUrlResponse objectId
             * @property {string|null} [url] ObjectUrlResponse url
             */

            /**
             * Constructs a new ObjectUrlResponse.
             * @memberof m10.directory
             * @classdesc Represents an ObjectUrlResponse.
             * @implements IObjectUrlResponse
             * @constructor
             * @param {m10.directory.IObjectUrlResponse=} [properties] Properties to set
             */
            function ObjectUrlResponse(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ObjectUrlResponse presignedUrl.
             * @member {string} presignedUrl
             * @memberof m10.directory.ObjectUrlResponse
             * @instance
             */
            ObjectUrlResponse.prototype.presignedUrl = "";

            /**
             * ObjectUrlResponse objectId.
             * @member {string} objectId
             * @memberof m10.directory.ObjectUrlResponse
             * @instance
             */
            ObjectUrlResponse.prototype.objectId = "";

            /**
             * ObjectUrlResponse url.
             * @member {string} url
             * @memberof m10.directory.ObjectUrlResponse
             * @instance
             */
            ObjectUrlResponse.prototype.url = "";

            /**
             * Creates a new ObjectUrlResponse instance using the specified properties.
             * @function create
             * @memberof m10.directory.ObjectUrlResponse
             * @static
             * @param {m10.directory.IObjectUrlResponse=} [properties] Properties to set
             * @returns {m10.directory.ObjectUrlResponse} ObjectUrlResponse instance
             */
            ObjectUrlResponse.create = function create(properties) {
                return new ObjectUrlResponse(properties);
            };

            /**
             * Encodes the specified ObjectUrlResponse message. Does not implicitly {@link m10.directory.ObjectUrlResponse.verify|verify} messages.
             * @function encode
             * @memberof m10.directory.ObjectUrlResponse
             * @static
             * @param {m10.directory.IObjectUrlResponse} message ObjectUrlResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObjectUrlResponse.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.presignedUrl != null && Object.hasOwnProperty.call(message, "presignedUrl"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.presignedUrl);
                if (message.objectId != null && Object.hasOwnProperty.call(message, "objectId"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.objectId);
                if (message.url != null && Object.hasOwnProperty.call(message, "url"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.url);
                return writer;
            };

            /**
             * Encodes the specified ObjectUrlResponse message, length delimited. Does not implicitly {@link m10.directory.ObjectUrlResponse.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.directory.ObjectUrlResponse
             * @static
             * @param {m10.directory.IObjectUrlResponse} message ObjectUrlResponse message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ObjectUrlResponse.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an ObjectUrlResponse message from the specified reader or buffer.
             * @function decode
             * @memberof m10.directory.ObjectUrlResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.directory.ObjectUrlResponse} ObjectUrlResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObjectUrlResponse.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.directory.ObjectUrlResponse();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.presignedUrl = reader.string();
                        break;
                    case 2:
                        message.objectId = reader.string();
                        break;
                    case 3:
                        message.url = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an ObjectUrlResponse message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.directory.ObjectUrlResponse
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.directory.ObjectUrlResponse} ObjectUrlResponse
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ObjectUrlResponse.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an ObjectUrlResponse message.
             * @function verify
             * @memberof m10.directory.ObjectUrlResponse
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ObjectUrlResponse.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.presignedUrl != null && message.hasOwnProperty("presignedUrl"))
                    if (!$util.isString(message.presignedUrl))
                        return "presignedUrl: string expected";
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    if (!$util.isString(message.objectId))
                        return "objectId: string expected";
                if (message.url != null && message.hasOwnProperty("url"))
                    if (!$util.isString(message.url))
                        return "url: string expected";
                return null;
            };

            /**
             * Creates an ObjectUrlResponse message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.directory.ObjectUrlResponse
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.directory.ObjectUrlResponse} ObjectUrlResponse
             */
            ObjectUrlResponse.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.directory.ObjectUrlResponse)
                    return object;
                var message = new $root.m10.directory.ObjectUrlResponse();
                if (object.presignedUrl != null)
                    message.presignedUrl = String(object.presignedUrl);
                if (object.objectId != null)
                    message.objectId = String(object.objectId);
                if (object.url != null)
                    message.url = String(object.url);
                return message;
            };

            /**
             * Creates a plain object from an ObjectUrlResponse message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.directory.ObjectUrlResponse
             * @static
             * @param {m10.directory.ObjectUrlResponse} message ObjectUrlResponse
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ObjectUrlResponse.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.presignedUrl = "";
                    object.objectId = "";
                    object.url = "";
                }
                if (message.presignedUrl != null && message.hasOwnProperty("presignedUrl"))
                    object.presignedUrl = message.presignedUrl;
                if (message.objectId != null && message.hasOwnProperty("objectId"))
                    object.objectId = message.objectId;
                if (message.url != null && message.hasOwnProperty("url"))
                    object.url = message.url;
                return object;
            };

            /**
             * Converts this ObjectUrlResponse to JSON.
             * @function toJSON
             * @memberof m10.directory.ObjectUrlResponse
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ObjectUrlResponse.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ObjectUrlResponse;
        })();

        directory.CreateImageUrlRequest = (function() {

            /**
             * Properties of a CreateImageUrlRequest.
             * @memberof m10.directory
             * @interface ICreateImageUrlRequest
             * @property {string|null} [mimeType] CreateImageUrlRequest mimeType
             */

            /**
             * Constructs a new CreateImageUrlRequest.
             * @memberof m10.directory
             * @classdesc Represents a CreateImageUrlRequest.
             * @implements ICreateImageUrlRequest
             * @constructor
             * @param {m10.directory.ICreateImageUrlRequest=} [properties] Properties to set
             */
            function CreateImageUrlRequest(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CreateImageUrlRequest mimeType.
             * @member {string|null|undefined} mimeType
             * @memberof m10.directory.CreateImageUrlRequest
             * @instance
             */
            CreateImageUrlRequest.prototype.mimeType = null;

            // OneOf field names bound to virtual getters and setters
            var $oneOfFields;

            /**
             * CreateImageUrlRequest _mimeType.
             * @member {"mimeType"|undefined} _mimeType
             * @memberof m10.directory.CreateImageUrlRequest
             * @instance
             */
            Object.defineProperty(CreateImageUrlRequest.prototype, "_mimeType", {
                get: $util.oneOfGetter($oneOfFields = ["mimeType"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Creates a new CreateImageUrlRequest instance using the specified properties.
             * @function create
             * @memberof m10.directory.CreateImageUrlRequest
             * @static
             * @param {m10.directory.ICreateImageUrlRequest=} [properties] Properties to set
             * @returns {m10.directory.CreateImageUrlRequest} CreateImageUrlRequest instance
             */
            CreateImageUrlRequest.create = function create(properties) {
                return new CreateImageUrlRequest(properties);
            };

            /**
             * Encodes the specified CreateImageUrlRequest message. Does not implicitly {@link m10.directory.CreateImageUrlRequest.verify|verify} messages.
             * @function encode
             * @memberof m10.directory.CreateImageUrlRequest
             * @static
             * @param {m10.directory.ICreateImageUrlRequest} message CreateImageUrlRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateImageUrlRequest.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.mimeType != null && Object.hasOwnProperty.call(message, "mimeType"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.mimeType);
                return writer;
            };

            /**
             * Encodes the specified CreateImageUrlRequest message, length delimited. Does not implicitly {@link m10.directory.CreateImageUrlRequest.verify|verify} messages.
             * @function encodeDelimited
             * @memberof m10.directory.CreateImageUrlRequest
             * @static
             * @param {m10.directory.ICreateImageUrlRequest} message CreateImageUrlRequest message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            CreateImageUrlRequest.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a CreateImageUrlRequest message from the specified reader or buffer.
             * @function decode
             * @memberof m10.directory.CreateImageUrlRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {m10.directory.CreateImageUrlRequest} CreateImageUrlRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateImageUrlRequest.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.m10.directory.CreateImageUrlRequest();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.mimeType = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a CreateImageUrlRequest message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof m10.directory.CreateImageUrlRequest
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {m10.directory.CreateImageUrlRequest} CreateImageUrlRequest
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            CreateImageUrlRequest.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a CreateImageUrlRequest message.
             * @function verify
             * @memberof m10.directory.CreateImageUrlRequest
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CreateImageUrlRequest.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                var properties = {};
                if (message.mimeType != null && message.hasOwnProperty("mimeType")) {
                    properties._mimeType = 1;
                    if (!$util.isString(message.mimeType))
                        return "mimeType: string expected";
                }
                return null;
            };

            /**
             * Creates a CreateImageUrlRequest message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof m10.directory.CreateImageUrlRequest
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {m10.directory.CreateImageUrlRequest} CreateImageUrlRequest
             */
            CreateImageUrlRequest.fromObject = function fromObject(object) {
                if (object instanceof $root.m10.directory.CreateImageUrlRequest)
                    return object;
                var message = new $root.m10.directory.CreateImageUrlRequest();
                if (object.mimeType != null)
                    message.mimeType = String(object.mimeType);
                return message;
            };

            /**
             * Creates a plain object from a CreateImageUrlRequest message. Also converts values to other types if specified.
             * @function toObject
             * @memberof m10.directory.CreateImageUrlRequest
             * @static
             * @param {m10.directory.CreateImageUrlRequest} message CreateImageUrlRequest
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CreateImageUrlRequest.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (message.mimeType != null && message.hasOwnProperty("mimeType")) {
                    object.mimeType = message.mimeType;
                    if (options.oneofs)
                        object._mimeType = "mimeType";
                }
                return object;
            };

            /**
             * Converts this CreateImageUrlRequest to JSON.
             * @function toJSON
             * @memberof m10.directory.CreateImageUrlRequest
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CreateImageUrlRequest.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CreateImageUrlRequest;
        })();

        return directory;
    })();

    return m10;
})();

$root.google = (function() {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    var google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        var protobuf = {};

        protobuf.Empty = (function() {

            /**
             * Properties of an Empty.
             * @memberof google.protobuf
             * @interface IEmpty
             */

            /**
             * Constructs a new Empty.
             * @memberof google.protobuf
             * @classdesc Represents an Empty.
             * @implements IEmpty
             * @constructor
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             */
            function Empty(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Creates a new Empty instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty=} [properties] Properties to set
             * @returns {google.protobuf.Empty} Empty instance
             */
            Empty.create = function create(properties) {
                return new Empty(properties);
            };

            /**
             * Encodes the specified Empty message. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                return writer;
            };

            /**
             * Encodes the specified Empty message, length delimited. Does not implicitly {@link google.protobuf.Empty.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.IEmpty} message Empty message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Empty.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Empty message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Empty();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Empty message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Empty
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Empty} Empty
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Empty.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Empty message.
             * @function verify
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Empty.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                return null;
            };

            /**
             * Creates an Empty message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Empty} Empty
             */
            Empty.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Empty)
                    return object;
                return new $root.google.protobuf.Empty();
            };

            /**
             * Creates a plain object from an Empty message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Empty
             * @static
             * @param {google.protobuf.Empty} message Empty
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Empty.toObject = function toObject() {
                return {};
            };

            /**
             * Converts this Empty to JSON.
             * @function toJSON
             * @memberof google.protobuf.Empty
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Empty.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Empty;
        })();

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Creates a new FileDescriptorSet instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet instance
             */
            FileDescriptorSet.create = function create(properties) {
                return new FileDescriptorSet(properties);
            };

            /**
             * Encodes the specified FileDescriptorSet message. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.file != null && message.file.length)
                    for (var i = 0; i < message.file.length; ++i)
                        $root.google.protobuf.FileDescriptorProto.encode(message.file[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorSet message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorSet.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.IFileDescriptorSet} message FileDescriptorSet message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorSet.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.file && message.file.length))
                            message.file = [];
                        message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorSet message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorSet.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (var i = 0; i < message.file.length; ++i) {
                        var error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                var message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (var i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (var j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Creates a new FileDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto instance
             */
            FileDescriptorProto.create = function create(properties) {
                return new FileDescriptorProto(properties);
            };

            /**
             * Encodes the specified FileDescriptorProto message. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message["package"] != null && Object.hasOwnProperty.call(message, "package"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message["package"]);
                if (message.dependency != null && message.dependency.length)
                    for (var i = 0; i < message.dependency.length; ++i)
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.dependency[i]);
                if (message.messageType != null && message.messageType.length)
                    for (var i = 0; i < message.messageType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.messageType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (var i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.service != null && message.service.length)
                    for (var i = 0; i < message.service.length; ++i)
                        $root.google.protobuf.ServiceDescriptorProto.encode(message.service[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (var i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FileOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.sourceCodeInfo != null && Object.hasOwnProperty.call(message, "sourceCodeInfo"))
                    $root.google.protobuf.SourceCodeInfo.encode(message.sourceCodeInfo, writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.publicDependency != null && message.publicDependency.length)
                    for (var i = 0; i < message.publicDependency.length; ++i)
                        writer.uint32(/* id 10, wireType 0 =*/80).int32(message.publicDependency[i]);
                if (message.weakDependency != null && message.weakDependency.length)
                    for (var i = 0; i < message.weakDependency.length; ++i)
                        writer.uint32(/* id 11, wireType 0 =*/88).int32(message.weakDependency[i]);
                if (message.syntax != null && Object.hasOwnProperty.call(message, "syntax"))
                    writer.uint32(/* id 12, wireType 2 =*/98).string(message.syntax);
                return writer;
            };

            /**
             * Encodes the specified FileDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FileDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.IFileDescriptorProto} message FileDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message["package"] = reader.string();
                        break;
                    case 3:
                        if (!(message.dependency && message.dependency.length))
                            message.dependency = [];
                        message.dependency.push(reader.string());
                        break;
                    case 10:
                        if (!(message.publicDependency && message.publicDependency.length))
                            message.publicDependency = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.publicDependency.push(reader.int32());
                        } else
                            message.publicDependency.push(reader.int32());
                        break;
                    case 11:
                        if (!(message.weakDependency && message.weakDependency.length))
                            message.weakDependency = [];
                        if ((tag & 7) === 2) {
                            var end2 = reader.uint32() + reader.pos;
                            while (reader.pos < end2)
                                message.weakDependency.push(reader.int32());
                        } else
                            message.weakDependency.push(reader.int32());
                        break;
                    case 4:
                        if (!(message.messageType && message.messageType.length))
                            message.messageType = [];
                        message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.service && message.service.length))
                            message.service = [];
                        message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());
                        break;
                    case 12:
                        message.syntax = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (var i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (var i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (var i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (var i = 0; i < message.messageType.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (var i = 0; i < message.enumType.length; ++i) {
                        var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (var i = 0; i < message.service.length; ++i) {
                        var error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (var i = 0; i < message.extension.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    var error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (var i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (var i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (var i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (var i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (var i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (var i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (var i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (var j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (var j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (var j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (var j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (var j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (var j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (var j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                return object;
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Creates a new DescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.DescriptorProto} DescriptorProto instance
             */
            DescriptorProto.create = function create(properties) {
                return new DescriptorProto(properties);
            };

            /**
             * Encodes the specified DescriptorProto message. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.field != null && message.field.length)
                    for (var i = 0; i < message.field.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.field[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.nestedType != null && message.nestedType.length)
                    for (var i = 0; i < message.nestedType.length; ++i)
                        $root.google.protobuf.DescriptorProto.encode(message.nestedType[i], writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                if (message.enumType != null && message.enumType.length)
                    for (var i = 0; i < message.enumType.length; ++i)
                        $root.google.protobuf.EnumDescriptorProto.encode(message.enumType[i], writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.extensionRange != null && message.extensionRange.length)
                    for (var i = 0; i < message.extensionRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ExtensionRange.encode(message.extensionRange[i], writer.uint32(/* id 5, wireType 2 =*/42).fork()).ldelim();
                if (message.extension != null && message.extension.length)
                    for (var i = 0; i < message.extension.length; ++i)
                        $root.google.protobuf.FieldDescriptorProto.encode(message.extension[i], writer.uint32(/* id 6, wireType 2 =*/50).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MessageOptions.encode(message.options, writer.uint32(/* id 7, wireType 2 =*/58).fork()).ldelim();
                if (message.oneofDecl != null && message.oneofDecl.length)
                    for (var i = 0; i < message.oneofDecl.length; ++i)
                        $root.google.protobuf.OneofDescriptorProto.encode(message.oneofDecl[i], writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.reservedRange != null && message.reservedRange.length)
                    for (var i = 0; i < message.reservedRange.length; ++i)
                        $root.google.protobuf.DescriptorProto.ReservedRange.encode(message.reservedRange[i], writer.uint32(/* id 9, wireType 2 =*/74).fork()).ldelim();
                if (message.reservedName != null && message.reservedName.length)
                    for (var i = 0; i < message.reservedName.length; ++i)
                        writer.uint32(/* id 10, wireType 2 =*/82).string(message.reservedName[i]);
                return writer;
            };

            /**
             * Encodes the specified DescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.IDescriptorProto} message DescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            DescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.field && message.field.length))
                            message.field = [];
                        message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 6:
                        if (!(message.extension && message.extension.length))
                            message.extension = [];
                        message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        if (!(message.nestedType && message.nestedType.length))
                            message.nestedType = [];
                        message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 4:
                        if (!(message.enumType && message.enumType.length))
                            message.enumType = [];
                        message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 5:
                        if (!(message.extensionRange && message.extensionRange.length))
                            message.extensionRange = [];
                        message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));
                        break;
                    case 8:
                        if (!(message.oneofDecl && message.oneofDecl.length))
                            message.oneofDecl = [];
                        message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 7:
                        message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());
                        break;
                    case 9:
                        if (!(message.reservedRange && message.reservedRange.length))
                            message.reservedRange = [];
                        message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));
                        break;
                    case 10:
                        if (!(message.reservedName && message.reservedName.length))
                            message.reservedName = [];
                        message.reservedName.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a DescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            DescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (var i = 0; i < message.field.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (var i = 0; i < message.extension.length; ++i) {
                        var error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (var i = 0; i < message.nestedType.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (var i = 0; i < message.enumType.length; ++i) {
                        var error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (var i = 0; i < message.extensionRange.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (var i = 0; i < message.oneofDecl.length; ++i) {
                        var error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (var i = 0; i < message.reservedRange.length; ++i) {
                        var error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (var i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                var message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (var i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (var i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (var i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (var i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (var i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (var i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (var i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (var i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (var j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (var j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (var j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (var j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (var j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (var j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (var j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (var j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.DescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * Creates a new ExtensionRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange instance
                 */
                ExtensionRange.create = function create(properties) {
                    return new ExtensionRange(properties);
                };

                /**
                 * Encodes the specified ExtensionRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ExtensionRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ExtensionRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IExtensionRange} message ExtensionRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ExtensionRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an ExtensionRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ExtensionRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Creates a new ReservedRange instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange instance
                 */
                ReservedRange.create = function create(properties) {
                    return new ReservedRange(properties);
                };

                /**
                 * Encodes the specified ReservedRange message. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.start != null && Object.hasOwnProperty.call(message, "start"))
                        writer.uint32(/* id 1, wireType 0 =*/8).int32(message.start);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 2, wireType 0 =*/16).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified ReservedRange message, length delimited. Does not implicitly {@link google.protobuf.DescriptorProto.ReservedRange.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.IReservedRange} message ReservedRange message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                ReservedRange.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.start = reader.int32();
                            break;
                        case 2:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a ReservedRange message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                ReservedRange.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    var message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * Creates a new FieldDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto instance
             */
            FieldDescriptorProto.create = function create(properties) {
                return new FieldDescriptorProto(properties);
            };

            /**
             * Encodes the specified FieldDescriptorProto message. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.extendee != null && Object.hasOwnProperty.call(message, "extendee"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.extendee);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 3, wireType 0 =*/24).int32(message.number);
                if (message.label != null && Object.hasOwnProperty.call(message, "label"))
                    writer.uint32(/* id 4, wireType 0 =*/32).int32(message.label);
                if (message.type != null && Object.hasOwnProperty.call(message, "type"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int32(message.type);
                if (message.typeName != null && Object.hasOwnProperty.call(message, "typeName"))
                    writer.uint32(/* id 6, wireType 2 =*/50).string(message.typeName);
                if (message.defaultValue != null && Object.hasOwnProperty.call(message, "defaultValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).string(message.defaultValue);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.FieldOptions.encode(message.options, writer.uint32(/* id 8, wireType 2 =*/66).fork()).ldelim();
                if (message.oneofIndex != null && Object.hasOwnProperty.call(message, "oneofIndex"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.oneofIndex);
                if (message.jsonName != null && Object.hasOwnProperty.call(message, "jsonName"))
                    writer.uint32(/* id 10, wireType 2 =*/82).string(message.jsonName);
                return writer;
            };

            /**
             * Encodes the specified FieldDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.FieldDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.IFieldDescriptorProto} message FieldDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 3:
                        message.number = reader.int32();
                        break;
                    case 4:
                        message.label = reader.int32();
                        break;
                    case 5:
                        message.type = reader.int32();
                        break;
                    case 6:
                        message.typeName = reader.string();
                        break;
                    case 2:
                        message.extendee = reader.string();
                        break;
                    case 7:
                        message.defaultValue = reader.string();
                        break;
                    case 9:
                        message.oneofIndex = reader.int32();
                        break;
                    case 10:
                        message.jsonName = reader.string();
                        break;
                    case 8:
                        message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                }
                switch (object.type) {
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                return object;
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {number}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {number}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Creates a new OneofDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto instance
             */
            OneofDescriptorProto.create = function create(properties) {
                return new OneofDescriptorProto(properties);
            };

            /**
             * Encodes the specified OneofDescriptorProto message. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.OneofOptions.encode(message.options, writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.OneofDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.IOneofDescriptorProto} message OneofDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto instance
             */
            EnumDescriptorProto.create = function create(properties) {
                return new EnumDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumDescriptorProto message. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.value != null && message.value.length)
                    for (var i = 0; i < message.value.length; ++i)
                        $root.google.protobuf.EnumValueDescriptorProto.encode(message.value[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.IEnumDescriptorProto} message EnumDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.value && message.value.length))
                            message.value = [];
                        message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (var i = 0; i < message.value.length; ++i) {
                        var error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (var i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.value = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (var j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Creates a new EnumValueDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto instance
             */
            EnumValueDescriptorProto.create = function create(properties) {
                return new EnumValueDescriptorProto(properties);
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.number != null && Object.hasOwnProperty.call(message, "number"))
                    writer.uint32(/* id 2, wireType 0 =*/16).int32(message.number);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.EnumValueOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.EnumValueDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.IEnumValueDescriptorProto} message EnumValueDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.number = reader.int32();
                        break;
                    case 3:
                        message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Creates a new ServiceDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto instance
             */
            ServiceDescriptorProto.create = function create(properties) {
                return new ServiceDescriptorProto(properties);
            };

            /**
             * Encodes the specified ServiceDescriptorProto message. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.method != null && message.method.length)
                    for (var i = 0; i < message.method.length; ++i)
                        $root.google.protobuf.MethodDescriptorProto.encode(message.method[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.ServiceOptions.encode(message.options, writer.uint32(/* id 3, wireType 2 =*/26).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.ServiceDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.IServiceDescriptorProto} message ServiceDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        if (!(message.method && message.method.length))
                            message.method = [];
                        message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (var i = 0; i < message.method.length; ++i) {
                        var error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (var i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (var j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Creates a new MethodDescriptorProto instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto instance
             */
            MethodDescriptorProto.create = function create(properties) {
                return new MethodDescriptorProto(properties);
            };

            /**
             * Encodes the specified MethodDescriptorProto message. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && Object.hasOwnProperty.call(message, "name"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.name);
                if (message.inputType != null && Object.hasOwnProperty.call(message, "inputType"))
                    writer.uint32(/* id 2, wireType 2 =*/18).string(message.inputType);
                if (message.outputType != null && Object.hasOwnProperty.call(message, "outputType"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.outputType);
                if (message.options != null && Object.hasOwnProperty.call(message, "options"))
                    $root.google.protobuf.MethodOptions.encode(message.options, writer.uint32(/* id 4, wireType 2 =*/34).fork()).ldelim();
                if (message.clientStreaming != null && Object.hasOwnProperty.call(message, "clientStreaming"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.clientStreaming);
                if (message.serverStreaming != null && Object.hasOwnProperty.call(message, "serverStreaming"))
                    writer.uint32(/* id 6, wireType 0 =*/48).bool(message.serverStreaming);
                return writer;
            };

            /**
             * Encodes the specified MethodDescriptorProto message, length delimited. Does not implicitly {@link google.protobuf.MethodDescriptorProto.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.IMethodDescriptorProto} message MethodDescriptorProto message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodDescriptorProto.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.name = reader.string();
                        break;
                    case 2:
                        message.inputType = reader.string();
                        break;
                    case 3:
                        message.outputType = reader.string();
                        break;
                    case 4:
                        message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());
                        break;
                    case 5:
                        message.clientStreaming = reader.bool();
                        break;
                    case 6:
                        message.serverStreaming = reader.bool();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodDescriptorProto message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodDescriptorProto.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    var error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                var message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = false;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FileOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             * @returns {google.protobuf.FileOptions} FileOptions instance
             */
            FileOptions.create = function create(properties) {
                return new FileOptions(properties);
            };

            /**
             * Encodes the specified FileOptions message. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.javaPackage != null && Object.hasOwnProperty.call(message, "javaPackage"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.javaPackage);
                if (message.javaOuterClassname != null && Object.hasOwnProperty.call(message, "javaOuterClassname"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.javaOuterClassname);
                if (message.optimizeFor != null && Object.hasOwnProperty.call(message, "optimizeFor"))
                    writer.uint32(/* id 9, wireType 0 =*/72).int32(message.optimizeFor);
                if (message.javaMultipleFiles != null && Object.hasOwnProperty.call(message, "javaMultipleFiles"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.javaMultipleFiles);
                if (message.goPackage != null && Object.hasOwnProperty.call(message, "goPackage"))
                    writer.uint32(/* id 11, wireType 2 =*/90).string(message.goPackage);
                if (message.ccGenericServices != null && Object.hasOwnProperty.call(message, "ccGenericServices"))
                    writer.uint32(/* id 16, wireType 0 =*/128).bool(message.ccGenericServices);
                if (message.javaGenericServices != null && Object.hasOwnProperty.call(message, "javaGenericServices"))
                    writer.uint32(/* id 17, wireType 0 =*/136).bool(message.javaGenericServices);
                if (message.pyGenericServices != null && Object.hasOwnProperty.call(message, "pyGenericServices"))
                    writer.uint32(/* id 18, wireType 0 =*/144).bool(message.pyGenericServices);
                if (message.javaGenerateEqualsAndHash != null && Object.hasOwnProperty.call(message, "javaGenerateEqualsAndHash"))
                    writer.uint32(/* id 20, wireType 0 =*/160).bool(message.javaGenerateEqualsAndHash);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 23, wireType 0 =*/184).bool(message.deprecated);
                if (message.javaStringCheckUtf8 != null && Object.hasOwnProperty.call(message, "javaStringCheckUtf8"))
                    writer.uint32(/* id 27, wireType 0 =*/216).bool(message.javaStringCheckUtf8);
                if (message.ccEnableArenas != null && Object.hasOwnProperty.call(message, "ccEnableArenas"))
                    writer.uint32(/* id 31, wireType 0 =*/248).bool(message.ccEnableArenas);
                if (message.objcClassPrefix != null && Object.hasOwnProperty.call(message, "objcClassPrefix"))
                    writer.uint32(/* id 36, wireType 2 =*/290).string(message.objcClassPrefix);
                if (message.csharpNamespace != null && Object.hasOwnProperty.call(message, "csharpNamespace"))
                    writer.uint32(/* id 37, wireType 2 =*/298).string(message.csharpNamespace);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FileOptions message, length delimited. Does not implicitly {@link google.protobuf.FileOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.IFileOptions} message FileOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FileOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.javaPackage = reader.string();
                        break;
                    case 8:
                        message.javaOuterClassname = reader.string();
                        break;
                    case 10:
                        message.javaMultipleFiles = reader.bool();
                        break;
                    case 20:
                        message.javaGenerateEqualsAndHash = reader.bool();
                        break;
                    case 27:
                        message.javaStringCheckUtf8 = reader.bool();
                        break;
                    case 9:
                        message.optimizeFor = reader.int32();
                        break;
                    case 11:
                        message.goPackage = reader.string();
                        break;
                    case 16:
                        message.ccGenericServices = reader.bool();
                        break;
                    case 17:
                        message.javaGenericServices = reader.bool();
                        break;
                    case 18:
                        message.pyGenericServices = reader.bool();
                        break;
                    case 23:
                        message.deprecated = reader.bool();
                        break;
                    case 31:
                        message.ccEnableArenas = reader.bool();
                        break;
                    case 36:
                        message.objcClassPrefix = reader.string();
                        break;
                    case 37:
                        message.csharpNamespace = reader.string();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FileOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FileOptions} FileOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FileOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                var message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = false;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FileOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {number}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MessageOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             * @returns {google.protobuf.MessageOptions} MessageOptions instance
             */
            MessageOptions.create = function create(properties) {
                return new MessageOptions(properties);
            };

            /**
             * Encodes the specified MessageOptions message. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.messageSetWireFormat != null && Object.hasOwnProperty.call(message, "messageSetWireFormat"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.messageSetWireFormat);
                if (message.noStandardDescriptorAccessor != null && Object.hasOwnProperty.call(message, "noStandardDescriptorAccessor"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.noStandardDescriptorAccessor);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.mapEntry != null && Object.hasOwnProperty.call(message, "mapEntry"))
                    writer.uint32(/* id 7, wireType 0 =*/56).bool(message.mapEntry);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MessageOptions message, length delimited. Does not implicitly {@link google.protobuf.MessageOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.IMessageOptions} message MessageOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MessageOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.messageSetWireFormat = reader.bool();
                        break;
                    case 2:
                        message.noStandardDescriptorAccessor = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 7:
                        message.mapEntry = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MessageOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MessageOptions} MessageOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MessageOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                var message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MessageOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MessageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new FieldOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             * @returns {google.protobuf.FieldOptions} FieldOptions instance
             */
            FieldOptions.create = function create(properties) {
                return new FieldOptions(properties);
            };

            /**
             * Encodes the specified FieldOptions message. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.ctype != null && Object.hasOwnProperty.call(message, "ctype"))
                    writer.uint32(/* id 1, wireType 0 =*/8).int32(message.ctype);
                if (message.packed != null && Object.hasOwnProperty.call(message, "packed"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.packed);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.lazy != null && Object.hasOwnProperty.call(message, "lazy"))
                    writer.uint32(/* id 5, wireType 0 =*/40).bool(message.lazy);
                if (message.jstype != null && Object.hasOwnProperty.call(message, "jstype"))
                    writer.uint32(/* id 6, wireType 0 =*/48).int32(message.jstype);
                if (message.weak != null && Object.hasOwnProperty.call(message, "weak"))
                    writer.uint32(/* id 10, wireType 0 =*/80).bool(message.weak);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified FieldOptions message, length delimited. Does not implicitly {@link google.protobuf.FieldOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.IFieldOptions} message FieldOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.ctype = reader.int32();
                        break;
                    case 2:
                        message.packed = reader.bool();
                        break;
                    case 6:
                        message.jstype = reader.int32();
                        break;
                    case 5:
                        message.lazy = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 10:
                        message.weak = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldOptions} FieldOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                var message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FieldOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {number}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {number}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                var valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new OneofOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             * @returns {google.protobuf.OneofOptions} OneofOptions instance
             */
            OneofOptions.create = function create(properties) {
                return new OneofOptions(properties);
            };

            /**
             * Encodes the specified OneofOptions message. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified OneofOptions message, length delimited. Does not implicitly {@link google.protobuf.OneofOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.IOneofOptions} message OneofOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            OneofOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an OneofOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.OneofOptions} OneofOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            OneofOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                var message = new $root.google.protobuf.OneofOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this OneofOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumOptions} EnumOptions instance
             */
            EnumOptions.create = function create(properties) {
                return new EnumOptions(properties);
            };

            /**
             * Encodes the specified EnumOptions message. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.allowAlias != null && Object.hasOwnProperty.call(message, "allowAlias"))
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.allowAlias);
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 3, wireType 0 =*/24).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.IEnumOptions} message EnumOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        message.allowAlias = reader.bool();
                        break;
                    case 3:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumOptions} EnumOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                var message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new EnumValueOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions instance
             */
            EnumValueOptions.create = function create(properties) {
                return new EnumValueOptions(properties);
            };

            /**
             * Encodes the specified EnumValueOptions message. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 1, wireType 0 =*/8).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified EnumValueOptions message, length delimited. Does not implicitly {@link google.protobuf.EnumValueOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.IEnumValueOptions} message EnumValueOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            EnumValueOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an EnumValueOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            EnumValueOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                var message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new ServiceOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             * @returns {google.protobuf.ServiceOptions} ServiceOptions instance
             */
            ServiceOptions.create = function create(properties) {
                return new ServiceOptions(properties);
            };

            /**
             * Encodes the specified ServiceOptions message. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified ServiceOptions message, length delimited. Does not implicitly {@link google.protobuf.ServiceOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.IServiceOptions} message ServiceOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            ServiceOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a ServiceOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            ServiceOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                var message = new $root.google.protobuf.ServiceOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Creates a new MethodOptions instance using the specified properties.
             * @function create
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             * @returns {google.protobuf.MethodOptions} MethodOptions instance
             */
            MethodOptions.create = function create(properties) {
                return new MethodOptions(properties);
            };

            /**
             * Encodes the specified MethodOptions message. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.deprecated != null && Object.hasOwnProperty.call(message, "deprecated"))
                    writer.uint32(/* id 33, wireType 0 =*/264).bool(message.deprecated);
                if (message.uninterpretedOption != null && message.uninterpretedOption.length)
                    for (var i = 0; i < message.uninterpretedOption.length; ++i)
                        $root.google.protobuf.UninterpretedOption.encode(message.uninterpretedOption[i], writer.uint32(/* id 999, wireType 2 =*/7994).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified MethodOptions message, length delimited. Does not implicitly {@link google.protobuf.MethodOptions.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.IMethodOptions} message MethodOptions message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            MethodOptions.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 33:
                        message.deprecated = reader.bool();
                        break;
                    case 999:
                        if (!(message.uninterpretedOption && message.uninterpretedOption.length))
                            message.uninterpretedOption = [];
                        message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a MethodOptions message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.MethodOptions} MethodOptions
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            MethodOptions.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (var i = 0; i < message.uninterpretedOption.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                var message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (var i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (var j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this MethodOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Creates a new UninterpretedOption instance using the specified properties.
             * @function create
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption instance
             */
            UninterpretedOption.create = function create(properties) {
                return new UninterpretedOption(properties);
            };

            /**
             * Encodes the specified UninterpretedOption message. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.name != null && message.name.length)
                    for (var i = 0; i < message.name.length; ++i)
                        $root.google.protobuf.UninterpretedOption.NamePart.encode(message.name[i], writer.uint32(/* id 2, wireType 2 =*/18).fork()).ldelim();
                if (message.identifierValue != null && Object.hasOwnProperty.call(message, "identifierValue"))
                    writer.uint32(/* id 3, wireType 2 =*/26).string(message.identifierValue);
                if (message.positiveIntValue != null && Object.hasOwnProperty.call(message, "positiveIntValue"))
                    writer.uint32(/* id 4, wireType 0 =*/32).uint64(message.positiveIntValue);
                if (message.negativeIntValue != null && Object.hasOwnProperty.call(message, "negativeIntValue"))
                    writer.uint32(/* id 5, wireType 0 =*/40).int64(message.negativeIntValue);
                if (message.doubleValue != null && Object.hasOwnProperty.call(message, "doubleValue"))
                    writer.uint32(/* id 6, wireType 1 =*/49).double(message.doubleValue);
                if (message.stringValue != null && Object.hasOwnProperty.call(message, "stringValue"))
                    writer.uint32(/* id 7, wireType 2 =*/58).bytes(message.stringValue);
                if (message.aggregateValue != null && Object.hasOwnProperty.call(message, "aggregateValue"))
                    writer.uint32(/* id 8, wireType 2 =*/66).string(message.aggregateValue);
                return writer;
            };

            /**
             * Encodes the specified UninterpretedOption message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.IUninterpretedOption} message UninterpretedOption message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            UninterpretedOption.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 2:
                        if (!(message.name && message.name.length))
                            message.name = [];
                        message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));
                        break;
                    case 3:
                        message.identifierValue = reader.string();
                        break;
                    case 4:
                        message.positiveIntValue = reader.uint64();
                        break;
                    case 5:
                        message.negativeIntValue = reader.int64();
                        break;
                    case 6:
                        message.doubleValue = reader.double();
                        break;
                    case 7:
                        message.stringValue = reader.bytes();
                        break;
                    case 8:
                        message.aggregateValue = reader.string();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an UninterpretedOption message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            UninterpretedOption.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (var i = 0; i < message.name.length; ++i) {
                        var error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                var message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (var i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        var long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    if (options.bytes === String)
                        object.stringValue = "";
                    else {
                        object.stringValue = [];
                        if (options.bytes !== Array)
                            object.stringValue = $util.newBuffer(object.stringValue);
                    }
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (var j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @function toJSON
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Creates a new NamePart instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart instance
                 */
                NamePart.create = function create(properties) {
                    return new NamePart(properties);
                };

                /**
                 * Encodes the specified NamePart message. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.namePart);
                    writer.uint32(/* id 2, wireType 0 =*/16).bool(message.isExtension);
                    return writer;
                };

                /**
                 * Encodes the specified NamePart message, length delimited. Does not implicitly {@link google.protobuf.UninterpretedOption.NamePart.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.INamePart} message NamePart message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                NamePart.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            message.namePart = reader.string();
                            break;
                        case 2:
                            message.isExtension = reader.bool();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    if (!message.hasOwnProperty("namePart"))
                        throw $util.ProtocolError("missing required 'namePart'", { instance: message });
                    if (!message.hasOwnProperty("isExtension"))
                        throw $util.ProtocolError("missing required 'isExtension'", { instance: message });
                    return message;
                };

                /**
                 * Decodes a NamePart message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                NamePart.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    var message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Converts this NamePart to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Creates a new SourceCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo instance
             */
            SourceCodeInfo.create = function create(properties) {
                return new SourceCodeInfo(properties);
            };

            /**
             * Encodes the specified SourceCodeInfo message. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.location != null && message.location.length)
                    for (var i = 0; i < message.location.length; ++i)
                        $root.google.protobuf.SourceCodeInfo.Location.encode(message.location[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified SourceCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.ISourceCodeInfo} message SourceCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            SourceCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.location && message.location.length))
                            message.location = [];
                        message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a SourceCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            SourceCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (var i = 0; i < message.location.length; ++i) {
                        var error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                var message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (var i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (var j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Creates a new Location instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location instance
                 */
                Location.create = function create(properties) {
                    return new Location(properties);
                };

                /**
                 * Encodes the specified Location message. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.span != null && message.span.length) {
                        writer.uint32(/* id 2, wireType 2 =*/18).fork();
                        for (var i = 0; i < message.span.length; ++i)
                            writer.int32(message.span[i]);
                        writer.ldelim();
                    }
                    if (message.leadingComments != null && Object.hasOwnProperty.call(message, "leadingComments"))
                        writer.uint32(/* id 3, wireType 2 =*/26).string(message.leadingComments);
                    if (message.trailingComments != null && Object.hasOwnProperty.call(message, "trailingComments"))
                        writer.uint32(/* id 4, wireType 2 =*/34).string(message.trailingComments);
                    if (message.leadingDetachedComments != null && message.leadingDetachedComments.length)
                        for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                            writer.uint32(/* id 6, wireType 2 =*/50).string(message.leadingDetachedComments[i]);
                    return writer;
                };

                /**
                 * Encodes the specified Location message, length delimited. Does not implicitly {@link google.protobuf.SourceCodeInfo.Location.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.ILocation} message Location message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Location.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes a Location message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            if (!(message.span && message.span.length))
                                message.span = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.span.push(reader.int32());
                            } else
                                message.span.push(reader.int32());
                            break;
                        case 3:
                            message.leadingComments = reader.string();
                            break;
                        case 4:
                            message.trailingComments = reader.string();
                            break;
                        case 6:
                            if (!(message.leadingDetachedComments && message.leadingDetachedComments.length))
                                message.leadingDetachedComments = [];
                            message.leadingDetachedComments.push(reader.string());
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes a Location message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Location.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (var i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (var i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    var message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (var i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (var i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (var j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (var j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Creates a new GeneratedCodeInfo instance using the specified properties.
             * @function create
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo instance
             */
            GeneratedCodeInfo.create = function create(properties) {
                return new GeneratedCodeInfo(properties);
            };

            /**
             * Encodes the specified GeneratedCodeInfo message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.annotation != null && message.annotation.length)
                    for (var i = 0; i < message.annotation.length; ++i)
                        $root.google.protobuf.GeneratedCodeInfo.Annotation.encode(message.annotation[i], writer.uint32(/* id 1, wireType 2 =*/10).fork()).ldelim();
                return writer;
            };

            /**
             * Encodes the specified GeneratedCodeInfo message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.IGeneratedCodeInfo} message GeneratedCodeInfo message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            GeneratedCodeInfo.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.annotation && message.annotation.length))
                            message.annotation = [];
                        message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a GeneratedCodeInfo message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            GeneratedCodeInfo.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (var i = 0; i < message.annotation.length; ++i) {
                        var error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                var message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (var i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (var j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Creates a new Annotation instance using the specified properties.
                 * @function create
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation instance
                 */
                Annotation.create = function create(properties) {
                    return new Annotation(properties);
                };

                /**
                 * Encodes the specified Annotation message. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encode = function encode(message, writer) {
                    if (!writer)
                        writer = $Writer.create();
                    if (message.path != null && message.path.length) {
                        writer.uint32(/* id 1, wireType 2 =*/10).fork();
                        for (var i = 0; i < message.path.length; ++i)
                            writer.int32(message.path[i]);
                        writer.ldelim();
                    }
                    if (message.sourceFile != null && Object.hasOwnProperty.call(message, "sourceFile"))
                        writer.uint32(/* id 2, wireType 2 =*/18).string(message.sourceFile);
                    if (message.begin != null && Object.hasOwnProperty.call(message, "begin"))
                        writer.uint32(/* id 3, wireType 0 =*/24).int32(message.begin);
                    if (message.end != null && Object.hasOwnProperty.call(message, "end"))
                        writer.uint32(/* id 4, wireType 0 =*/32).int32(message.end);
                    return writer;
                };

                /**
                 * Encodes the specified Annotation message, length delimited. Does not implicitly {@link google.protobuf.GeneratedCodeInfo.Annotation.verify|verify} messages.
                 * @function encodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation} message Annotation message or plain object to encode
                 * @param {$protobuf.Writer} [writer] Writer to encode to
                 * @returns {$protobuf.Writer} Writer
                 */
                Annotation.encodeDelimited = function encodeDelimited(message, writer) {
                    return this.encode(message, writer).ldelim();
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer.
                 * @function decode
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @param {number} [length] Message length if known beforehand
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decode = function decode(reader, length) {
                    if (!(reader instanceof $Reader))
                        reader = $Reader.create(reader);
                    var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    while (reader.pos < end) {
                        var tag = reader.uint32();
                        switch (tag >>> 3) {
                        case 1:
                            if (!(message.path && message.path.length))
                                message.path = [];
                            if ((tag & 7) === 2) {
                                var end2 = reader.uint32() + reader.pos;
                                while (reader.pos < end2)
                                    message.path.push(reader.int32());
                            } else
                                message.path.push(reader.int32());
                            break;
                        case 2:
                            message.sourceFile = reader.string();
                            break;
                        case 3:
                            message.begin = reader.int32();
                            break;
                        case 4:
                            message.end = reader.int32();
                            break;
                        default:
                            reader.skipType(tag & 7);
                            break;
                        }
                    }
                    return message;
                };

                /**
                 * Decodes an Annotation message from the specified reader or buffer, length delimited.
                 * @function decodeDelimited
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 * @throws {Error} If the payload is not a reader or valid buffer
                 * @throws {$protobuf.util.ProtocolError} If required fields are missing
                 */
                Annotation.decodeDelimited = function decodeDelimited(reader) {
                    if (!(reader instanceof $Reader))
                        reader = new $Reader(reader);
                    return this.decode(reader, reader.uint32());
                };

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (var i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    var message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (var i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    var object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (var j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this Annotation to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        protobuf.FieldMask = (function() {

            /**
             * Properties of a FieldMask.
             * @memberof google.protobuf
             * @interface IFieldMask
             * @property {Array.<string>|null} [paths] FieldMask paths
             */

            /**
             * Constructs a new FieldMask.
             * @memberof google.protobuf
             * @classdesc Represents a FieldMask.
             * @implements IFieldMask
             * @constructor
             * @param {google.protobuf.IFieldMask=} [properties] Properties to set
             */
            function FieldMask(properties) {
                this.paths = [];
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldMask paths.
             * @member {Array.<string>} paths
             * @memberof google.protobuf.FieldMask
             * @instance
             */
            FieldMask.prototype.paths = $util.emptyArray;

            /**
             * Creates a new FieldMask instance using the specified properties.
             * @function create
             * @memberof google.protobuf.FieldMask
             * @static
             * @param {google.protobuf.IFieldMask=} [properties] Properties to set
             * @returns {google.protobuf.FieldMask} FieldMask instance
             */
            FieldMask.create = function create(properties) {
                return new FieldMask(properties);
            };

            /**
             * Encodes the specified FieldMask message. Does not implicitly {@link google.protobuf.FieldMask.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.FieldMask
             * @static
             * @param {google.protobuf.IFieldMask} message FieldMask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldMask.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.paths != null && message.paths.length)
                    for (var i = 0; i < message.paths.length; ++i)
                        writer.uint32(/* id 1, wireType 2 =*/10).string(message.paths[i]);
                return writer;
            };

            /**
             * Encodes the specified FieldMask message, length delimited. Does not implicitly {@link google.protobuf.FieldMask.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.FieldMask
             * @static
             * @param {google.protobuf.IFieldMask} message FieldMask message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            FieldMask.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes a FieldMask message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.FieldMask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.FieldMask} FieldMask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldMask.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldMask();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        if (!(message.paths && message.paths.length))
                            message.paths = [];
                        message.paths.push(reader.string());
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes a FieldMask message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.FieldMask
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.FieldMask} FieldMask
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            FieldMask.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies a FieldMask message.
             * @function verify
             * @memberof google.protobuf.FieldMask
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldMask.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.paths != null && message.hasOwnProperty("paths")) {
                    if (!Array.isArray(message.paths))
                        return "paths: array expected";
                    for (var i = 0; i < message.paths.length; ++i)
                        if (!$util.isString(message.paths[i]))
                            return "paths: string[] expected";
                }
                return null;
            };

            /**
             * Creates a FieldMask message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldMask
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldMask} FieldMask
             */
            FieldMask.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldMask)
                    return object;
                var message = new $root.google.protobuf.FieldMask();
                if (object.paths) {
                    if (!Array.isArray(object.paths))
                        throw TypeError(".google.protobuf.FieldMask.paths: array expected");
                    message.paths = [];
                    for (var i = 0; i < object.paths.length; ++i)
                        message.paths[i] = String(object.paths[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldMask message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldMask
             * @static
             * @param {google.protobuf.FieldMask} message FieldMask
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldMask.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.arrays || options.defaults)
                    object.paths = [];
                if (message.paths && message.paths.length) {
                    object.paths = [];
                    for (var j = 0; j < message.paths.length; ++j)
                        object.paths[j] = message.paths[j];
                }
                return object;
            };

            /**
             * Converts this FieldMask to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldMask
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldMask.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FieldMask;
        })();

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Creates a new Any instance using the specified properties.
             * @function create
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny=} [properties] Properties to set
             * @returns {google.protobuf.Any} Any instance
             */
            Any.create = function create(properties) {
                return new Any(properties);
            };

            /**
             * Encodes the specified Any message. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encode
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encode = function encode(message, writer) {
                if (!writer)
                    writer = $Writer.create();
                if (message.type_url != null && Object.hasOwnProperty.call(message, "type_url"))
                    writer.uint32(/* id 1, wireType 2 =*/10).string(message.type_url);
                if (message.value != null && Object.hasOwnProperty.call(message, "value"))
                    writer.uint32(/* id 2, wireType 2 =*/18).bytes(message.value);
                return writer;
            };

            /**
             * Encodes the specified Any message, length delimited. Does not implicitly {@link google.protobuf.Any.verify|verify} messages.
             * @function encodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.IAny} message Any message or plain object to encode
             * @param {$protobuf.Writer} [writer] Writer to encode to
             * @returns {$protobuf.Writer} Writer
             */
            Any.encodeDelimited = function encodeDelimited(message, writer) {
                return this.encode(message, writer).ldelim();
            };

            /**
             * Decodes an Any message from the specified reader or buffer.
             * @function decode
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @param {number} [length] Message length if known beforehand
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decode = function decode(reader, length) {
                if (!(reader instanceof $Reader))
                    reader = $Reader.create(reader);
                var end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.Any();
                while (reader.pos < end) {
                    var tag = reader.uint32();
                    switch (tag >>> 3) {
                    case 1:
                        message.type_url = reader.string();
                        break;
                    case 2:
                        message.value = reader.bytes();
                        break;
                    default:
                        reader.skipType(tag & 7);
                        break;
                    }
                }
                return message;
            };

            /**
             * Decodes an Any message from the specified reader or buffer, length delimited.
             * @function decodeDelimited
             * @memberof google.protobuf.Any
             * @static
             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from
             * @returns {google.protobuf.Any} Any
             * @throws {Error} If the payload is not a reader or valid buffer
             * @throws {$protobuf.util.ProtocolError} If required fields are missing
             */
            Any.decodeDelimited = function decodeDelimited(reader) {
                if (!(reader instanceof $Reader))
                    reader = new $Reader(reader);
                return this.decode(reader, reader.uint32());
            };

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                var message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                var object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        return protobuf;
    })();

    return google;
})();

module.exports = $root;
